<!DOCTYPE html>
<head>
  <link rel="stylesheet" href="./style.css">
</head>
<body>
  <webgl-component></webgl-component>
  <script src="./webgl_component.js"></script>

  <script type="module">
    import * as LMGL from '../src/LMGL2.js'
    import { GUI } from './libs/lil-gui.module.min.js';

    const gui = new GUI();

class MyMesh {
  constructor(geometry){
    this.init(geometry);
  }

  async init(geometry) {
    // const model = LMGL.geometryLib.sphere(1);
    console.error(geometry);

    const geo = {
      type: LMGL.GEOMETRY_TYPE.TRIANGLES,
      count: geometry.vertices.length/3,
      indices: geometry.indices,
      attribute: {
        position: {
          value: geometry.vertices,
          itemSize: 3
        },
        normal:{
          value: geometry.normals,
          itemSize: 3
        },
        uv:{
          value: geometry.uvs,
          itemSize: 2
        }
      }
    };

     const loader = new LMGL.DDSLoader(4,4)
     const t4 = await loader.load("./images/NewCubemap.dds")
    //  const t4 = await loader.load("./images/environment.dds")

    const img = await LMGL.loadImage("./images/bian2.jpg");
  const texture_specularMap = new LMGL.ImageTexture(img)

    // const shader = LMGL.shaderLib.physical({
    //   environmentBrdfSampler: map.getTexture(),
    //   reflectionSampler: cubeMap,//cubeMap.getTexture(),
    //   roughness: 0.0,
    //   metallic: 0.2,
    //   baseColor: new LMGL.Vector3(1.0, 0.766, 0.336)
    // });
    const mat = new LMGL.Material({
      vertexShader: `#version 300 es
      precision mediump float;
    uniform vec3 uLightPos;
    out vec2 vUv0;
    out vec3 worldNormal, eyeVec, lightVec, vertPos, lightPos;
     in vec3 position;
     in vec3 normal;
     in vec2 uv;
    out vec3 vPositionW;
    out vec3 vNormalW;

    uniform mat4 projectionMatrix;
    uniform mat4 modelViewMatrix;
    uniform mat4 modelMatrix;

    void subScatterVS(vec4 ecVert) {
        lightVec = uLightPos;
        eyeVec = -ecVert.xyz;
        vertPos = ecVert.xyz;
        lightPos = uLightPos;
    }

    // uniform
    void main() {
        // vertPos = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        vUv0 = uv;
        // vUv0.y =  1.- vUv0.y;
        vPositionW = vec4(modelMatrix * vec4(position, 1.)).xyz;

        mat3 normalWorld = mat3(modelMatrix);
        // normalMatrix
        worldNormal = normalWorld * normal.xyz;
        vNormalW = normalize(worldNormal);
    }`,
      fragmentShader: `#version 300 es
      precision mediump float;
          out vec4 FragColor;
        vec4 dReflection;
        vec3 dAlbedo;
        vec3 dNormalW;
        vec3 dVertexNormalW;
        vec3 dViewDirW;
        vec3 dReflDirW;
        vec3 dDiffuseLight;
        vec3 dSpecularLight;
        vec3 dSpecularity;
        float dGlossiness;
        float dAlpha;
        vec4 ccReflection;
        vec3 ccNormalW;
        vec3 ccSpecularLight;
        float ccSpecularity;
        float ccGlossiness;
        float dAo;

        #define AREA_LUTS_PRECISION highp
        #define texture2D texture
        #define textureCube texture
        #define texture2DProj textureProj
        #define texture2DLodEXT textureLod
        #define texture2DProjLodEXT textureProjLod
        #define textureCubeLodEXT textureLod
        #define texture2DGradEXT textureGrad
        #define texture2DProjGradEXT textureProjGrad
        #define textureCubeGradEXT textureGrad
        #define GL2
        precision highp float;
        #ifdef GL2
            // precision highp sampler2DShadow;
        #endif
        in vec3 vPositionW;
        in vec3 vNormalW;
        in vec2 vUv0;
    uniform sampler2D texture_specularMap;
    uniform samplerCube texture_prefilteredCubeMap128;
    uniform samplerCube texture_prefilteredCubeMap64;
    uniform samplerCube texture_prefilteredCubeMap32;
    uniform samplerCube texture_prefilteredCubeMap16;
    uniform samplerCube texture_prefilteredCubeMap8;
    uniform samplerCube texture_prefilteredCubeMap4;

        uniform vec3 view_position;

        uniform float material_opacity;
        void getOpacity() {
          dAlpha = 1.0;
          dAlpha *= material_opacity;
        }

        void getViewDir() {
          dViewDirW = normalize(view_position - vPositionW);
        }

        void getNormal() {
          dNormalW = normalize(dVertexNormalW);
        }

        void getReflDir() {
          dReflDirW = normalize(-reflect(dViewDirW, dNormalW));
        }

        uniform vec3 material_diffuse;
        void getAlbedo() {
          dAlbedo = vec3(1.0);
          dAlbedo *= material_diffuse.rgb;
        }

        uniform vec3 material_specular;
        void getSpecularity() {
          dSpecularity = vec3(1.0);
          dSpecularity *= material_specular;

          dSpecularity *= texture2D(texture_specularMap, vUv0).rgb;
        }

    uniform float material_shininess;
    void getGlossiness() {
      dGlossiness = 1.0;
      dGlossiness *= material_shininess;
      dGlossiness += 0.0000001;
    }

    void getFresnel() {
      float fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);
      float fresnel2 = fresnel * fresnel;
      fresnel *= fresnel2 * fresnel2;
      fresnel *= dGlossiness * dGlossiness;
      dSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;
    }

    vec3 cubeMapRotate(vec3 refDir) {
        return refDir;
    }
    vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
        float scale = invRecMipSize;
        float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));
        if (abs(vec.x) != M) vec.x *= scale;
        if (abs(vec.y) != M) vec.y *= scale;
        if (abs(vec.z) != M) vec.z *= scale;
        return vec;
    }
    uniform float skyboxIntensity;
    vec3 processEnvironment(vec3 color) {
        return color * skyboxIntensity;
    }
    vec3 decodeRGBM(vec4 rgbm) {
        vec3 color = (8.0 * rgbm.a) * rgbm.rgb;
        return color * color;
    }

    vec3 calcSeam(vec3 vec) {
        vec3 avec = abs(vec);
        float M = max(avec.x, max(avec.y, avec.z));
        return vec3(avec.x != M ? 1.0 : 0.0, avec.y != M ? 1.0 : 0.0, avec.z != M ? 1.0 : 0.0);
    }

    vec3 cubeMapProject(vec3 dir) {
        return cubeMapRotate(dir);
    }

    vec3 applySeam(vec3 vec, vec3 seam, float scale) {
        return vec * (seam * -scale + vec3(1.0));
    }

    float saturate(float x) {
        return clamp(x, 0.0, 1.0);
    }
    vec3 saturate(vec3 x) {
        return clamp(x, vec3(0.0), vec3(1.0));
    }

    vec3 calcReflection(vec3 tReflDirW, float tGlossiness) {
        vec3 refl = cubeMapProject(tReflDirW);
        vec3 seam = calcSeam(refl);
        // vec4 c0 = textureCube(texture_prefilteredCubeMap128, applySeam(refl, seam, 1.0 / 128.0));
        // vec4 c1 = textureCube(texture_prefilteredCubeMap64, applySeam(refl, seam, 2.0 / 128.0));
        // vec4 c2 = textureCube(texture_prefilteredCubeMap32, applySeam(refl, seam, 4.0 / 128.0));
        // vec4 c3 = textureCube(texture_prefilteredCubeMap16, applySeam(refl, seam, 8.0 / 128.0));
        // vec4 c4 = textureCube(texture_prefilteredCubeMap8, applySeam(refl, seam, 16.0 / 128.0));
        vec4 c5 = textureCube(texture_prefilteredCubeMap4, applySeam(refl, seam, 32.0 / 128.0));
        float bias = saturate(1.0 - tGlossiness) * 5.0;
        vec4 cubes0;
        vec4 cubes1;
        // if (bias < 1.0) {
        //     cubes0 = c0;
        //     cubes1 = c1;
        // }
        // else if (bias < 2.0) {
        //     cubes0 = c1;
        //     cubes1 = c2;
        // }
        // else if (bias < 3.0) {
        //     cubes0 = c2;
        //     cubes1 = c3;
        // }
        // else if (bias < 4.0) {
        //     cubes0 = c3;
        //     cubes1 = c4;
        // }
        // else {
        //     cubes0 = c4;
        //     cubes1 = c5;
        // }

                    cubes0 = c5;
            cubes1 = c5;
        vec4 cubeFinal = mix(cubes0, cubes1, fract(bias));
        return processEnvironment(decodeRGBM(cubeFinal).rgb);
    }

    uniform float material_reflectivity;
    void addReflection() {
        dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);
    }
    void addAmbient() {
        vec3 fixedReflDir = fixSeamsStatic(cubeMapRotate(dNormalW), 1.0 - 1.0 / 4.0);
        dDiffuseLight += processEnvironment(decodeRGBM(textureCube(texture_prefilteredCubeMap4, fixedReflDir)).rgb);
    }

    vec3 combineColor() {
        return mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);
    }

    uniform vec3 material_emissive;
    vec3 getEmission() {
        vec3 emission = vec3(1.0);
        emission *= material_emissive;
        return emission;
    }

    vec3 addFog(vec3 color) {
        return color;
    }

    void occludeSpecular() {
        float specOcc = dAo;
        dSpecularLight *= specOcc;
        dReflection *= specOcc;
    }

        void main(){
          dDiffuseLight = vec3(0);
          dSpecularLight = vec3(0);
          dReflection = vec4(0);
          dSpecularity = vec3(0);
          dVertexNormalW = normalize(vNormalW);

          getOpacity();
          getViewDir();
          getNormal();

          getReflDir();
          getAlbedo();

          getSpecularity();

          getGlossiness();
          getFresnel();

          addAmbient();

          addReflection();
          occludeSpecular();

          FragColor.rgb = combineColor();
          // FragColor.rgb += getEmission();
          // // FragColor.rgb = addFog(FragColor.rgb);
          // FragColor.rgb = dSpecularity;
          // vec3 fixedReflDir = fixSeamsStatic(cubeMapRotate(dNormalW), 1.0 - 1.0 / 4.0);
          // FragColor.xyz = textureCube(texture_prefilteredCubeMap4, fixedReflDir).rgb;
          // FragColor.rgb = vec3(dSpecularity);
          FragColor.a = 1.0;

        }
      `,
      uniforms: {
          texture_specularMap: {
            type: "t",
            value: texture_specularMap.getTexture(),
          },
           texture_prefilteredCubeMap4: {
            value: t4._webGLTexture,
            type:"tcube"
          },
          view_position: {
            type: "v3",
            value: new LMGL.Vector3(2.2449, -0.3274, 1.7226),
          },
          material_emissive: {
            type: "v3",
            // value: new LMGL.Vector3(0.1059, 0.1059, 0.1059),
            value: new LMGL.Vector3(0, 0, 0),
          },
          material_specular: {
            type: "v3",
            value: new LMGL.Vector3(0.7725, 0.4353, 0.2941),
          },
          material_diffuse: {
            type: "v3",
            value: new LMGL.Vector3(1, 0.9569, 0),
          },
          material_shininess: {
            type: "f",
            value: 0.3138,
          },
          material_opacity: {
            type: "f",
            value: 0,
          },
          material_reflectivity: {
            type: "f",
            value:  1.8530,
          },
          skyboxIntensity: {
            type: "f",
            value:  1.1000,
          },

          // texture_prefilteredCubeMap8: {value: t8},
          // texture_prefilteredCubeMap16: {value: t16},
          // texture_prefilteredCubeMap32: {value: t32},
          // texture_prefilteredCubeMap64: {value: t64},
          // texture_prefilteredCubeMap128: {value: t128},
        }
    });
    // const mat = new LMGL.Material(shader);
    // this.shader = shader;
    this.mesh = new LMGL.Mesh(geo, mat);
    window.obj = this.mesh
    obj.rotation.y = -Math.PI/2;
    // this.mesh.scalse.set(10,10,10)
    stage.add(this.mesh)
  }
}

let stage

window.onload = async () => {


  document.title = "brdf"
  const width = window.innerWidth
  const height = window.innerHeight

  stage = new LMGL.Stage((err)=>{
    console.error(err);
  },{
    useRightHandedSystem: true,
  })
  stage.init(document.querySelector("#c"), width, height)
  stage.camera.fov = 45;
  stage.camera.near = 1;
  stage.camera.far = 10000;
  stage.camera.position.set(0, 0, 10)


  // console.error(a);
  // window.a = a;

  // const urls = [
  //   "images/cubeMap2/TEXTURE_CUBE_MAP_POSITIVE_X.png",
  //   "images/cubeMap2/TEXTURE_CUBE_MAP_NEGATIVE_X.png",
  //   "images/cubeMap2/TEXTURE_CUBE_MAP_POSITIVE_Y.png",
  //   "images/cubeMap2/TEXTURE_CUBE_MAP_NEGATIVE_Y.png",
  //   "images/cubeMap2/TEXTURE_CUBE_MAP_POSITIVE_Z.png",
  //   "images/cubeMap2/TEXTURE_CUBE_MAP_NEGATIVE_Z.png"
  // ];
  // const images = await LMGL.loadCubeImages(urls)
  // let cubeMap = new LMGL.ImageCubeTexture(images)

  // const img = await LMGL.loadImage("./images/a.png");
  // let map = new LMGL.ImageTexture(img);

  const objLoader = new LMGL.OBJLoader();
  const geometry = await objLoader.load("./obj/hougai.obj")
  new MyMesh(geometry);
  // stage.add(obj.mesh)
  // window.mesh = obj.mesh;

  // const matParam = obj.mesh.material.param;
  // const params={
  //   ior: matParam.ior,
  //   metallic: matParam.metallic,
  //   roughness: matParam.roughness,
  //   baseColor: [ matParam.baseColor.x,matParam.baseColor.y,matParam.baseColor.z ]
  // }

  // gui.add( params, 'ior',0, 5).onChange(v=>{
  //   obj.mesh.material.param.ior = v;
  // });
  // gui.add( params, 'metallic',0, 1).onChange(v=>{
  //   obj.mesh.material.param.metallic = v;
  // });
  // gui.add( params, 'roughness',0, 1).onChange(v=>{
  //   obj.mesh.material.param.roughness = v;
  // });

  // gui.addColor( params, 'baseColor',).onChange(v=>{
  //   obj.mesh.material.param.baseColor.x = v[0]
  //   obj.mesh.material.param.baseColor.y = v[1]
  //   obj.mesh.material.param.baseColor.z = v[2]
  // });
  // gui.open();

stage.addUpdate(1,()=>{
   window.obj && (window.obj.material.uniforms["view_position"].value = stage.camera.position.clone());
})
    // 添加坐标轴
  const axis = new LMGL.meshLib.Axis(100)
  stage.add(axis.meshX)
  stage.add(axis.meshY)
  stage.add(axis.meshZ)
  stage.run()
}

  </script>
</body>
</html>
