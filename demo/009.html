<!DOCTYPE html>
<head>
  <link rel="stylesheet" href="./style.css">
</head>
<body>
  <div class="content">
    <canvas id="c"></canvas>
  </div>
  <script type="module">
    // https://math.hws.edu/graphicsbook/source/webgl/render-to-texture.html
    import * as lmgl from '../src/lmgl.js'
    window.lmgl = lmgl;

  // 平面
  const vsPlane = `
    precision mediump float;
    attribute vec3 aPosition;
    attribute vec2 aUv;
    varying vec2 vUv;
    uniform mat4 projectionMatrix;
    uniform mat4 modelViewMatrix;

    void main() {
      vUv = aUv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(aPosition, 1.0);
    }
  `

  const fsPlane = `
    precision mediump float;
    uniform sampler2D texture;
    varying vec2 vUv;

    void main() {
      gl_FragColor = texture2D(texture, vUv);;
    }
    `

  // 程序纹理
  const vsTexture = `
      attribute vec2 a_coords;
      uniform vec2 translation;
      void main() {
          gl_Position = vec4(a_coords + translation, 0, 1);
      }`

  const fsTexture = `
      precision mediump float;
      uniform vec4 color;
      void main() {
          gl_FragColor = color;
      }`

  let stage
  // This is the number of disks.
  const DISK_COUNT = 30;
  // This is the size of the disks.
  const DISK_DIAMETER = 0.6;

  // 动态程序生成的纹理
  class Disks {
    constructor(stage) {
      this.stage = stage;
      this.diskVelocities = new Array(DISK_COUNT);
      this.diskCenters = new Array(DISK_COUNT);
      this.diskColors = new Array(DISK_COUNT);

      let diskCoords = new Array(2*64);
      for (let i = 0; i < 64; i++) {
          let angle = i/64 * 2*Math.PI;
          diskCoords[2*i] = DISK_DIAMETER/2 * Math.cos(angle);
          diskCoords[2*i+1] = DISK_DIAMETER/2 * Math.sin(angle);
      }
      const geoInfo = {
        count: 64,
        attribute: {
          a_coords: {
            value: diskCoords,
            itemSize: 2
          },
        },
      };

      const matInfo = {
        vertexShader: vsTexture,
        fragmentShader: fsTexture,
        uniforms: {
          translation:{
            value: {x:0,y:0},
            type: "v2"
          },
          color:{
            value: {x:0,y:1,z:0,w:1},
            type: "v4"
          }
        }
      }
      this.mesh = new lmgl.Mesh(geoInfo, matInfo);
        // 深度和混合互斥
      this.mesh.material.blending = true;
      this.mesh.material.needUpdate = true;
      this.mesh.material.blendingType = lmgl.BLENDING_TYPE.RGB_A;
      this.mesh.material.blendRGBASrc = lmgl.BLENDING_FACTOR.ONE_MINUS_SRC_ALPHA;
      this.mesh.material.blendRGBADst = lmgl.BLENDING_FACTOR.ONE_MINUS_SRC_ALPHA;
      this.mesh.material.blendRGB_ASrc = lmgl.BLENDING_FACTOR.ONE;
      this.mesh.material.blendRGB_ADst = lmgl.BLENDING_FACTOR.ONE;
      this.mesh.material.depthTest = false;

      this.createDiskData();
      this.updateDiskPositions();
    }

    updateDiskPositions() {
      let {diskCenters, diskVelocities} = this;

      for (let i = 0; i < DISK_COUNT; i++) {
          diskCenters[i][0] += diskVelocities[i][0];
          if (diskCenters[i][0] < -1) {
              diskCenters[i][0] += 2;
          }
          else if (diskCenters[i][0] > 1) {
              diskCenters[i][0] -=2;
          }
          diskCenters[i][1] += diskVelocities[i][1];
          if (diskCenters[i][1] < -1) {
              diskCenters[i][1] += 2;
          }
          else if (diskCenters[i][1] > 1) {
              diskCenters[i][1] -=2;
          }
          if (Math.random() < 0.02) {
              let angle = Math.random()*2*Math.PI;
              let speed = 0.003 + 0.01*Math.random();
              diskVelocities[i] = [ speed*Math.cos(angle), speed*Math.sin(angle) ];
          }
      }
    }

    createDiskData() {
      let {diskCenters, diskVelocities, diskColors} = this;

      for (let i = 0; i < DISK_COUNT; i++) {
          diskColors[i] = [ Math.random(), Math.random(), Math.random(), 0.5 ];
          diskCenters[i] = [ 2*Math.random() - 1, 2*Math.random() - 1 ];
          let angle = Math.random()*2*Math.PI;
          let speed = 0.003 + 0.01*Math.random();
          diskVelocities[i] = [ speed*Math.cos(angle), speed*Math.sin(angle) ];
      }
    }

    drawDisks() {
      let {diskCenters, diskColors, stage, mesh} = this;
      function disk(i, extraTranslateX, extraTranslateY) {
          const color = diskColors[i];
          mesh.material.uniforms["color"].value = {
            x: color[0],
            y: color[1],
            z: color[2],
            w: color[3],
          };
          mesh.material.uniforms["translation"].value = {
            x: diskCenters[i][0] + extraTranslateX,
            y: diskCenters[i][1] + extraTranslateY
          }
          mesh.geometry.type = lmgl.GEOMETRY_TYPE.TRIANGLE_FAN
          stage.renderer.renderMesh(mesh);

          mesh.material.uniforms["color"].value = {
            x: 0,
            y: 0,
            z: 0,
            w: 1,
          };
          mesh.geometry.type = lmgl.GEOMETRY_TYPE.LINE_LOOP
          stage.renderer.renderMesh(mesh);
      }

      let r = DISK_DIAMETER/2;  // disk radius
      for (let i = 0; i < DISK_COUNT; i++) {
          disk(i,0,0);  // draw the disk with no extra translation (in its usual position)
          if (diskCenters[i][0] < -1 + r) { // disk hangs off left edge, draw it again on the right side
              disk(i,2,0);
              disk(i,2,2);    // in case it also hangs off the bottom (in that case, we need three copies)
              disk(i,2,-2);   // in case it also hangs off the top
          }
          if (diskCenters[i][0] > 1 - r) { // disk hangs off right edge, draw it again on the left side
              disk(i,-2,0);
              disk(i,-2,2);    // in case it also hangs off the bottom
              disk(i,-2,-2);  // in case it also hangs off the top
          }
          if (diskCenters[i][1] < -1 + r) { // hangs off the bottom
              disk(i,0,2);
          }
          if (diskCenters[i][1] > 1 - r) { // hangs off the top
              disk(i,0,-2);
          }
      }
  }

  }

  // 平面
  class Plane {
    constructor() {
      const center = {
        x: 0,
        y: 0
      }
      const size = 2
      const geo = {
        attribute: {
          aPosition: {
            value: [
              center.x - size, center.y - size, 0,
              center.x - size, center.y + size, 0,
              center.x + size, center.y + size, 0,
              center.x + size, center.y - size, 0,
            ],
            itemSize: 3
          },
          aUv:{
            value: [ 0,1, 0,0, 1,0, 1,1],
            itemSize: 2
          },
        },
        indices: [0,1,2, 2,3,0]
      };

      const mat = {
        vertexShader: vsPlane,
        fragmentShader: fsPlane,
        uniforms: {
          texture: {type: "t", value: null}
        }
      }

      this.mesh = new lmgl.Mesh(geo, mat);
    }
  }

  window.onload = () => {
    document.title = "FBO-渲染到纹理"
    const radio = devicePixelRatio
    let width = window.innerWidth
    let height = window.innerHeight

    window.addEventListener("resize", ()=>{
      width = window.innerWidth
      height = window.innerHeight
    })

    stage = new lmgl.Stage()
    stage.init(document.querySelector("#c"), width, height)
    stage.camera.position.set(0, 0, 10)

    // 自定义渲染
    stage.setRenderState(false)
    const webgl = lmgl.webgl;
    const gl = stage.getGl()

    const disks = new Disks(stage);
    const plane = new Plane();

    const textureSize = {
      w: 512,
      h: 512
    }
    const renderTarget = new lmgl.RenderTarget(textureSize.w, textureSize.h);

    stage.addUpdate("loop",()=>{
      stage.renderer.setRenderTarget(renderTarget.getFrameBuffer());
      stage.renderer.clear();
      webgl.setViewPort(gl, textureSize.w, textureSize.h)
      disks.updateDiskPositions();
      disks.drawDisks();

      webgl.setViewPort(gl, width*radio, height*radio)
      stage.renderer.setRenderTarget(null);
      stage.renderer.clear();
      plane.mesh.material.uniforms["texture"].value = renderTarget.getTexture();
      stage.renderer.renderMesh(plane.mesh);

      plane.mesh.rotation.y += 0.01;
    })


    // stage.add(mesh)
    stage.run()
  }

  </script>
</body>
</html>
