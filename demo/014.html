<!DOCTYPE html>
<head>
  <link rel="stylesheet" href="./style.css">
</head>
<body>
  <div class="content">
    <canvas id="c"></canvas>
  </div>
  <script type="module">
    import * as lmgl from '../src/lmgl.js'
    import teapotModel from './module/teapotModel.js'
    import {cube} from './module/cubeModel.js'

    const dataModel = teapotModel//cube(10)
    window.lmgl = lmgl;


  // 阴影接收平面
  class Plane {
    constructor(lightDirction) {
      const size = 5;
      const geo = {
        attribute: {
          aNormal: {
            value: [
              0,0,-1,
              0,0,-1,
              0,0,-1,
              0,0,-1,
            ],
            itemSize: 3
          },
          aPosition: {
            value: [
             - size, - size, 0,
             - size, + size, 0,
               size, + size, 0,
               size, - size, 0,
            ],
            itemSize: 3
          },
        },
        indices: [0,1,2, 2,3,0]
      };

      const lambert = lmgl.shaderLib.lambert()
      const lambertMat = new lmgl.Material({
        uniforms: {
          diffuseColor: {value: {x:1,y:0,z:0}, type:"v3"},
          lightDirction: {value: lightDirction, type:"v3"},
        }
      },lambert)
      this.mesh = new lmgl.Mesh(geo, lambertMat);
      this.mat = lambertMat
    }
  }

  // 产生阴影的模型
  class CastShadow {
    constructor(lightDirction) {
      const geoInfo = {
        attribute: {
          aPosition: {
            value: dataModel.vertexPositions,
            itemSize: 3
          },
          aNormal: {
            value: dataModel.vertexNormals,
            itemSize: 3
          },
        },
        indices: dataModel.indices
      };

      const lambert = lmgl.shaderLib.lambert()
      const lambertMat = new lmgl.Material({
        uniforms: {
          diffuseColor: {value: {x:0,y:1,z:0}, type:"v3"},
          lightDirction: {value: lightDirction, type:"v3"},
        }
      },lambert)

      this.mesh = new lmgl.Mesh(geoInfo, lambertMat);
      this.mesh.scale.set(0.1,0.1,0.1)
      this.mat = lambertMat
    }
  }

  window.onload = () => {
    document.title = "shadowmap"
    const radio = devicePixelRatio
    let width = window.innerWidth
    let height = window.innerHeight

    window.addEventListener("resize", ()=>{
      width = window.innerWidth
      height = window.innerHeight
    })

    var stage = new lmgl.Stage()
    stage.init(document.querySelector("#c"), width, height)
    stage.camera.position.set(0, 2, 10)
    stage.camera.lookAt(new lmgl.Vector3(0, 0, 0));
    // new lmgl.Axis(100, stage)

    const lightDirction = new lmgl.Vector3(1,0,0);


    const plane = new Plane(lightDirction);
    plane.mesh.rotation.x = Math.PI/2;
    plane.mesh.position.y = -0.8
    stage.add(plane.mesh)

    const cast = new CastShadow(lightDirction)
    stage.add(cast.mesh)

    // plane.mesh.material = depthMat
    // cast.mesh.material = depthMat;

    // 自定义渲染
    stage.setRenderState(false)
    const webgl = lmgl.webgl;
    const gl = stage.getGl()
    const shadowmapTextureSize = {
      w: width*radio,
      h: height*radio
    }
    const renderTarget = new lmgl.RenderTarget(shadowmapTextureSize.w, shadowmapTextureSize.h);
    const camera = stage.camera

    // 设置相机的位置为光源位置
    const lightPosition = new lmgl.Vector3(2,2,0);
    const lightCamera = camera.clone();
    lightCamera.position.copy(lightPosition)
    lightCamera.lookAt(new lmgl.Vector3(0, 0, 0));
    lightCamera.updateProjectionMatrix()
    lightCamera.updateMatrix()
    lightCamera.updateMatrixWorld();
    window.aaa = lightCamera
    // lm.control.camera = lightCamera
    const lightMVPCast = new lmgl.Matrix4();
    lightMVPCast.copy(lightCamera.projectionMatrix)
    lightMVPCast.multiply(lightCamera.matrixWorldInverse);
    lightMVPCast.multiply(cast.mesh.matrix);

     const lightMVPPlane = new lmgl.Matrix4();
    lightMVPPlane.copy(lightCamera.projectionMatrix)
    lightMVPPlane.multiply(lightCamera.matrixWorldInverse);
    lightMVPPlane.multiply(plane.mesh.matrix);

    const depth = lmgl.shaderLib.depth()
    const depthMat = new lmgl.Material(depth,{
       uniforms: {
          uLightMVP: {"type":"m4",value: null},
        }
    })

    function renderDepth() {
      // gl.disable(gl.CULL_FACE);
      gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFrameBuffer());
      gl.bindRenderbuffer(gl.RENDERBUFFER, renderTarget.getRenderBuffer());

      stage.renderer.clear();
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      webgl.setViewPort(gl, shadowmapTextureSize.w, shadowmapTextureSize.h)
      plane.mesh.material = depthMat;
      plane.mesh.material.uniforms["uLightMVP"].value = lightMVPPlane.elements;
      plane.mesh.material.setUniform();
      stage.renderer.renderMesh(plane.mesh,lightCamera);

      cast.mesh.material = depthMat;
      cast.mesh.material.setUniform();
      cast.mesh.material.uniforms["uLightMVP"].value = lightMVPCast.elements;
      stage.renderer.renderMesh(cast.mesh,lightCamera);
    }

    function renderShadow() {
      camera.lookAt(new lmgl.Vector3(0, 0, 0));
      camera.updateProjectionMatrix()
      camera.updateMatrix()
      camera.updateMatrixWorld();

      // stage.renderer.setRenderTarget(null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      // gl.enable(gl.CULL_FACE);
      stage.renderer.clear();
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      webgl.setViewPort(gl, width*radio, height*radio)
      const shadowMap = lmgl.shaderLib.shadowMap()
      const shadowMapMat = new lmgl.Material({
        uniforms: {
          uLightMVP: {"type":"m4",value: null},
          uShadowMap: {type: "t", value: renderTarget.getTexture()}
        }
      },shadowMap);

      plane.mesh.material = shadowMapMat;
      plane.mesh.material.uniforms["uLightMVP"].value = lightMVPPlane.elements;
      plane.mesh.material.setUniform();
      stage.renderer.renderMesh(plane.mesh);

      cast.mesh.material = shadowMapMat;
      cast.mesh.material.uniforms["uLightMVP"].value = lightMVPCast.elements;
      cast.mesh.material.setUniform();
      stage.renderer.renderMesh(cast.mesh);
    }

    // renderDepth()
    // renderShadow()


    stage.addUpdate("loop",()=>{
      renderDepth()
      renderShadow()
        // cast.mesh.material.setUniform();
        // stage.renderer.renderMesh(cast.mesh);

        // plane.mesh.material.setUniform();
        // stage.renderer.renderMesh(plane.mesh);

      // stage.renderer.setRenderTarget(renderTarget.getFrameBuffer());
      // stage.renderer.clear();
      // webgl.setViewPort(gl, textureSize.w, textureSize.h)
      // disks.updateDiskPositions();
      // disks.drawDisks();

      // webgl.setViewPort(gl, width*radio, height*radio)
      // stage.renderer.setRenderTarget(null);
      // stage.renderer.clear();
      // plane.mesh.material.uniforms["texture"].value = renderTarget.getTexture();
      // stage.renderer.renderMesh(plane.mesh);

      // plane.mesh.rotation.y += 0.01;
    })


    // stage.add(mesh)
    stage.run()
  }

  </script>
</body>
</html>
