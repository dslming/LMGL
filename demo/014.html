<!DOCTYPE html>
<head>
  <link rel="stylesheet" href="./style.css">
</head>
<body>
  <div class="content">
    <canvas id="c"></canvas>
  </div>
  <script type="module">
    import * as lmgl from '../src/lmgl.js'
    import teapotModel from './module/teapotModel.js'
    import {cube} from './module/cubeModel.js'

    const dataModel = teapotModel//cube(10)
    window.lmgl = lmgl;


  // 阴影接收平面
  class Plane {
    constructor(lightDirction) {
      const size = 5;
      const geo = {
        attribute: {
          aNormal: {
            value: [
              0,0,-1,
              0,0,-1,
              0,0,-1,
              0,0,-1,
            ],
            itemSize: 3
          },
          aPosition: {
            value: [
             - size, - size, 0,
             - size, + size, 0,
               size, + size, 0,
               size, - size, 0,
            ],
            itemSize: 3
          },
        },
        indices: [0,1,2, 2,3,0]
      };

      const lambert = lmgl.shaderLib.lambert()
      const lambertMat = new lmgl.Material({
        uniforms: {
          diffuseColor: {value: {x:1,y:0,z:0}, type:"v3"},
          lightDirction: {value: lightDirction, type:"v3"},
        }
      },lambert)
      this.mesh = new lmgl.Mesh(geo, lambertMat);
      this.mat = lambertMat
    }
  }

  // 产生阴影的模型
  class CastShadow {
    constructor(lightDirction) {
      const geoInfo = {
        attribute: {
          aPosition: {
            value: dataModel.vertexPositions,
            itemSize: 3
          },
          aNormal: {
            value: dataModel.vertexNormals,
            itemSize: 3
          },
        },
        indices: dataModel.indices
      };

      const lambert = lmgl.shaderLib.lambert()
      const lambertMat = new lmgl.Material({
        uniforms: {
          diffuseColor: {value: {x:0,y:1,z:0}, type:"v3"},
          lightDirction: {value: lightDirction, type:"v3"},
        }
      },lambert)

      this.mesh = new lmgl.Mesh(geoInfo, lambertMat);
      this.mesh.scale.set(0.1,0.1,0.1)
      this.mat = lambertMat
    }
  }

  window.onload = () => {
    document.title = "shadowmap"
    const radio = devicePixelRatio
    let width = window.innerWidth
    let height = window.innerHeight

    window.addEventListener("resize", ()=>{
      width = window.innerWidth
      height = window.innerHeight
    })

    var stage = new lmgl.Stage()
    stage.init(document.querySelector("#c"), width, height)
    stage.camera.position.set(0, 0, 10)
    // new lmgl.Axis(100, stage)

    const lightDirction = new lmgl.Vector3(1,0,0);


    const plane = new Plane(lightDirction);
    plane.mesh.rotation.x = Math.PI/2;
    plane.mesh.position.y = -0.8
    // stage.add(plane.mesh)

    const cast = new CastShadow(lightDirction)
    stage.add(cast.mesh)

    // plane.mesh.material = depthMat
    // cast.mesh.material = depthMat;

    // 自定义渲染
    stage.setRenderState(false)
    const webgl = lmgl.webgl;
    const gl = stage.getGl()
    const shadowmapTextureSize = {
      w: 512,
      h: 512
    }
    // const renderTarget = new lmgl.RenderTarget(shadowmapTextureSize.w, shadowmapTextureSize.h);
    const camera = stage.camera

    // 设置相机的位置为光源位置
    const lightPosition = new lmgl.Vector3(10,0,0);
    const cameraPosition = new lmgl.Vector3().copy(camera.position)
    camera.position.copy(lightPosition)
    camera.updateProjectionMatrix()
    camera.updateMatrix()
    camera.updateMatrixWorld()
    const lightMVP = new lmgl.Matrix4();
    lightMVP.copy(camera.projectionMatrix)
    lightMVP.multiply(camera.matrixWorldInverse);
    lightMVP.multiply(lightMVP, cast.mesh.matrix);
    const depth = lmgl.shaderLib.depth()
    const depthMat = new lmgl.Material({
        uniforms: {
          lightMVP: {"type":"m4",value: lightMVP.elements},
          viewMatrix: {"type":"m4",value: camera.matrixWorldInverse.elements},
          modelMatrix: {"type":"m4",value: cast.mesh.matrix.elements},
        }
      },depth)
    cast.mesh.material = depthMat;
    cast.mesh.material.setUniform();
    stage.renderer.renderMesh(cast.mesh);
    // cast.mesh.material.uniforms["lightMVP"].value = ;
    // cast.mesh.material.setUniform();
    // stage.renderer.renderMesh(cast.mesh);
    // stage.renderer.setRenderTarget(renderTarget.getFrameBuffer());
    // stage.renderer.clear();
    // webgl.setViewPort(gl, shadowmapTextureSize.w, shadowmapTextureSize.h)
    // stage.renderer.render();

    stage.addUpdate("loop",()=>{
        cast.mesh.material.setUniform();
        stage.renderer.renderMesh(cast.mesh);

      // stage.renderer.setRenderTarget(renderTarget.getFrameBuffer());
      // stage.renderer.clear();
      // webgl.setViewPort(gl, textureSize.w, textureSize.h)
      // disks.updateDiskPositions();
      // disks.drawDisks();

      // webgl.setViewPort(gl, width*radio, height*radio)
      // stage.renderer.setRenderTarget(null);
      // stage.renderer.clear();
      // plane.mesh.material.uniforms["texture"].value = renderTarget.getTexture();
      // stage.renderer.renderMesh(plane.mesh);

      // plane.mesh.rotation.y += 0.01;
    })


    // stage.add(mesh)
    stage.run()
  }

  </script>
</body>
</html>
