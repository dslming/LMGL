<!DOCTYPE html>
<head>
  <link rel="stylesheet" href="./style.css">
</head>
<body>
  <div class="content">
    <canvas id="c"></canvas>
  </div>
  <script type="module">
    import * as lmgl from '../src/lmgl.js'
    import teapotModel from './module/teapotModel.js'
    import {cube} from './module/cubeModel.js'

    const dataModel = teapotModel//cube(10)
    window.lmgl = lmgl;


  // 阴影接收平面
  class Plane {
    constructor(size) {
      const vsPlane = `
        precision mediump float;
        attribute vec3 aPosition;
        attribute vec2 aUv;
        varying vec2 vUv;
        uniform mat4 projectionMatrix;
        uniform mat4 modelViewMatrix;

        void main() {
          vUv = aUv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(aPosition, 1.0);
        }
      `

      const fsPlane = `
        precision mediump float;
        uniform sampler2D texture;
        varying vec2 vUv;

        void main() {
          gl_FragColor = texture2D(texture, vUv);
          gl_FragColor = vec4(0.1,0.,0.,1.);
        }
        `

      const center = {
        x: 0,
        y: 0
      }
      const geo = {
        attribute: {
          aPosition: {
            value: [
              center.x - size, center.y - size, 0,
              center.x - size, center.y + size, 0,
              center.x + size, center.y + size, 0,
              center.x + size, center.y - size, 0,
            ],
            itemSize: 3
          },
          aUv:{
            value: [ 0,1, 0,0, 1,0, 1,1],
            itemSize: 2
          },
        },
        indices: [0,1,2, 2,3,0]
      };

      const mat = {
        vertexShader: vsPlane,
        fragmentShader: fsPlane,
        // uniforms: {
        //   texture: {type: "t", value: null}
        // }
      }

      this.mesh = new lmgl.Mesh(geo, mat);
    }
  }

  window.onload = () => {
    document.title = "shadowmap"
    const radio = devicePixelRatio
    let width = window.innerWidth
    let height = window.innerHeight

    window.addEventListener("resize", ()=>{
      width = window.innerWidth
      height = window.innerHeight
    })

    var stage = new lmgl.Stage()
    stage.init(document.querySelector("#c"), width, height)
    stage.camera.position.set(0, 5, 10)
    new lmgl.Axis(100, stage)

    // 接收阴影的平面
    const plane = new Plane(5);
    plane.mesh.rotation.x = Math.PI/2;
    plane.mesh.position.y = -0.8
    stage.add(plane.mesh)

    // 产生阴影的模型
    const geoInfo = {
      attribute: {
        aPosition: {
          value: dataModel.vertexPositions,
          itemSize: 3
        },
        aNormal: {
          value: dataModel.vertexNormals,
          itemSize: 3
        },
      },
      indices: dataModel.indices
    };
    const castMesh = new lmgl.LambertMesh(geoInfo)
    castMesh.mesh.scale.set(0.1,0.1,0.1)
    castMesh.mesh.position.y = 0
    stage.add(castMesh.mesh)


    // 自定义渲染
    stage.setRenderState(false)
    const webgl = lmgl.webgl;
    const gl = stage.getGl()
    const shadowmapTextureSize = {
      w: 512,
      h: 512
    }
    const renderTarget = new lmgl.RenderTarget(shadowmapTextureSize.w, shadowmapTextureSize.h);

    // 设置相机的位置为光源位置
    const lightPosition = new lmgl.Vector3(10,10,0);
    const cameraPosition = new lmgl.Vector3().copy(stage.camera.position)
    stage.camera.position.copy(lightPosition)

    stage.renderer.setRenderTarget(renderTarget.getFrameBuffer());
    stage.renderer.clear();
    webgl.setViewPort(gl, shadowmapTextureSize.w, shadowmapTextureSize.h)

    // stage.addUpdate("loop",()=>{
      // stage.renderer.setRenderTarget(renderTarget.getFrameBuffer());
      // stage.renderer.clear();
      // webgl.setViewPort(gl, textureSize.w, textureSize.h)
      // disks.updateDiskPositions();
      // disks.drawDisks();

      // webgl.setViewPort(gl, width*radio, height*radio)
      // stage.renderer.setRenderTarget(null);
      // stage.renderer.clear();
      // plane.mesh.material.uniforms["texture"].value = renderTarget.getTexture();
      // stage.renderer.renderMesh(plane.mesh);

      // plane.mesh.rotation.y += 0.01;
    // })


    // stage.add(mesh)
    stage.run()
  }

  </script>
</body>
</html>
