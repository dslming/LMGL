<!DOCTYPE html>
<head>
  <!-- <link rel="stylesheet" href="./style.css"> -->
</head>
<body>

  <style>
    .button {
      position: fixed;
      top: 280px;
      width: 80px;
      height: 30px;
      background-color: bisque;
      border-radius: 8px;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }
  </style>
  <div class="content">
    <canvas id="c"></canvas>
    <div class="button">模糊</div>
  </div>
  <script type="module">
    // https://math.hws.edu/graphicsbook/c7/s4.html


    import * as lmgl from '../src/lmgl.js'
    window.lmgl = lmgl;

const vertexShader = `
  precision mediump float;
  attribute vec3 aPosition;
  attribute vec2 aUv;

  uniform mat4 projectionMatrix;
  uniform mat4 modelViewMatrix;
  uniform vec2 offset;

  varying vec2 vUv;
  void main() {
    vUv = aUv + offset;
   gl_Position = vec4(aPosition, 1.0);
  }
`
const fragmentShader = `
  precision mediump float;
  uniform sampler2D image;
  uniform vec2 offset;
  uniform float multiplier;

  varying vec2 vUv;
	void main() {
	  vec4 color = texture2D(image, vUv);
    gl_FragColor = vec4(multiplier * color.rgb, 1.0 );
	}
	`
let stage

window.onload = () => {
  document.title = "模糊纹理"

  // 2^n
  const width = 512
  const height = 256

  stage = new lmgl.Stage()
  stage.init(document.querySelector("#c"), width, height)

  const center = {
    x: 0,
    y: 0
  }
  const size = {
    x: 1,
    y: 1
  }
  const geo = {
    attribute: {
      aPosition: {
        value: [
          center.x - size.x, center.y + size.y, 0,
          center.x - size.x, center.y - size.y, 0,
          center.x + size.x, center.y - size.y, 0,
          center.x + size.x, center.y + size.y, 0,
        ],
        itemSize: 3
      },
      aUv:{
        value: [ 0,1, 0,0, 1,0, 1,1],
        itemSize: 2
      },
    },
    indices: [0,1,2, 2,3,0]
  };

  stage.run()
  lmgl.loadImage("./images/house.jpg", img => {
    let imageTexture = new lmgl.ImageTexture(img)
    const mat = {
      vertexShader: vertexShader,
      fragmentShader,
      uniforms: {
        multiplier:{
          value: 1,
          type: "f"
        },
        offset:{
          value: { x:0, y:0 },
          type: "v2"
        },
        image: {
          value: imageTexture.getTexture(),
          type: "t"
        }
      }
    }

    const mesh = new lmgl.Mesh(geo, mat);
    const material = mesh.material;
    // 深度和混合互斥
    material.blending = true;
    material.depthTest = false;
    material.setUniform()

    // 自定义渲染
    stage.setRenderState(false)
    const webgl = lmgl.webgl;
    const gl = stage.getGl()
    stage.renderer.renderMesh(mesh);

    var blur = ()=>{
      const count = 9;
      const kernel = [
        {x:-1,y: -1},
        {x:-1,y: 0},
        {x:-1,y: 1},
        {x: 0,y: 1},
        {x:0,y: 0},
        {x:0,y: -1},
        {x:1,y: -1},
        {x:1,y: 0},
        {x:1,y: 1},
      ]
      material.uniforms.multiplier.value = 1/count;

      for(let i=0;i<count;i++) {
        let dx = 4/width;
        let dy = 4/height;
        const item = kernel[i]
        material.uniforms.offset.value = {
          x: item.x * dx,
          y: item.y * dy,
        }
        material.setUniform()
        stage.renderer.renderMesh(mesh);
      }
      // 拷贝帧缓存的内容到当前使用的纹理中
      webgl.copyFramebufferToTexture(gl, width, height)
    }
    document.querySelector(".button").addEventListener("pointerdown", ()=>{
      blur()
    })
  })
}

  </script>
</body>
</html>
