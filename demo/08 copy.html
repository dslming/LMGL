<!DOCTYPE html>
<head>
  <!-- <link rel="stylesheet" href="./style.css"> -->
</head>
<body>
  <div class="content">
    <canvas id="c" width="512" height="256"></canvas>
  </div>
  <script type="module">
    // https://math.hws.edu/graphicsbook/c7/s4.html


    import * as lmgl from '../src/lmgl.js'
    window.lmgl = lmgl;

    function createProgram(gl, vShader, fShader) {
    let vsh = gl.createShader( gl.VERTEX_SHADER );
    gl.shaderSource(vsh,vShader);
    gl.compileShader(vsh);
    if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
        throw new Error("Error in vertex shader:  " + gl.getShaderInfoLog(vsh));
    }
    let fsh = gl.createShader( gl.FRAGMENT_SHADER );
    gl.shaderSource(fsh, fShader);
    gl.compileShader(fsh);
    if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
       throw new Error("Error in fragment shader:  " + gl.getShaderInfoLog(fsh));
    }
    let prog = gl.createProgram();
    gl.attachShader(prog,vsh);
    gl.attachShader(prog, fsh);
    gl.linkProgram(prog);
    if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
       throw new Error("Link error in program:  " + gl.getProgramInfoLog(prog));
    }
    return prog;
}


// const vertexShader = `
//   precision mediump float;
//   attribute vec3 aPosition;
//   attribute vec2 aUv;

//   uniform mat4 projectionMatrix;
//   uniform mat4 modelViewMatrix;
//   uniform vec2 uOffset;

//   varying vec2 vUv;
//   void main() {
//     vUv = aUv + uOffset;
//    gl_Position = projectionMatrix * modelViewMatrix * vec4(aPosition, 1.0);
//   }
// `
// const fragmentShader = `
//   precision mediump float;
//   uniform sampler2D uTexture;
//   uniform vec2 uOffset;
//   uniform float uMultiplier;

//   varying vec2 vUv;
// 	void main() {
// 	  vec4 color = texture2D(uTexture, vUv);
//     gl_FragColor = vec4(uMultiplier * color.rgb, 1.0 );
//     gl_FragColor = color+vec4(0.5,0.,0.,1.);
// 	}
// 	`

const vertexShader  = `
    attribute vec2 a_coords;
    uniform vec2 offset;
    varying vec2 v_coords;
    void main() {
        vec2 coords;  // coords translated from default range -1 to 1 to the range 0 to 1.
        coords = vec2( (a_coords.x + 1.0)*0.5, (a_coords.y + 1.0)* 0.5 );
        v_coords = coords + offset;
        gl_Position = vec4(a_coords,0.0,1.0);
    }`;

const fragmentShader = `
    precision mediump float;
    uniform sampler2D image;
    uniform float multiplier;
    varying vec2 v_coords;
    void main() {
        vec4 color = texture2D( image, v_coords );
        gl_FragColor = vec4( multiplier*color.rgb, 1.0 );
        // gl_FragColor = vec4(0.5, 0.,0.,1.);
    }`;


let stage

window.onload = () => {
  document.title = "模糊图片"
  const width = window.innerWidth
  const height = window.innerHeight

  stage = new lmgl.Stage()
  stage.init(document.querySelector("#c"), width, height)
  stage.camera.position.set(0, 0, 20)

  var blur = null;
  const center = {
    x: 0,
    y: 0
  }
  const size = 2
  const geo = {
    attribute: {
      // aPosition: {
      //   value: [
      //     center.x - size, center.y + size, 0,
      //     center.x - size, center.y - size, 0,
      //     center.x + size, center.y - size, 0,
      //     center.x + size, center.y + size, 0,
      //   ],
      //   itemSize: 3
      // },
      // aUv:{
      //   // todo: y轴不对
      //   value: [ 0,0, 0,1,  1,1,1,0,],
      //   itemSize: 2
      // }
      a_coords: {
        value: [-1,-1, 1,-1, 1,1, -1,1 ],
        itemSize: 2
      }
    },
    indices: [0,1,2, 2,3,0]
  };

  let img = new Image();
    img.onload = function() {
    // const mat = {
    //   vertexShader: vertexShader,
    //   fragmentShader,
    //   uniforms: {
    //     uMultiplier:{
    //       value: 1,
    //       type: "f"
    //     },
    //     uOffset:{
    //       value: { x:0, y:0 },
    //       type: "v2"
    //     },
    //     uTexture: {
    //       value: img,
    //       type: "t"
    //     }
    //   }
    // }
    // let mesh = new lmgl.Mesh(geo, mat);
    // stage.add(mesh);

    // stage.setRenderState(false)
    // const webgl = lmgl.webgl;
    const gl = stage.getGl()
    // var canvas = document.querySelector("#c")
    // var  gl = canvas.getContext("webgl", {  // no need for depth buffer in this program
            // depth: false
        // });
     let prog = createProgram( gl, vertexShader, fragmentShader );
    gl.useProgram(prog);
    gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, 1 );

    var a_coords_location = gl.getAttribLocation(prog, "a_coords");
    var a_coords_buffer = gl.createBuffer();

    let coords = new Float32Array( [ -1,-1, 1,-1, 1,1, -1,1 ] );

    gl.bindBuffer(gl.ARRAY_BUFFER, a_coords_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
    gl.vertexAttribPointer(a_coords_location, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_coords_location);

    // const material = mesh.material;
    // const prog = material.program;
    // const geometry = mesh.geometry;
    var u_image = gl.getUniformLocation(prog, "image");
    var u_offset = gl.getUniformLocation(prog, "offset");
    var u_multiplier = gl.getUniformLocation(prog, "multiplier");

    gl.uniform1i(u_image, 0);


    // gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, 1 );
    // stage.renderer.render();
    // mesh.setAttributes(mesh.attributeBuffer, mesh.indicesBuffer, geometry, prog);
    //  gl.useProgram(prog);
     var textureObject = gl.createTexture();

     gl.bindTexture(gl.TEXTURE_2D, textureObject);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);

    function draw() {
        gl.clearColor(1,1,1,1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform2f(u_offset, 0, 0);
        gl.uniform1f(u_multiplier, 1);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);  // Attribute values were set up in initGL()
    }
    draw();


    // 自定义渲染
    // stage.addOnUpdate("loop",()=>{

    //   // webgl.copyFramebufferToTexture(gl,"uTexture", program, 512, 256)
    // })


    window.blur = ()=>{
      //  gl.clearColor(0, 0, 0, 0); // fill color buffer with zeros
      //  gl.clear(gl.COLOR_BUFFER_BIT);
      // gl.enable(gl.BLEND); // turn on blending
      // gl.blendFunc(gl.ONE, gl.ONE);


      //  const material = mesh.material;
      //  const program = material.program;
      //  const geometry = mesh.geometry;

      // const count = 9;
      // const kernel = [
      //   {x:-1,y: -1},
      //   {x:-1,y: 0},
      //   {x:-1,y: 1},
      //   {x: 0,y: 1},
      //   {x:0,y: 0},
      //   {x:0,y: -1},
      //   {x:1,y: -1},
      //   {x:1,y: 0},
      //   {x:1,y: 1},
      // ]
      // // material.uniforms.uMultiplier.value = 1/count;

      // for(let i=0;i<count;i++) {
      //   let dx = 1/512;
      //   let dy = 1/256;
      //   const item = kernel[i]
      //   material.uniforms.uOffset.value = {
      //     x: item.x * dx,
      //     y: item.y * dy,
      //   }
      //   material.setUniform(material.uniforms, program)
      //   stage.renderer.renderOne(geometry);
      // }
      // gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, 0, 0, 512, 256, 0); // copy current image to texture
      // // webgl.copyFramebufferToTexture(gl,"uTexture", program, 512, 256)
      // gl.disable(gl.BLEND); // turn blending off, so it won't apply in draw()

      gl.clearColor(1,0,0,1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      function drawWithOffset(a,b) { // helper function
          gl.uniform2f(u_offset, a, b);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
      }

      gl.clearColor(0,0,0,0);  // fill color buffer with zeros
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.enable(gl.BLEND);  // turn on blending
      gl.blendFunc(gl.ONE, gl.ONE);  // just add the source and destination values, with no dependence on alpha
      gl.uniform1f(u_multiplier, 1/9);  // (the only value we need in this program; could be different for other blur functions)
      let dx = 1/512;  // width of one pixel in the texture image, which is 512x256
      let dy = 1/256;  // height of one pixel in the texture image
      drawWithOffset(-dx,-dy);  // Draw the texture 9 times, with different offsets
      drawWithOffset(-dx,0);
      drawWithOffset(-dx,dy);
      drawWithOffset(0,dy);
      drawWithOffset(0,0);
      drawWithOffset(0,-dy);
      drawWithOffset(dx,-dy);
      drawWithOffset(dx,0);
      drawWithOffset(dx,dy);
      gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, 0,0,512,256, 0);  // copy current image to texture
      gl.disable(gl.BLEND);
    }

  }
  img.src = "./images/house.jpg"
  // stage.run()
}

  </script>
</body>
</html>
