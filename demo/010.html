<!DOCTYPE html>
<head>
  <link rel="stylesheet" href="./style.css">
</head>
<body>
  <div class="content">
    <canvas id="c"></canvas>
  </div>
  <script type="module">
    // https://math.hws.edu/graphicsbook/source/webgl/cube-camera.html
    import * as lmgl from '../src/lmgl.js'
    window.lmgl = lmgl;

    /************* shader program for the skybox ******************/
  let stage

  class SkyBox {
    constructor(stage){
      this.init(stage);
    }

  async init() {
    const vertexShaderSourceSB = `
        precision mediump float;
        attribute vec3 aPosition;
        uniform mat4 projectionMatrix;
        uniform mat4 modelViewMatrix;
        varying vec3 vUv;

        void main() {
          vUv = aPosition;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(aPosition, 1.0);
        }`;
      const fragmentShaderSourceSB = `
          precision mediump float;
          varying vec3 v_objCoords;
          uniform samplerCube skybox;
          varying vec3 vUv;

          void main() {
                gl_FragColor = textureCube(skybox, vUv);
          }`;

        const urls = [
          "cubeMap/posx.jpg",
          "cubeMap/negx.jpg",
          "cubeMap/posy.jpg",
          "cubeMap/negy.jpg",
          "cubeMap/posz.jpg",
          "cubeMap/negz.jpg"
        ];
        const images = await lmgl.loadCubeImages(urls)
        let cubeMap = new lmgl.ImageCubeTexture(images)

        const mat = {
          vertexShader: vertexShaderSourceSB,
          fragmentShader: fragmentShaderSourceSB,
          uniforms: {
            skybox: {
              type: "tcube",
              value: cubeMap.getTexture()
            }
          }
        }

        const geoInfo = lmgl.createCube(20);
        const geo = {
          attribute: {
            aPosition: {
              value: geoInfo.positions,
              itemSize: 3
            },
          },
          indices: geoInfo.indices
        };
        let mesh = new lmgl.Mesh(geo, mat);
        this.mesh = mesh;
        stage.add(mesh)
    }

  }

  // 平面
  class Plane {
    constructor() {
      // 平面
      const vsPlane = `
        precision mediump float;
        attribute vec3 aPosition;
        attribute vec2 aUv;
        varying vec2 vUv;
        uniform mat4 projectionMatrix;
        uniform mat4 modelViewMatrix;

        void main() {
          vUv = aUv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(aPosition, 1.0);
        }
      `

      const fsPlane = `
        precision mediump float;
        uniform sampler2D texture;
        varying vec2 vUv;

        void main() {
          gl_FragColor = vec4(vUv, 0., 1.);
        }
        `

      const center = {
        x: 0,
        y: 0
      }
      const size = 2
      const geo = {
        attribute: {
          aPosition: {
            value: [
              center.x - size, center.y - size, 0,
              center.x - size, center.y + size, 0,
              center.x + size, center.y + size, 0,
              center.x + size, center.y - size, 0,
            ],
            itemSize: 3
          },
          aUv:{
            value: [ 0,1, 0,0, 1,0, 1,1],
            itemSize: 2
          },
        },
        indices: [0,1,2, 2,3,0]
      };

      const mat = {
        vertexShader: vsPlane,
        fragmentShader: fsPlane,
      }

      this.mesh = new lmgl.Mesh(geo, mat);
    }
  }

  window.onload = () => {
    document.title = "天空盒"
    let width = window.innerWidth
    let height = window.innerHeight

    window.addEventListener("resize", ()=>{
      width = window.innerWidth
      height = window.innerHeight
    })

    stage = new lmgl.Stage()
    stage.init(document.querySelector("#c"), width, height)
    stage.camera.position.set(0, 0, 20)

    const skyBox = new SkyBox(stage);
    const plane = new Plane();
    stage.add(plane.mesh);

    stage.addUpdate("loop",()=>{
      skyBox.mesh && (skyBox.mesh.rotation.y += 0.001);
      plane.mesh.rotation.y += 0.01;
    })
    stage.run()
  }

  </script>
</body>
</html>
