{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/_tslib@2.3.1@tslib/tslib.es6.js","webpack:///./src/application.ts","webpack:///./src/cameras/PerspectiveCamera.ts","webpack:///./src/cameras/camera.control.ts","webpack:///./src/cameras/camera.ts","webpack:///./src/cameras/index.ts","webpack:///./src/engines/engine.draw.ts","webpack:///./src/engines/engine.enum.ts","webpack:///./src/engines/engine.programs.ts","webpack:///./src/engines/engine.renderTarget.ts","webpack:///./src/engines/engine.state.ts","webpack:///./src/engines/engine.texture.ts","webpack:///./src/engines/engine.ts","webpack:///./src/engines/engine.uniformBuffer.ts","webpack:///./src/engines/engine.uniforms.ts","webpack:///./src/engines/engine.vertex.ts","webpack:///./src/engines/engine.viewPort.ts","webpack:///./src/engines/index.ts","webpack:///./src/geometry/builder.ts","webpack:///./src/geometry/geometry.ts","webpack:///./src/geometry/index.ts","webpack:///./src/index.ts","webpack:///./src/lmgl.ts","webpack:///./src/loader/index.ts","webpack:///./src/loader/loader.ts","webpack:///./src/loader/shader.loader.ts","webpack:///./src/loader/texture.loader.ts","webpack:///./src/material/index.ts","webpack:///./src/material/material.ts","webpack:///./src/maths/index.ts","webpack:///./src/maths/math.color.ts","webpack:///./src/maths/math.constants.ts","webpack:///./src/maths/math.euler.ts","webpack:///./src/maths/math.mat3.ts","webpack:///./src/maths/math.mat4.ts","webpack:///./src/maths/math.quat.ts","webpack:///./src/maths/math.scalar.ts","webpack:///./src/maths/math.tool.ts","webpack:///./src/maths/math.vec2.ts","webpack:///./src/maths/math.vec3.ts","webpack:///./src/maths/math.vec4.ts","webpack:///./src/mesh/index.ts","webpack:///./src/mesh/mesh.axis.ts","webpack:///./src/mesh/mesh.ts","webpack:///./src/misc/arrayTools.ts","webpack:///./src/misc/domManagement.ts","webpack:///./src/misc/fileTools.ts","webpack:///./src/misc/logger.ts","webpack:///./src/misc/shaderProcess.ts","webpack:///./src/misc/tool.ts","webpack:///./src/misc/typeStore.ts","webpack:///./src/object3D.ts","webpack:///./src/postprocessing/index.ts","webpack:///./src/postprocessing/postprocessing.ts","webpack:///./src/renderer/index.ts","webpack:///./src/renderer/render.target.ts","webpack:///./src/renderer/renderer.ts","webpack:///./src/scene/index.ts","webpack:///./src/scene/scene.ts","webpack:///./src/texture/index.ts","webpack:///./src/texture/texture.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,8EAA8E;AACvG;AACA;;AAEO;AACP;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEO;AACP;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEO;AACP,mCAAmC,oCAAoC;AACvE;;AAEO;AACP;AACA;;AAEO;AACP,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;;AAEO;AACP,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;;AAEO;AACP;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;;AAEM;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM,gBAAgB;AACzC;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACO;AACP,4BAA4B,sBAAsB;AAClD;AACA;AACA;;AAEA;AACO;AACP,iDAAiD,QAAQ;AACzD,wCAAwC,QAAQ;AAChD,wDAAwD,QAAQ;AAChE;AACA;AACA;;AAEO;AACP,4EAA4E,OAAO;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA,iBAAiB,sFAAsF,aAAa,EAAE;AACtH,sBAAsB,gCAAgC,qCAAqC,0CAA0C,EAAE,EAAE,GAAG;AAC5I,2BAA2B,MAAM,eAAe,EAAE,YAAY,oBAAoB,EAAE;AACpF,sBAAsB,oGAAoG;AAC1H,6BAA6B,uBAAuB;AACpD,4BAA4B,wBAAwB;AACpD,2BAA2B,yDAAyD;AACpF;;AAEO;AACP;AACA,iBAAiB,4CAA4C,SAAS,EAAE,qDAAqD,aAAa,EAAE;AAC5I,yBAAyB,6BAA6B,oBAAoB,gDAAgD,gBAAgB,EAAE,KAAK;AACjJ;;AAEO;AACP;AACA;AACA,2GAA2G,sFAAsF,aAAa,EAAE;AAChN,sBAAsB,8BAA8B,gDAAgD,uDAAuD,EAAE,EAAE,GAAG;AAClK,4CAA4C,sCAAsC,UAAU,oBAAoB,EAAE,EAAE,UAAU;AAC9H;;AAEO;AACP,gCAAgC,uCAAuC,aAAa,EAAE,EAAE,OAAO,kBAAkB;AACjH;AACA;;AAEA;AACA,yCAAyC,6BAA6B;AACtE,CAAC;AACD;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,4CAA4C;AAC5C;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9OA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyD;AACO;AACpB;AACD;AACpC;AACP;AACA;AACA;AACA;AACA,0BAA0B,4EAAiB;AAC3C,4BAA4B,0DAAQ;AACpC;AACA;AACA;AACA,4BAA4B,qEAAa;AACzC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAA2D;AACzB;AAClC,gCAAgC,8CAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAwE;AACzF;AACA,mBAAmB,6DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6DAAO;AAC7C;AACA;AACA;AACA,eAAe,6DAAO,0BAA0B,6DAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;AChK7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACF;AACI;AACJ;AACA;AACH;AACvC;AACO;AACP;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAI;AAC7B,yBAAyB,qDAAI;AAC7B,6BAA6B,kDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAK;AACrC;AACA;AACA;AACA,8BAA8B,qDAAI;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAI,UAAU,yDAAQ;AAC1D,oCAAoC,qDAAI,UAAU,yDAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAI;AAC9B,0BAA0B,qDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAI;AACnC;AACA;AACA,6BAA6B,qDAAI;AACjC;AACA;AACA;AACA;AACA,0BAA0B,yDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAQ;AAClC;AACA;AACA;AACA;AACA,2BAA2B,yDAAQ;AACnC,2BAA2B,yDAAQ;AACnC;AACA;AACA;AACA;AACA,2BAA2B,yDAAQ;AACnC,2BAA2B,yDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtLA;AAAA;AAAA;AAAA;AAA0C;AACH;AACvC,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA,sCAAsC,qDAAI;AAC1C,oCAAoC,qDAAI;AACxC,2CAA2C,qDAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACkB;;;;;;;;;;;;;ACxClB;AAAA;AAAA;AAAA;AAAoC;;;;;;;;;;;;;ACApC;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;;;;;;;;;;;;ACxU/B;AAAA;AAAA;AAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uCAAuC;AACpD,uBAAuB,iEAAa;AACpC,wBAAwB,iEAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5FA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAAA;AAAoD;AAC7C;AACP;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA,mBAAmB,sDAAS,mBAAmB,sDAAS;AACxD;AACA;AACA,yBAAyB,qDAAQ;AACjC,yBAAyB,qDAAQ;AACjC;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,gBAAgB;AAC1B,UAAU,iBAAiB;AAC3B,UAAU,qBAAqB;AAC/B,UAAU,mBAAmB;AAC7B,UAAU,oBAAoB;AAC9B,UAAU,wBAAwB;AAClC,UAAU,kBAAkB;AAC5B;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,wBAAwB;AAChG;AACA,eAAe,OAAO;AACtB;AACA,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oBAAoB;AAC5B;AACA,eAAe,OAAO;AACtB;AACA,UAAU;AACV,UAAU;AACV,UAAU;AACV,UAAU;AACV;AACA;AACA,eAAe,KAAK;AACpB;AACA,6BAA6B,qDAAQ;AACrC;AACA;AACA;AACA,uCAAuC,qDAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,SAAS;AACxB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA,UAAU;AACV,UAAU;AACV,UAAU;AACV;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAS;AACjC;AACA;AACA;AACA,wBAAwB,sDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClXA;AAAA;AAAA;AAAA;AAA2D;AACG;AACvD;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,0DAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,2DAAc;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,2DAAc;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA,YAAY,8EAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACO;AACS;AACd;AACI;AACY;AACX;AACH;AACI;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAU;AACxC,kCAAkC,+DAAc;AAChD,kCAAkC,8DAAa;AAC/C,iCAAiC,8DAAa;AAC9C,gCAAgC,2DAAY;AAC5C,iCAAiC,6DAAa;AAC9C,uCAAuC,yEAAmB;AAC1D,sCAAsC,uEAAkB;AACxD,+BAA+B,yDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAA6C;AACtC;AACP;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA,mBAAmB,OAAO;AAC1B,wBAAwB,yDAAY;AACpC;AACA;AACA,wBAAwB,yDAAY;AACpC;AACA;AACA,wBAAwB,yDAAY;AACpC;AACA;AACA,wBAAwB,yDAAY;AACpC;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA,mBAAmB,cAAc;AACjC,wBAAwB,yDAAY;AACpC;AACA;AACA,wBAAwB,yDAAY;AACpC;AACA;AACA,wBAAwB,yDAAY;AACpC;AACA;AACA,wBAAwB,yDAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrEA;AAAA;AAAA;AAAA;AAAA,WAAW,8CAA8C;AACnB;AACO;AACtC;AACP;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,8BAA8B,KAAK,GAAG,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAY;AAC7B;AACA;AACA,iBAAiB,yDAAY;AAC7B;AACA;AACA,iBAAiB,yDAAY;AAC7B;AACA;AACA,iBAAiB,yDAAY;AAC7B;AACA;AACA,iBAAiB,yDAAY;AAC7B;AACA;AACA,iBAAiB,yDAAY;AAC7B;AACA;AACA,iBAAiB,yDAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC,8BAA8B,KAAK,GAAG,EAAE;AACxC;AACA,6BAA6B,yDAAY;AACzC;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA,2BAA2B,cAAc;AACzC,oDAAoD,IAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2CAAI;AAC/B;AACA,iFAAiF,yDAAY;AAC7F,qGAAqG,yDAAY;AACjH,4BAA4B,2CAAI;AAChC;AACA,+FAA+F,yDAAY;AAC3G;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA,mBAAmB,cAAc;AACjC,wBAAwB,yDAAY;AACpC;AACA;AACA,6BAA6B,yDAAY;AACzC;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAY;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrGA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,wCAAwC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAAO;AACP;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyB;AACK;;;;;;;;;;;;;ACD9B;AAAA;AAAA;AAAA;AAAA;AAA0C;AAC1C;AACA;AACO;AACP;AACA,+EAA+E,qDAAI;AACnF;AACA;AACA;AACA;AACA,YAAY,qDAAI;AAChB,YAAY,qDAAI;AAChB,YAAY,qDAAI;AAChB,YAAY,qDAAI;AAChB,YAAY,qDAAI;AAChB,YAAY,qDAAI;AAChB,YAAY,qDAAI;AAChB,YAAY,qDAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sBAAsB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAI;AAC9B,0BAA0B,qDAAI;AAC9B,0BAA0B,qDAAI;AAC9B,sBAAsB,qDAAI;AAC1B,uBAAuB,gBAAgB;AACvC,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtKA;AAAA;AAAA;AAAA;AAAA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACuD;AACf;AACjC;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAM;AAClB;AACA;AACA,sCAAsC,kEAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mCAAmC;AAClD;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0B;AACC;;;;;;;;;;;;;ACD3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgC;AACA;AACC;AACA;AACJ;AACC;AACC;AACC;AACC;AACM;AACT;AACG;AACH;;;;;;;;;;;;;ACZ9B;AAAA;AAAA;AACgC;AAChC,cAAc,mCAAI;;;;;;;;;;;;;ACFlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiC;AACD;;;;;;;;;;;;;ACDhC;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAA8C;AACZ;AAC3B,2BAA2B,8CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAS;AACrB;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACY;AACT;AACH;AAC3B,4BAA4B,8CAAM;AACzC;AACA;AACA;AACA;AACA,eAAe,uDAAS;AACxB,oDAAoD,uDAAS;AAC7D,oCAAoC,yDAAS;AAC7C,oCAAoC,gDAAO;AAC3C;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAA2B;;;;;;;;;;;;;ACA3B;AAAA;AAAA;AAAA;AAAsD;AACT;AACtC;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAa,4BAA4B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA,mBAAmB,cAAc;AACjC,wBAAwB,iEAAY;AACpC;AACA;AACA,6BAA6B,iEAAY;AACzC;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAY;AACpC;AACA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACA;AACA;AACC;AACD;AACA;;;;;;;;;;;;;ACN5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACwB;AACf;AACD;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oDAAoD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAM;AACzB,mBAAmB,mDAAM;AACzB,mBAAmB,mDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAM,eAAe,mDAAM,eAAe,mDAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAa;AACzD,4CAA4C,6DAAa;AACzD,4CAA4C,6DAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4DAAY;AACxD,4CAA4C,4DAAY;AACxD,4CAA4C,4DAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA,qBAAqB,gEAAgE;AACrF;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAM;AACzB,mBAAmB,mDAAM;AACzB,mBAAmB,mDAAM;AACzB,mBAAmB,mDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qEAAqE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAM,eAAe,mDAAM,eAAe,mDAAM;AACzE;AACA;AACA,qBAAqB,mDAAM,eAAe,mDAAM,eAAe,mDAAM,eAAe,mDAAM;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAa;AACzD,4CAA4C,6DAAa;AACzD,4CAA4C,6DAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4DAAY;AACxD,4CAA4C,4DAAY;AACxD,4CAA4C,4DAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mBAAmB,2DAAU;AAC7B,mBAAmB,2DAAU;AAC7B,0DAAU;AACV,0DAAU;;;;;;;;;;;;;AC97BV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACmB;;;;;;;;;;;;;ACjBnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AACA;AACA;AACI;AACvC,kCAAkC,+CAAI;AACtC,sCAAsC,+CAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACiB;;;;;;;;;;;;;AC7LjB;AAAA;AAAA;AAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA,iBAAiB,KAAK;AACtB;AACA,mCAAmC,+CAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACgB;;;;;;;;;;;;;ACtPhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAc,yBAAyB;AACA;AACJ;AACA;AACA;AACnC,sBAAsB,+CAAI;AAC1B,cAAc,+CAAI;AAClB,cAAc,+CAAI;AAClB,cAAc,+CAAI;AAClB,kBAAkB,+CAAI;AACtB,8BAA8B,+CAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gBAAgB;AACxB;AACA,eAAe,KAAK;AACpB;AACA,eAAe,KAAK;AACpB;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA,iBAAiB,mDAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAI;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAI;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAI;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA,yBAAyB,+CAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mDAAQ;AACtB,cAAc,mDAAQ;AACtB,cAAc,mDAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAQ;AACrD;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,gCAAgC,+CAAI;AACpC,+BAA+B,+CAAI;AACnB;;;;;;;;;;;;;AC3wChB;AAAA;AAAA;AAAA;AAAA,cAAc,yBAAyB;AACA;AACJ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAQ;AAC7B;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA,gCAAgC,+CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAQ;AACrD;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,iDAAiD;AACjD,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACgB;;;;;;;;;;;;;ACrlBhB;AAAA;AAAA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7VA;AAAA;AAAA;AAAoD;AACpD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,uDAAO;AAChC;AACA;AACA,yBAAyB,uDAAO;AAChC;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,mCAAmC;AACnC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClWA;AAAA;AAAA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO,IAAI,OAAO;AACrC;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;;;;;;;;;;;ACtiBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO,IAAI,OAAO,IAAI,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACgB;;;;;;;;;;;;;AC5oBhB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACgB;;;;;;;;;;;;;ACnhBhB;AAAA;AAAA;AAAA;AAAuB;;;;;;;;;;;;;ACAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACa;AAChB;AACS;AAClB;AACvB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D,kCAAkC,yBAAyB;AAC3D,kCAAkC,yBAAyB;AAC3D,yBAAyB,0CAAI,mBAAmB,kDAAQ;AACxD,yBAAyB,0CAAI,mBAAmB,kDAAQ;AACxD,yBAAyB,0CAAI,mBAAmB,kDAAQ;AACxD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,2DAAQ;AAChC;AACA;AACA;AACA,yBAAyB,OAAO,qDAAY,qBAAqB;AACjE,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,kBAAkB,kEAAa;AAC/B;AACA;AACA;;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACF;AACA;AACA;AACI;AACJ;AACF;AACjC;AACP;AACA;AACA;AACA,oBAAoB,yDAAQ;AAC5B;AACA;AACA,0BAA0B,qDAAI;AAC9B,gCAAgC,qDAAI;AACpC,4BAA4B,qDAAI;AAChC,yBAAyB,qDAAI;AAC7B,4BAA4B,uDAAK;AACjC,8BAA8B,qDAAI;AAClC;AACA;AACA,wBAAwB,2DAAQ;AAChC,qBAAqB,2DAAQ;AAC7B,wBAAwB,2DAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjIA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACA;AACI;AACJ;AACA;AACzC,WAAW,kBAAkB;AACc;AAC3C,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB;AACA;AACA,8BAA8B,qDAAI;AAClC,8BAA8B,qDAAI;AAClC,8BAA8B,qDAAI;AAClC,kCAAkC,qDAAI;AACtC,oCAAoC,qDAAI;AACxC,iCAAiC,qDAAI;AACrC,sCAAsC,qDAAI;AAC1C,iCAAiC,qDAAI;AACrC,iCAAiC,qDAAI;AACrC,iCAAiC,qDAAI;AACrC,qBAAqB;AACrB,uBAAuB;AACvB;AACA;AACA,8CAA8C,uBAAuB;AACrE,oBAAoB,yDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAI;AACjC,6BAA6B,uDAAK;AAClC,+BAA+B,qDAAI;AACnC,0BAA0B,qDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,2BAA2B,qDAAI;AAC/B,aAAa;AACb;AACA,2BAA2B,qDAAI;AAC/B,aAAa;AACb,SAAS;AACT,0BAA0B,qDAAI;AAC9B,+BAA+B,qDAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAI;AAC7B;AACA;AACoB;;;;;;;;;;;;;AClPpB;AAAA;AAAA;AAAA;AAAiC;;;;;;;;;;;;;ACAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACmB;AACE;AACV;AACtC;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,6BAA6B,kDAAQ;AACrC;AACA,8BAA8B,wDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAS;AACxB;AACA;AACA;AACA,oBAAoB,kEAAY;AAChC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,2BAA2B,wCAAwC;AACnE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClIA;AAAA;AAAA;AAAA;AAAA;AAAA,wCAAgC;AACL;;;;;;;;;;;;;ACD3B;AAAA;AAAA;AAAA;AAA0E;AACrC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAO;AACtC;AACA;AACA,oBAAoB,sDAAa;AACjC,sBAAsB,uDAAc;AACpC,sBAAsB,uDAAc;AACpC,uBAAuB,sDAAa;AACpC,uBAAuB,sDAAa;AACpC,SAAS;AACT;AACA;AACA;AACA;AACA,mCAAmC,gDAAO;AAC1C;AACA;AACA,wBAAwB,sDAAa;AACrC,0BAA0B,uDAAc;AACxC,0BAA0B,uDAAc;AACxC,2BAA2B,sDAAa;AACxC,2BAA2B,sDAAa;AACxC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACsD;AACT;AACH;AAC3B;AACf;AACA;AACA;AACA;AACA,8BAA8B,wDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,iEAAY;AACrH,oCAAoC,qDAAI;AACxC;AACA,gGAAgG,iEAAY;AAC5G,kFAAkF,iEAAY;AAC9F;AACA;AACA,+FAA+F,iEAAY;AAC3G,wFAAwF,iEAAY;AACpG;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C,kBAAkB,yEAAyE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/FA;AAAA;AAAA;AAAA;AAAwB;;;;;;;;;;;;;ACAxB;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAA0B;;;;;;;;;;;;;ACA1B;AAAA;AAAA;AAAA;AAAmG;AACrD;AAC9C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,kEAAa;AAC7F,gFAAgF,kEAAa;AAC7F,6EAA6E,mEAAc;AAC3F,6EAA6E,mEAAc;AAC3F;AACA,uEAAuE,kEAAa;AACpF;AACA,sFAAsF,gEAAW;AACjG;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,eAAe,yDAAQ,4BAA4B,yDAAQ;AAC3D;AACA;AACA,+CAA+C,wBAAwB;AACvE,QAAQ,+BAA+B;AACvC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"lmgl.max.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/lmgl.ts\");\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import { CameraControl } from \"./cameras/camera.control\";\nimport { PerspectiveCamera } from \"./cameras/PerspectiveCamera\";\nimport { MeshAxis } from \"./mesh/mesh.axis\";\nimport Renderer from \"./renderer/renderer\";\nexport class Application {\n    constructor(engine, scene) {\n        this.autoRender = true;\n        this.engine = engine;\n        scene && (this.scene = scene);\n        this.camera = new PerspectiveCamera(45, 1, 1, 20);\n        this.renderer = new Renderer(engine);\n        this.loop = this.loop.bind(this);\n        this.handleResize(this.engine.renderingCanvas.clientWidth, this.engine.renderingCanvas.clientHeight);\n        this.camera.position.set(0, 0, 10);\n        this._control = new CameraControl({\n            distance: this.camera.position.z,\n            distRange: {\n                min: 0.01,\n            },\n        }, this.camera, this.engine.renderingCanvas);\n        window.onresize = () => {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n            this.handleResize(width, height);\n        };\n        const axis = new MeshAxis(engine, 10);\n        this.scene.add(axis.meshX);\n        this.scene.add(axis.meshY);\n        this.scene.add(axis.meshZ);\n        this.loop();\n    }\n    handleResize(width, height) {\n        const canvas = this.engine.renderingCanvas;\n        const ratio = window.devicePixelRatio;\n        canvas.width = width;\n        canvas.height = height;\n        this.camera.aspect = width / height;\n        canvas.style.width = width + \"px\";\n        canvas.style.height = height + \"px\";\n    }\n    getRenderSize() {\n        return {\n            width: this.engine.engineDraw.getRenderWidth(),\n            height: this.engine.engineDraw.getRenderHeight(),\n        };\n    }\n    loop() {\n        this._control.update();\n        if (this.autoRender) {\n            this.renderer.renderScene(this.scene, this.camera);\n        }\n        window.requestAnimationFrame(this.loop);\n    }\n}\n","import { DEG2RAD, RAD2DEG } from \"../maths/math.constants\";\nimport { Camera } from \"./camera\";\nclass PerspectiveCamera extends Camera {\n    constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {\n        super();\n        this.useRightHandedSystem = true;\n        this.type = \"PerspectiveCamera\";\n        this.fov = fov;\n        this.zoom = 1;\n        this.near = near;\n        this.far = far;\n        this.focus = 10;\n        this.aspect = aspect;\n        this.view = null;\n        this.filmGauge = 35; // width of the film (default in millimeters)\n        this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n        this.updateProjectionMatrix();\n    }\n    // copy(source, recursive) {\n    //   super.copy(source, recursive);\n    //   this.fov = source.fov;\n    //   this.zoom = source.zoom;\n    //   this.near = source.near;\n    //   this.far = source.far;\n    //   this.focus = source.focus;\n    //   this.aspect = source.aspect;\n    //   this.view = source.view === null ? null : Object.assign({}, source.view);\n    //   this.filmGauge = source.filmGauge;\n    //   this.filmOffset = source.filmOffset;\n    //   return this;\n    // }\n    /**\n     * Sets the FOV by focal length in respect to the current .filmGauge.\n     *\n     * The default film gauge is 35, so that the focal length can be specified for\n     * a 35mm (full frame) camera.\n     *\n     * Values for focal length and film gauge must have the same unit.\n     */\n    setFocalLength(focalLength) {\n        /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n        const vExtentSlope = (0.5 * this.getFilmHeight()) / focalLength;\n        this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);\n        this.updateProjectionMatrix();\n    }\n    /**\n     * Calculates the focal length from the current .fov and .filmGauge.\n     */\n    getFocalLength() {\n        const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n        return (0.5 * this.getFilmHeight()) / vExtentSlope;\n    }\n    getEffectiveFOV() {\n        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);\n    }\n    getFilmWidth() {\n        // film not completely covered in portrait format (aspect < 1)\n        return this.filmGauge * Math.min(this.aspect, 1);\n    }\n    getFilmHeight() {\n        // film not completely covered in landscape format (aspect > 1)\n        return this.filmGauge / Math.max(this.aspect, 1);\n    }\n    /**\n     * Sets an offset in a larger frustum. This is useful for multi-window or\n     * multi-monitor/multi-machine setups.\n     *\n     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n     * the monitors are in grid like this\n     *\n     *   +---+---+---+\n     *   | A | B | C |\n     *   +---+---+---+\n     *   | D | E | F |\n     *   +---+---+---+\n     *\n     * then for each monitor you would call it like this\n     *\n     *   const w = 1920;\n     *   const h = 1080;\n     *   const fullWidth = w * 3;\n     *   const fullHeight = h * 2;\n     *\n     *   --A--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n     *   --B--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n     *   --C--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n     *   --D--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n     *   --E--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n     *   --F--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n     *\n     *   Note there is no reason monitors have to be the same size or in a grid.\n     */\n    setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n        this.aspect = fullWidth / fullHeight;\n        if (this.view === null) {\n            this.view = {\n                enabled: true,\n                fullWidth: 1,\n                fullHeight: 1,\n                offsetX: 0,\n                offsetY: 0,\n                width: 1,\n                height: 1,\n            };\n        }\n        this.view.enabled = true;\n        this.view.fullWidth = fullWidth;\n        this.view.fullHeight = fullHeight;\n        this.view.offsetX = x;\n        this.view.offsetY = y;\n        this.view.width = width;\n        this.view.height = height;\n        this.updateProjectionMatrix();\n    }\n    clearViewOffset() {\n        if (this.view !== null) {\n            this.view.enabled = false;\n        }\n        this.updateProjectionMatrix();\n    }\n    updateProjectionMatrix() {\n        const near = this.near;\n        let top = (near * Math.tan(DEG2RAD * 0.5 * this.fov)) / this.zoom;\n        let height = 2 * top;\n        let width = this.aspect * height;\n        let left = -0.5 * width;\n        const view = this.view;\n        if (this.view !== null && this.view.enabled) {\n            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;\n            left += (view.offsetX * width) / fullWidth;\n            top -= (view.offsetY * height) / fullHeight;\n            width *= view.width / fullWidth;\n            height *= view.height / fullHeight;\n        }\n        const skew = this.filmOffset;\n        if (skew !== 0)\n            left += (near * skew) / this.getFilmWidth();\n        if (this.useRightHandedSystem === true) {\n            this.projectionMatrix.makePerspectiveRH(left, left + width, top, top - height, near, this.far);\n        }\n        else {\n            this.projectionMatrix.makePerspectiveLH(left, left + width, top, top - height, near, this.far);\n        }\n        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n    }\n    getViewMatrix() {\n        return this.matrixWorldInverse;\n    }\n    getProjectionMatrix() {\n        this.updateProjectionMatrix();\n        return this.projectionMatrix;\n    }\n}\nPerspectiveCamera.prototype.isPerspectiveCamera = true;\nexport { PerspectiveCamera };\n","import { Euler } from \"../maths/math.euler\";\nimport { Quat } from \"../maths/math.quat\";\nimport { MathTool } from \"../maths/math.tool\";\nimport { Vec2 } from \"../maths/math.vec2\";\nimport { Vec3 } from \"../maths/math.vec3\";\nimport { Object3D } from \"../object3D\";\n// \nexport class CameraControl {\n    /**\n     * @param {object} options\n     * @param { object } options.distRange\n     * @param { number } options.distRange.max\n     * @param { number } options.distRange.min\n     *\n     * @param { object } options.rotRange\n     * @param { number } options.rotRange.xMax\n     * @param { number } options.rotRange.xMin\n     * @param { number } options.rotRange.yMax\n     * @param { number } options.rotRange.yMin\n     *\n     * @param { number } options.distance\n     */\n    constructor(options, camera, container) {\n        this.forceUpdate = true;\n        this.readOptions(options);\n        this.vpW = container.clientWidth;\n        this.vpH = container.clientHeight;\n        this.quatX = new Quat();\n        this.quatY = new Quat();\n        this.camHolder = new Object3D();\n        this.camera = camera;\n        this.gyro = {\n            orient: 0,\n            alpha: 0,\n            beta: 0,\n            gamma: 0,\n        };\n        this.defaultEuler = new Euler(0, 0, 0);\n        this.initEvent(container);\n    }\n    initEvent(container) {\n        const mouseVec2 = new Vec2();\n        let disableHammer = true;\n        container.addEventListener(\"mousedown\", (event) => {\n            mouseVec2.set(event.clientX, event.clientY);\n            disableHammer = false;\n        }, false);\n        container.addEventListener(\"mousemove\", (event) => {\n            if (disableHammer)\n                return;\n            const t = 300;\n            let angleX = ((event.clientX - mouseVec2.x) / this.vpW) * t;\n            let angleY = ((event.clientY - mouseVec2.y) / this.vpH) * t;\n            this.orbitBy(angleX, angleY);\n            mouseVec2.set(event.clientX, event.clientY);\n        }, false);\n        container.addEventListener(\"mouseup\", event => {\n            disableHammer = true;\n        }, false);\n        container.addEventListener(\"wheel\", (event) => {\n            const t = 0.08;\n            this.dolly(event.deltaY * t);\n        }, false);\n    }\n    update() {\n        if (!this.forceUpdate && !this.changesOccurred()) {\n            return false;\n        }\n        // \n        this.rotActual.lerp(this.rotTarget, 0.2);\n        this.quatX.setFromAxisAngle(Vec3.AXIS_X, -MathTool.degToRad(this.rotActual.y));\n        this.quatY.setFromAxisAngle(Vec3.AXIS_Y, -MathTool.degToRad(this.rotActual.x));\n        this.quatY.mul(this.quatX);\n        this.camera.quaternion.copy(this.quatY);\n        // \n        this.focusActual.lerp(this.focusTarget, 0.1);\n        this.camera.position.copy(this.focusActual);\n        if (this.distActual !== this.distTarget) {\n            this.distActual = MathTool.zTween(this.distActual, this.distTarget, 0.3);\n        }\n        this.camera.translateZ(this.distActual);\n        this.forceUpdate = false;\n        return true;\n    }\n    readOptions(options) {\n        if (options == undefined)\n            options = {};\n        if (options.distRange == undefined)\n            options.distRange = {};\n        if (options.rotRange == undefined)\n            options.rotRange = {};\n        this.options = {\n            distance: options.distance || 90,\n            focusPos: new Vec3(),\n            rotation: new Vec3(),\n            rotRange: {\n                xMax: options.rotRange.xMax || Number.POSITIVE_INFINITY,\n                xMin: options.rotRange.xMin || Number.NEGATIVE_INFINITY,\n                yMax: options.rotRange.yMax || 90,\n                yMin: options.rotRange.yMin || -90,\n            },\n            distRange: {\n                max: options.distRange.max || Number.POSITIVE_INFINITY,\n                min: options.distRange.min || Number.NEGATIVE_INFINITY,\n            },\n            smartUpdates: true,\n        };\n        const opt = this.options;\n        this.distActual = opt.distance;\n        this.distTarget = opt.distance;\n        // \n        this.focusActual = new Vec3(opt.focusPos.x, opt.focusPos.y, opt.focusPos.z);\n        // \n        this.focusTarget = this.focusActual.clone();\n        this.rotActual = new Vec3(opt.rotation.x, opt.rotation.y, opt.rotation.z);\n        this.rotTarget = this.rotActual.clone();\n    }\n    setDistance(dist) {\n        this.distTarget = dist;\n        this.distTarget = MathTool.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\n        this.forceUpdate = true;\n    }\n    setDistRange(max, min) {\n        this.options.distRange.max = max;\n        this.options.distRange.min = min;\n    }\n    setRotation(_rotX, _rotY, _rotZ) {\n        if (_rotX === undefined)\n            _rotX = 0;\n        if (_rotY === undefined)\n            _rotY = 0;\n        if (_rotZ === undefined)\n            _rotZ = 0;\n        this.rotActual.set(_rotX, _rotY, _rotZ);\n        this.rotTarget.set(_rotX, _rotY, _rotZ);\n        this.forceUpdate = true;\n    }\n    setRotRange(xMax, xMin, yMax, yMin) {\n        this.options.rotRange.xMax = xMax !== undefined ? xMax : this.options.rotRange.xMax;\n        this.options.rotRange.xMin = xMin !== undefined ? xMin : this.options.rotRange.xMin;\n        this.options.rotRange.yMax = yMax !== undefined ? yMax : this.options.rotRange.yMax;\n        this.options.rotRange.yMin = yMin !== undefined ? yMin : this.options.rotRange.yMin;\n    }\n    clearRotRange() {\n        this.options.rotRange.xMax = Number.POSITIVE_INFINITY;\n        this.options.rotRange.xMin = Number.NEGATIVE_INFINITY;\n        this.options.rotRange.yMax = Number.POSITIVE_INFINITY;\n        this.options.rotRange.yMin = Number.NEGATIVE_INFINITY;\n    }\n    dolly(distance) {\n        this.distTarget += distance;\n        this.distTarget = MathTool.clamp(this.distTarget, this.options.distRange.min, this.options.distRange.max);\n    }\n    orbitBy(angleX, angleY) {\n        this.rotTarget.x += angleX;\n        this.rotTarget.y += angleY;\n        this.rotTarget.x = MathTool.clamp(this.rotTarget.x, this.options.rotRange.xMin, this.options.rotRange.xMax);\n        this.rotTarget.y = MathTool.clamp(this.rotTarget.y, this.options.rotRange.yMin, this.options.rotRange.yMax);\n    }\n    orbitTo(angleX, angleY) {\n        this.rotTarget.x = angleX;\n        this.rotTarget.y = angleY;\n        this.rotTarget.x = MathTool.clamp(this.rotTarget.x, this.options.rotRange.xMin, this.options.rotRange.xMax);\n        this.rotTarget.y = MathTool.clamp(this.rotTarget.y, this.options.rotRange.yMin, this.options.rotRange.yMax);\n    }\n    pan(distX, distY) {\n        this.focusTarget.x -= distX;\n        this.focusTarget.y += distY;\n    }\n    onWindowResize(vpW, vpH) {\n        this.vpW = vpW;\n        this.vpH = vpH;\n    }\n    changesOccurred() {\n        if (this.options.smartUpdates &&\n            this.rotActual.manhattanDistanceTo(this.rotTarget) < 0.01 &&\n            Math.abs(this.distActual - this.distTarget) < 0.01 &&\n            this.focusActual.manhattanDistanceTo(this.focusTarget) < 0.01) {\n            return false;\n        }\n        return true;\n    }\n}\n","import { Mat4 } from \"../maths/math.mat4\";\nimport { Object3D } from \"../object3D\";\nclass Camera extends Object3D {\n    constructor() {\n        super();\n        this.type = \"Camera\";\n        this.matrixWorldInverse = new Mat4();\n        this.projectionMatrix = new Mat4();\n        this.projectionMatrixInverse = new Mat4();\n    }\n    toJSON(meta) {\n        throw new Error(\"Method not implemented.\");\n    }\n    copy(source, recursive) {\n        super.copy(source, recursive);\n        this.matrixWorldInverse.copy(source.matrixWorldInverse);\n        this.projectionMatrix.copy(source.projectionMatrix);\n        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n        return this;\n    }\n    getWorldDirection(target) {\n        this.updateWorldMatrix(true, false);\n        const e = this.matrixWorld.data;\n        return target.set(-e[8], -e[9], -e[10]).normalize();\n    }\n    updateMatrixWorld() {\n        // super.updateMatrixWorld(force);\n        this.matrixWorld.copy(this.matrix);\n        this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n        super.updateWorldMatrix(updateParents, updateChildren);\n        this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    updateProjectionMatrix() { }\n    clone() {\n        // return new Camera().copy(this);\n    }\n}\nCamera.prototype.isCamera = true;\nexport { Camera };\n","export * from \"./PerspectiveCamera\";\n","export var PrimitiveType;\n(function (PrimitiveType) {\n    PrimitiveType[PrimitiveType[\"PRIMITIVE_POINTS\"] = 0] = \"PRIMITIVE_POINTS\";\n    PrimitiveType[PrimitiveType[\"PRIMITIVE_LINES\"] = 1] = \"PRIMITIVE_LINES\";\n    PrimitiveType[PrimitiveType[\"PRIMITIVE_LINELOOP\"] = 2] = \"PRIMITIVE_LINELOOP\";\n    PrimitiveType[PrimitiveType[\"PRIMITIVE_LINESTRIP\"] = 3] = \"PRIMITIVE_LINESTRIP\";\n    PrimitiveType[PrimitiveType[\"PRIMITIVE_TRIANGLES\"] = 4] = \"PRIMITIVE_TRIANGLES\";\n    PrimitiveType[PrimitiveType[\"PRIMITIVE_TRISTRIP\"] = 5] = \"PRIMITIVE_TRISTRIP\";\n    PrimitiveType[PrimitiveType[\"PRIMITIVE_TRIFAN\"] = 6] = \"PRIMITIVE_TRIFAN\";\n})(PrimitiveType || (PrimitiveType = {}));\nexport class EngineDraw {\n    constructor(engine) {\n        this._engine = engine;\n        const { gl } = this._engine;\n        this._glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];\n    }\n    /**\n     * Gets the current render width\n     * @returns a number defining the current render width\n     */\n    getRenderWidth() {\n        return this._engine.gl.drawingBufferWidth;\n    }\n    /**\n     * Gets the current render height\n     * @returns a number defining the current render height\n     */\n    getRenderHeight() {\n        return this._engine.gl.drawingBufferHeight;\n    }\n    draw(primitive) {\n        if (!primitive.type) {\n            throw new Error(\"error primitive type\");\n        }\n        if (primitive.count === undefined) {\n            throw new Error(\"error primitive count\");\n        }\n        const mode = this._glPrimitive[primitive.type];\n        const count = primitive.count;\n        const { gl } = this._engine;\n        if (primitive.indexed && primitive.type === PrimitiveType.PRIMITIVE_TRIANGLES) {\n            gl.drawElements(mode, count, gl.UNSIGNED_SHORT, 0);\n        }\n        else if (primitive.type === PrimitiveType.PRIMITIVE_LINES) {\n            gl.lineWidth(1);\n            gl.drawArrays(gl.LINES, 0, count);\n        }\n    }\n}\n","export var UniformsType;\n(function (UniformsType) {\n    UniformsType[UniformsType[\"Texture\"] = 0] = \"Texture\";\n    UniformsType[UniformsType[\"Float\"] = 1] = \"Float\";\n    UniformsType[UniformsType[\"Vec2\"] = 2] = \"Vec2\";\n    UniformsType[UniformsType[\"Vec3\"] = 3] = \"Vec3\";\n    UniformsType[UniformsType[\"Vec4\"] = 4] = \"Vec4\";\n    UniformsType[UniformsType[\"Mat3\"] = 5] = \"Mat3\";\n    UniformsType[UniformsType[\"Mat4\"] = 6] = \"Mat4\";\n    UniformsType[UniformsType[\"Struct\"] = 7] = \"Struct\";\n    UniformsType[UniformsType[\"Array\"] = 8] = \"Array\";\n})(UniformsType || (UniformsType = {}));\nexport var TextureFormat;\n(function (TextureFormat) {\n    /**\n     * 8-bit alpha.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_A8\"] = 0] = \"PIXELFORMAT_A8\";\n    /**\n     * 8-bit luminance.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_L8\"] = 1] = \"PIXELFORMAT_L8\";\n    /**\n     * 8-bit luminance with 8-bit alpha.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_L8_A8\"] = 2] = \"PIXELFORMAT_L8_A8\";\n    /**\n     * 16-bit RGB (5-bits for red channel, 6 for green and 5 for blue).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_R5_G6_B5\"] = 3] = \"PIXELFORMAT_R5_G6_B5\";\n    /**\n     * 16-bit RGBA (5-bits for red channel, 5 for green, 5 for blue with 1-bit alpha).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_R5_G5_B5_A1\"] = 4] = \"PIXELFORMAT_R5_G5_B5_A1\";\n    /**\n     * 16-bit RGBA (4-bits for red channel, 4 for green, 4 for blue with 4-bit alpha).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_R4_G4_B4_A4\"] = 5] = \"PIXELFORMAT_R4_G4_B4_A4\";\n    /**\n     * 24-bit RGB (8-bits for red channel, 8 for green and 8 for blue).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_R8_G8_B8\"] = 6] = \"PIXELFORMAT_R8_G8_B8\";\n    /**\n     * 32-bit RGBA (8-bits for red channel, 8 for green, 8 for blue with 8-bit alpha).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_R8_G8_B8_A8\"] = 7] = \"PIXELFORMAT_R8_G8_B8_A8\";\n    /**\n     * Block compressed format storing 16 input pixels in 64 bits of output, consisting of two 16-bit\n     * RGB 5:6:5 color values and a 4x4 two bit lookup table.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_DXT1\"] = 8] = \"PIXELFORMAT_DXT1\";\n    /**\n     * Block compressed format storing 16 input pixels (corresponding to a 4x4 pixel block) into 128\n     * bits of output, consisting of 64 bits of alpha channel data (4 bits for each pixel) followed by\n     * 64 bits of color data, encoded the same way as DXT1.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_DXT3\"] = 9] = \"PIXELFORMAT_DXT3\";\n    /**\n     * Block compressed format storing 16 input pixels into 128 bits of output, consisting of 64 bits\n     * of alpha channel data (two 8 bit alpha values and a 4x4 3 bit lookup table) followed by 64 bits\n     * of color data (encoded the same way as DXT1).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_DXT5\"] = 10] = \"PIXELFORMAT_DXT5\";\n    /**\n     * 16-bit floating point RGB (16-bit float for each red, green and blue channels).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_RGB16F\"] = 11] = \"PIXELFORMAT_RGB16F\";\n    /**\n     * 16-bit floating point RGBA (16-bit float for each red, green, blue and alpha channels).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_RGBA16F\"] = 12] = \"PIXELFORMAT_RGBA16F\";\n    /**\n     * 32-bit floating point RGB (32-bit float for each red, green and blue channels).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_RGB32F\"] = 13] = \"PIXELFORMAT_RGB32F\";\n    /**\n     * 32-bit floating point RGBA (32-bit float for each red, green, blue and alpha channels).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_RGBA32F\"] = 14] = \"PIXELFORMAT_RGBA32F\";\n    /**\n     * 32-bit floating point single channel format (WebGL2 only).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_R32F\"] = 15] = \"PIXELFORMAT_R32F\";\n    /**\n     * A readable depth buffer format.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_DEPTH\"] = 16] = \"PIXELFORMAT_DEPTH\";\n    /**\n     * A readable depth/stencil buffer format (WebGL2 only).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_DEPTHSTENCIL\"] = 17] = \"PIXELFORMAT_DEPTHSTENCIL\";\n    /**\n     * A floating-point color-only format with 11 bits for red and green channels and 10 bits for the\n     * blue channel (WebGL2 only).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_111110F\"] = 18] = \"PIXELFORMAT_111110F\";\n    /**\n     * Color-only sRGB format (WebGL2 only).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_SRGB\"] = 19] = \"PIXELFORMAT_SRGB\";\n    /**\n     * Color sRGB format with additional alpha channel (WebGL2 only).\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_SRGBA\"] = 20] = \"PIXELFORMAT_SRGBA\";\n    /**\n     * ETC1 compressed format.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_ETC1\"] = 21] = \"PIXELFORMAT_ETC1\";\n    /**\n     * ETC2 (RGB) compressed format.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_ETC2_RGB\"] = 22] = \"PIXELFORMAT_ETC2_RGB\";\n    /**\n     * ETC2 (RGBA) compressed format.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_ETC2_RGBA\"] = 23] = \"PIXELFORMAT_ETC2_RGBA\";\n    /**\n     * PVRTC (2BPP RGB) compressed format.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_PVRTC_2BPP_RGB_1\"] = 24] = \"PIXELFORMAT_PVRTC_2BPP_RGB_1\";\n    /**\n     * PVRTC (2BPP RGBA) compressed format.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_PVRTC_2BPP_RGBA_1\"] = 25] = \"PIXELFORMAT_PVRTC_2BPP_RGBA_1\";\n    /**\n     * PVRTC (4BPP RGB) compressed format.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_PVRTC_4BPP_RGB_1\"] = 26] = \"PIXELFORMAT_PVRTC_4BPP_RGB_1\";\n    /**\n     * PVRTC (4BPP RGBA) compressed format.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_PVRTC_4BPP_RGBA_1\"] = 27] = \"PIXELFORMAT_PVRTC_4BPP_RGBA_1\";\n    /**\n     * ATC compressed format with alpha channel in blocks of 4x4.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_ASTC_4x4\"] = 28] = \"PIXELFORMAT_ASTC_4x4\";\n    /**\n     * ATC compressed format with no alpha channel.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_ATC_RGB\"] = 29] = \"PIXELFORMAT_ATC_RGB\";\n    /**\n     * ATC compressed format with alpha channel.\n     */\n    TextureFormat[TextureFormat[\"PIXELFORMAT_ATC_RGBA\"] = 30] = \"PIXELFORMAT_ATC_RGBA\";\n})(TextureFormat || (TextureFormat = {}));\nexport var TextureFilter;\n(function (TextureFilter) {\n    /**\n     * Point sample filtering.\n     */\n    TextureFilter[TextureFilter[\"FILTER_NEAREST\"] = 0] = \"FILTER_NEAREST\";\n    /**\n     * Bilinear filtering.\n     */\n    TextureFilter[TextureFilter[\"FILTER_LINEAR\"] = 1] = \"FILTER_LINEAR\";\n    /**\n     * Use the nearest neighbor in the nearest mipmap level.\n     */\n    TextureFilter[TextureFilter[\"FILTER_NEAREST_MIPMAP_NEAREST\"] = 2] = \"FILTER_NEAREST_MIPMAP_NEAREST\";\n    /**\n     * Linearly interpolate in the nearest mipmap level.\n     */\n    TextureFilter[TextureFilter[\"FILTER_NEAREST_MIPMAP_LINEAR\"] = 3] = \"FILTER_NEAREST_MIPMAP_LINEAR\";\n    /**\n     * Use the nearest neighbor after linearly interpolating between mipmap levels.\n     */\n    TextureFilter[TextureFilter[\"FILTER_LINEAR_MIPMAP_NEAREST\"] = 4] = \"FILTER_LINEAR_MIPMAP_NEAREST\";\n    /**\n     * Linearly interpolate both the mipmap levels and between texels.\n     */\n    TextureFilter[TextureFilter[\"FILTER_LINEAR_MIPMAP_LINEAR\"] = 5] = \"FILTER_LINEAR_MIPMAP_LINEAR\";\n})(TextureFilter || (TextureFilter = {}));\nexport var TextureAddress;\n(function (TextureAddress) {\n    /**\n     * Ignores the integer part of texture coordinates, using only the fractional part.\n     */\n    TextureAddress[TextureAddress[\"ADDRESS_REPEAT\"] = 0] = \"ADDRESS_REPEAT\";\n    /**\n     * Clamps texture coordinate to the range 0 to 1.\n     */\n    TextureAddress[TextureAddress[\"ADDRESS_CLAMP_TO_EDGE\"] = 1] = \"ADDRESS_CLAMP_TO_EDGE\";\n    /**\n     * Texture coordinate to be set to the fractional part if the integer part is even. If the integer\n     * part is odd, then the texture coordinate is set to 1 minus the fractional part.\n     */\n    TextureAddress[TextureAddress[\"ADDRESS_MIRRORED_REPEAT\"] = 2] = \"ADDRESS_MIRRORED_REPEAT\";\n})(TextureAddress || (TextureAddress = {}));\nexport var CompareFunc;\n(function (CompareFunc) {\n    /**\n     * Never pass.\n     */\n    CompareFunc[CompareFunc[\"FUNC_NEVER\"] = 0] = \"FUNC_NEVER\";\n    /**\n     * Pass if (ref & mask) < (stencil & mask).\n     */\n    CompareFunc[CompareFunc[\"FUNC_LESS\"] = 1] = \"FUNC_LESS\";\n    /**\n     * Pass if (ref & mask) == (stencil & mask).\n     */\n    CompareFunc[CompareFunc[\"FUNC_EQUAL\"] = 2] = \"FUNC_EQUAL\";\n    /**\n     * Pass if (ref & mask) <= (stencil & mask).\n     */\n    CompareFunc[CompareFunc[\"FUNC_LESSEQUAL\"] = 3] = \"FUNC_LESSEQUAL\";\n    /**\n     * Pass if (ref & mask) > (stencil & mask).\n     */\n    CompareFunc[CompareFunc[\"FUNC_GREATER\"] = 4] = \"FUNC_GREATER\";\n    /**\n     * Pass if (ref & mask) != (stencil & mask).\n     */\n    CompareFunc[CompareFunc[\"FUNC_NOTEQUAL\"] = 5] = \"FUNC_NOTEQUAL\";\n    /**\n     * Pass if (ref & mask) >= (stencil & mask).\n     */\n    CompareFunc[CompareFunc[\"FUNC_GREATEREQUAL\"] = 6] = \"FUNC_GREATEREQUAL\";\n    /**\n     * Always pass.\n     */\n    CompareFunc[CompareFunc[\"FUNC_ALWAYS\"] = 7] = \"FUNC_ALWAYS\";\n})(CompareFunc || (CompareFunc = {}));\nexport var BlendMode;\n(function (BlendMode) {\n    /**\n     * Multiply all fragment components by zero.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_ZERO\"] = 0] = \"BLENDMODE_ZERO\";\n    /**\n     * Multiply all fragment components by one.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_ONE\"] = 1] = \"BLENDMODE_ONE\";\n    /**\n     * Multiply all fragment components by the components of the source fragment.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_SRC_COLOR\"] = 2] = \"BLENDMODE_SRC_COLOR\";\n    /**\n     * Multiply all fragment components by one minus the components of the source fragment.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_ONE_MINUS_SRC_COLOR\"] = 3] = \"BLENDMODE_ONE_MINUS_SRC_COLOR\";\n    /**\n     * Multiply all fragment components by the components of the destination fragment.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_DST_COLOR\"] = 4] = \"BLENDMODE_DST_COLOR\";\n    /**\n     * Multiply all fragment components by one minus the components of the destination fragment.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_ONE_MINUS_DST_COLOR\"] = 5] = \"BLENDMODE_ONE_MINUS_DST_COLOR\";\n    /**\n     * Multiply all fragment components by the alpha value of the source fragment.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_SRC_ALPHA\"] = 6] = \"BLENDMODE_SRC_ALPHA\";\n    /**\n     * Multiply all fragment components by the alpha value of the source fragment.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_SRC_ALPHA_SATURATE\"] = 7] = \"BLENDMODE_SRC_ALPHA_SATURATE\";\n    /**\n     * Multiply all fragment components by one minus the alpha value of the source fragment.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_ONE_MINUS_SRC_ALPHA\"] = 8] = \"BLENDMODE_ONE_MINUS_SRC_ALPHA\";\n    /**\n     * Multiply all fragment components by the alpha value of the destination fragment.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_DST_ALPHA\"] = 9] = \"BLENDMODE_DST_ALPHA\";\n    /**\n     * Multiply all fragment components by one minus the alpha value of the destination fragment.\n     */\n    BlendMode[BlendMode[\"BLENDMODE_ONE_MINUS_DST_ALPHA\"] = 10] = \"BLENDMODE_ONE_MINUS_DST_ALPHA\";\n})(BlendMode || (BlendMode = {}));\nexport var BlendEquation;\n(function (BlendEquation) {\n    /**\n     * Add the results of the source and destination fragment multiplies.\n     */\n    BlendEquation[BlendEquation[\"BLENDEQUATION_ADD\"] = 0] = \"BLENDEQUATION_ADD\";\n    /**\n     * Subtract the results of the source and destination fragment multiplies.\n     */\n    BlendEquation[BlendEquation[\"BLENDEQUATION_SUBTRACT\"] = 1] = \"BLENDEQUATION_SUBTRACT\";\n    /**\n     * Reverse and subtract the results of the source and destination fragment multiplies.\n     */\n    BlendEquation[BlendEquation[\"BLENDEQUATION_REVERSE_SUBTRACT\"] = 2] = \"BLENDEQUATION_REVERSE_SUBTRACT\";\n    /**\n     * Use the smallest value. Check app.graphicsDevice.extBlendMinmax for support.\n     */\n    BlendEquation[BlendEquation[\"BLENDEQUATION_MIN\"] = 3] = \"BLENDEQUATION_MIN\";\n    /**\n     * Use the largest value. Check app.graphicsDevice.extBlendMinmax for support.\n     */\n    BlendEquation[BlendEquation[\"BLENDEQUATION_MAX\"] = 4] = \"BLENDEQUATION_MAX\";\n})(BlendEquation || (BlendEquation = {}));\nexport var CullFace;\n(function (CullFace) {\n    /**\n     * No triangles are culled.\n     */\n    CullFace[CullFace[\"CULLFACE_NONE\"] = 0] = \"CULLFACE_NONE\";\n    /**\n     * Triangles facing away from the view direction are culled.\n     */\n    CullFace[CullFace[\"CULLFACE_BACK\"] = 1] = \"CULLFACE_BACK\";\n    /**\n     * Triangles facing the view direction are culled.\n     */\n    CullFace[CullFace[\"CULLFACE_FRONT\"] = 2] = \"CULLFACE_FRONT\";\n    /**\n     * Triangles are culled regardless of their orientation with respect to the view direction. Note\n     * that point or line primitives are unaffected by this render state.\n     */\n    CullFace[CullFace[\"CULLFACE_FRONTANDBACK\"] = 3] = \"CULLFACE_FRONTANDBACK\";\n})(CullFace || (CullFace = {}));\nexport var ClearFlag;\n(function (ClearFlag) {\n    ClearFlag[ClearFlag[\"CLEARFLAG_NULL\"] = 0] = \"CLEARFLAG_NULL\";\n    /**\n     * Clear the color buffer.\n     */\n    ClearFlag[ClearFlag[\"CLEARFLAG_COLOR\"] = 1] = \"CLEARFLAG_COLOR\";\n    /**\n     * Clear the depth buffer.\n     */\n    ClearFlag[ClearFlag[\"CLEARFLAG_DEPTH\"] = 2] = \"CLEARFLAG_DEPTH\";\n    /**\n     * Clear the stencil buffer.\n     */\n    ClearFlag[ClearFlag[\"CLEARFLAG_STENCIL\"] = 4] = \"CLEARFLAG_STENCIL\";\n})(ClearFlag || (ClearFlag = {}));\n","import { ShaderProcess } from \"../misc/shaderProcess\";\n// \nvar SHADER_INFO_TYPE;\n(function (SHADER_INFO_TYPE) {\n    SHADER_INFO_TYPE[\"DELETE_STATUS\"] = \"DELETE_STATUS\";\n    SHADER_INFO_TYPE[\"COMPILE_STATUS\"] = \"COMPILE_STATUS\";\n    SHADER_INFO_TYPE[\"SHADER_TYPE\"] = \"SHADER_TYPE\";\n})(SHADER_INFO_TYPE || (SHADER_INFO_TYPE = {}));\n// shader \nvar SHADER_TYPE;\n(function (SHADER_TYPE) {\n    SHADER_TYPE[\"VERTEX_SHADER\"] = \"VERTEX_SHADER\";\n    SHADER_TYPE[\"FRAGMENT_SHADER\"] = \"FRAGMENT_SHADER\";\n})(SHADER_TYPE || (SHADER_TYPE = {}));\nexport class EngineProgram {\n    constructor(engine) {\n        this._engine = engine;\n    }\n    _getShader(type, source) {\n        const { gl } = this._engine;\n        // \n        const shader = gl.createShader(gl[type]);\n        if (!shader) {\n            throw new Error(\"Something went wrong while compile the shader.\");\n        }\n        // \n        gl.shaderSource(shader, source);\n        // \n        gl.compileShader(shader);\n        //\n        let success = this._getShaderInfo(shader, SHADER_INFO_TYPE.COMPILE_STATUS);\n        if (success) {\n            return shader;\n        }\n        console.error(gl.getShaderInfoLog(shader), source);\n        this._deleteShader(shader);\n        return true;\n    }\n    _getShaderInfo(shader, type) {\n        const { gl } = this._engine;\n        return gl.getShaderParameter(shader, gl[type]);\n    }\n    _deleteShader(shader) {\n        const { gl } = this._engine;\n        gl.deleteShader(shader);\n    }\n    _createProgram(vertexShader, fragmentShader) {\n        const { gl } = this._engine;\n        const program = gl.createProgram();\n        if (!program) {\n            throw new Error(\"Unable to create program\");\n        }\n        // shader, shader\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        // \n        gl.linkProgram(program);\n        let result = gl.getProgramParameter(program, gl.LINK_STATUS);\n        if (result) {\n            // console.log('');\n            this._deleteShader(vertexShader);\n            this._deleteShader(fragmentShader);\n            return program;\n        }\n        let errorLog = gl.getProgramInfoLog(program);\n        gl.deleteProgram(program);\n        throw errorLog;\n    }\n    createProgram(shaderSource) {\n        let { vertexShader: vs, fragmentShader: fs } = shaderSource;\n        const header = ShaderProcess.getHead();\n        const defines = ShaderProcess.generateDefines(shaderSource.defines);\n        vs = header + defines + vs;\n        fs = header + defines + fs;\n        //\n        const vertexShader = this._getShader(SHADER_TYPE.VERTEX_SHADER, vs);\n        //\n        let fragmentShader = this._getShader(SHADER_TYPE.FRAGMENT_SHADER, fs);\n        //\n        const program = this._createProgram(vertexShader, fragmentShader);\n        return {\n            vertexShader: vs,\n            fragmentShader: fs,\n            program,\n        };\n    }\n    deleteProgram(program) {\n        this._engine.gl.deleteProgram(program);\n    }\n    useProgram(program) {\n        this._engine.gl.useProgram(program);\n    }\n}\n","export class EngineRenderTarget {\n    constructor(engine) {\n        this._engine = engine;\n        this.maxRenderBufferSize = this._engine.capabilities.maxRenderBufferSize;\n    }\n    /**\n     * Binds the specified framebuffer object.\n     *\n     * @param {WebGLFramebuffer} fb - The framebuffer to bind.\n     * @ignore\n     */\n    setFramebuffer(fb) {\n        const { gl } = this._engine;\n        if (this.activeFramebuffer !== fb) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n            this.activeFramebuffer = fb;\n        }\n        if (gl.getError() != gl.NO_ERROR) {\n            throw \"Some WebGL error occurred while trying to create framebuffer.\";\n        }\n    }\n    /**\n     * Initialize render target before it can be used.\n     *\n     * @param {RenderTarget} target - The render target to be initialized.\n     * @ignore\n     */\n    initRenderTarget(target) {\n        if (target.glFrameBuffer)\n            return;\n        const { gl, webgl2 } = this._engine;\n        // ##### Create main FBO #####\n        target.glFrameBuffer = gl.createFramebuffer();\n        this.setFramebuffer(target.glFrameBuffer);\n        // --- Init the provided color buffer (optional) ---\n        const colorBuffer = target.colorBuffer;\n        if (colorBuffer) {\n            if (!colorBuffer.glTexture) {\n                // Clamp the render buffer size to the maximum supported by the device\n                colorBuffer.width = Math.min(colorBuffer.width, this.maxRenderBufferSize);\n                colorBuffer.height = Math.min(colorBuffer.height, this.maxRenderBufferSize);\n                this._engine.engineTexture.setTexture(colorBuffer, 0);\n            }\n            // Attach the color buffer\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorBuffer.glTexture, 0);\n        }\n        const depthBuffer = target.depthBuffer;\n        if (depthBuffer && webgl2) {\n            // --- Init the provided depth/stencil buffer (optional, WebGL2 only) ---\n            if (!depthBuffer.glTexture) {\n                // Clamp the render buffer size to the maximum supported by the device\n                depthBuffer.width = Math.min(depthBuffer.width, this.maxRenderBufferSize);\n                depthBuffer.height = Math.min(depthBuffer.height, this.maxRenderBufferSize);\n                this._engine.engineTexture.setTexture(depthBuffer, 0);\n            }\n            // Attach\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, target.depthBuffer.glTexture, 0);\n        }\n        // gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    }\n    setRenderTarget(target) {\n        const { gl } = this._engine;\n        if (target !== null) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, target.glFrameBuffer);\n            if (target.depth) {\n                gl.bindRenderbuffer(gl.RENDERBUFFER, target.glDepthBuffer);\n            }\n        }\n        else {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n    }\n}\n","import { ClearFlag, CullFace } from \"./engine.enum\";\nexport class EngineState {\n    constructor(engine) {\n        this._engine = engine;\n        this._depthWrite = true;\n        const { gl } = this._engine;\n        this._glBlendFunction = [\n            gl.ZERO,\n            gl.ONE,\n            gl.SRC_COLOR,\n            gl.ONE_MINUS_SRC_COLOR,\n            gl.DST_COLOR,\n            gl.ONE_MINUS_DST_COLOR,\n            gl.SRC_ALPHA,\n            gl.SRC_ALPHA_SATURATE,\n            gl.ONE_MINUS_SRC_ALPHA,\n            gl.DST_ALPHA,\n            gl.ONE_MINUS_DST_ALPHA,\n        ];\n        this._glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];\n        this._glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, gl.MIN, gl.MAX];\n        this._glClearFlag = [\n            0,\n            gl.COLOR_BUFFER_BIT,\n            gl.DEPTH_BUFFER_BIT,\n            gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,\n            gl.STENCIL_BUFFER_BIT,\n            gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT,\n            gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,\n            gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,\n        ];\n        this._defaultClearOptions = {\n            color: { r: 0, g: 0, b: 0, a: 1 },\n            depth: 1,\n            stencil: 0,\n            flags: ClearFlag.CLEARFLAG_COLOR | ClearFlag.CLEARFLAG_DEPTH,\n        };\n        this.setDepthTest(true);\n        this._cullMode = CullFace.CULLFACE_NONE;\n        this.setCullMode(CullFace.CULLFACE_BACK);\n    }\n    /**\n     * Queries whether depth testing is enabled.\n     *\n     * @returns {boolean} True if depth testing is enabled and false otherwise.\n     * @example\n     * var depthTest = device.getDepthTest();\n     * console.log('Depth testing is ' + depthTest ? 'enabled' : 'disabled');\n     */\n    getDepthTest() {\n        return this._depthTest;\n    }\n    /**\n     * Enables or disables depth testing of fragments. Once this state is set, it persists until it\n     * is changed. By default, depth testing is enabled.\n     *\n     * @param {boolean} depthTest - True to enable depth testing and false otherwise.\n     * @example\n     * device.setDepthTest(true);\n     */\n    setDepthTest(depthTest) {\n        const { gl } = this._engine;\n        if (this._depthTest !== depthTest) {\n            if (depthTest) {\n                gl.enable(gl.DEPTH_TEST);\n            }\n            else {\n                gl.disable(gl.DEPTH_TEST);\n            }\n            this._depthTest = depthTest;\n        }\n    }\n    /**\n     * Configures the depth test.\n     *\n     * @param {number} func - A function to compare a new depth value with an existing z-buffer\n     * value and decide if to write a pixel. Can be:\n     *\n     * - {@link FUNC_NEVER}: don't draw\n     * - {@link FUNC_LESS}: draw if new depth < depth buffer\n     * - {@link FUNC_EQUAL}: draw if new depth == depth buffer\n     * - {@link FUNC_LESSEQUAL}: draw if new depth <= depth buffer\n     * - {@link FUNC_GREATER}: draw if new depth > depth buffer\n     * - {@link FUNC_NOTEQUAL}: draw if new depth != depth buffer\n     * - {@link FUNC_GREATEREQUAL}: draw if new depth >= depth buffer\n     * - {@link FUNC_ALWAYS}: always draw\n     */\n    setDepthFunc(func) {\n        const { gl, glComparison } = this._engine;\n        if (this._depthFunc === func)\n            return;\n        gl.depthFunc(glComparison[func]);\n        this._depthFunc = func;\n    }\n    /**\n     * Queries whether writes to the depth buffer are enabled.\n     *\n     * @returns {boolean} True if depth writing is enabled and false otherwise.\n     * @example\n     * var depthWrite = device.getDepthWrite();\n     * console.log('Depth writing is ' + depthWrite ? 'enabled' : 'disabled');\n     */\n    getDepthWrite() {\n        return this._depthWrite;\n    }\n    /**\n     * Enables or disables writes to the depth buffer. Once this state is set, it persists until it\n     * is changed. By default, depth writes are enabled.\n     *\n     * @param {boolean} writeDepth - True to enable depth writing and false otherwise.\n     * @example\n     * device.setDepthWrite(true);\n     */\n    setDepthWrite(writeDepth) {\n        const { gl } = this._engine;\n        if (this._depthWrite !== writeDepth) {\n            gl.depthMask(writeDepth);\n            this._depthWrite = writeDepth;\n        }\n    }\n    /**\n     * Queries whether blending is enabled.\n     *\n     * @returns {boolean} True if blending is enabled and false otherwise.\n     */\n    getBlending() {\n        return this._blending;\n    }\n    /**\n     * Enables or disables blending.\n     *\n     * @param {boolean} blending - True to enable blending and false to disable it.\n     */\n    setBlending(blending) {\n        const { gl } = this._engine;\n        if (this._blending !== blending) {\n            if (blending) {\n                gl.enable(gl.BLEND);\n            }\n            else {\n                gl.disable(gl.BLEND);\n            }\n            this._blending = blending;\n        }\n    }\n    /**\n     * Configures blending operations. Both source and destination blend modes can take the\n     * following values:\n     *\n     * @param {number} blendSrc - The source blend function.\n     * @param {number} blendDst - The destination blend function.\n     */\n    setBlendFunction(blendSrc, blendDst) {\n        const { gl } = this._engine;\n        if (this._blendSrc !== blendSrc || this._blendDst !== blendDst || this._separateAlphaBlend) {\n            gl.blendFunc(this._glBlendFunction[blendSrc], this._glBlendFunction[blendDst]);\n            this._blendSrc = blendSrc;\n            this._blendDst = blendDst;\n            this._separateAlphaBlend = false;\n        }\n    }\n    /**\n     * Configures blending operations. Both source and destination blend modes can take the\n     * following values:\n     *\n     * - {@link BLENDMODE_ZERO}\n     * - {@link BLENDMODE_ONE}\n     * - {@link BLENDMODE_SRC_COLOR}\n     * - {@link BLENDMODE_ONE_MINUS_SRC_COLOR}\n     * - {@link BLENDMODE_DST_COLOR}\n     * - {@link BLENDMODE_ONE_MINUS_DST_COLOR}\n     * - {@link BLENDMODE_SRC_ALPHA}\n     * - {@link BLENDMODE_SRC_ALPHA_SATURATE}\n     * - {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}\n     * - {@link BLENDMODE_DST_ALPHA}\n     * - {@link BLENDMODE_ONE_MINUS_DST_ALPHA}\n     *\n     * @param {number} blendSrc - The source blend function.\n     * @param {number} blendDst - The destination blend function.\n     * @param {number} blendSrcAlpha - The separate source blend function for the alpha channel.\n     * @param {number} blendDstAlpha - The separate destination blend function for the alpha channel.\n     */\n    setBlendFunctionSeparate(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {\n        const { gl } = this._engine;\n        if (this._blendSrc !== blendSrc || this._blendDst !== blendDst || this._blendSrcAlpha !== blendSrcAlpha || this._blendDstAlpha !== blendDstAlpha || !this._separateAlphaBlend) {\n            gl.blendFuncSeparate(this._glBlendFunction[blendSrc], this._glBlendFunction[blendDst], this._glBlendFunction[blendSrcAlpha], this._glBlendFunction[blendDstAlpha]);\n            this._blendSrc = blendSrc;\n            this._blendDst = blendDst;\n            this._blendSrcAlpha = blendSrcAlpha;\n            this._blendDstAlpha = blendDstAlpha;\n            this._separateAlphaBlend = true;\n        }\n    }\n    /**\n     * Configures the blending equation. The default blend equation is {@link BLENDEQUATION_ADD}.\n     *\n     * @param {number} blendEquation - The blend equation. Can be:\n     *\n     * - {@link BLENDEQUATION_ADD}\n     * - {@link BLENDEQUATION_SUBTRACT}\n     * - {@link BLENDEQUATION_REVERSE_SUBTRACT}\n     * - {@link BLENDEQUATION_MIN}\n     * - {@link BLENDEQUATION_MAX}\n     *\n     * Note that MIN and MAX modes require either EXT_blend_minmax or WebGL2 to work (check\n     * device.extBlendMinmax).\n     * @param {number} blendAlphaEquation - A separate blend equation for the alpha channel.\n     * Accepts same values as `blendEquation`.\n     */\n    setBlendEquationSeparate(blendEquation, blendAlphaEquation) {\n        const { gl } = this._engine;\n        if (this._blendEquation !== blendEquation || this._blendAlphaEquation !== blendAlphaEquation || !this._separateAlphaEquation) {\n            gl.blendEquationSeparate(this._glBlendEquation[blendEquation], this._glBlendEquation[blendAlphaEquation]);\n            this._blendEquation = blendEquation;\n            this._blendAlphaEquation = blendAlphaEquation;\n            this._separateAlphaEquation = true;\n        }\n    }\n    /**\n     * Controls how triangles are culled based on their face direction. The default cull mode is\n     * {@link CULLFACE_BACK}.\n     *\n     * @param {number} cullMode - The cull mode to set. Can be:\n     *\n     * - {@link CULLFACE_NONE}\n     * - {@link CULLFACE_BACK}\n     * - {@link CULLFACE_FRONT}\n     * - {@link CULLFACE_FRONTANDBACK}\n     */\n    setCullMode(cullMode) {\n        const { gl } = this._engine;\n        if (this._cullMode !== cullMode) {\n            if (cullMode === CullFace.CULLFACE_NONE) {\n                gl.disable(gl.CULL_FACE);\n            }\n            else {\n                if (this._cullMode === CullFace.CULLFACE_NONE) {\n                    gl.enable(gl.CULL_FACE);\n                }\n                const mode = this._glCull[cullMode];\n                if (this._cullFace !== mode) {\n                    gl.cullFace(mode);\n                    this._cullFace = mode;\n                }\n            }\n            this._cullMode = cullMode;\n        }\n    }\n    /**\n     * Gets the current cull mode.\n     *\n     * @returns {number} The current cull mode.\n     * @ignore\n     */\n    getCullMode() {\n        return this._cullMode;\n    }\n    /**\n     * Set the stencil clear value used when the stencil buffer is cleared.\n     *\n     * @param {number} value - The stencil value to clear the stencil buffer to.\n     */\n    setClearStencil(value) {\n        const { gl } = this._engine;\n        if (value !== this._clearStencil) {\n            gl.clearStencil(value);\n            this._clearStencil = value;\n        }\n    }\n    /**\n     * Set the depth value used when the depth buffer is cleared.\n     *\n     * @param {number} depth - The depth value to clear the depth buffer to in the range 0.0\n     * to 1.0.\n     * @ignore\n     */\n    setClearDepth(depth) {\n        const { gl } = this._engine;\n        if (depth !== this._clearDepth) {\n            gl.clearDepth(depth);\n            this._clearDepth = depth;\n        }\n    }\n    /**\n     * Set the clear color used when the frame buffer is cleared.\n     *\n     * @param {number} r - The red component of the color in the range 0.0 to 1.0.\n     * @param {number} g - The green component of the color in the range 0.0 to 1.0.\n     * @param {number} b - The blue component of the color in the range 0.0 to 1.0.\n     * @param {number} a - The alpha component of the color in the range 0.0 to 1.0.\n     * @ignore\n     */\n    setClearColor(r, g, b, a) {\n        const { gl } = this._engine;\n        if (r !== this._clearRed || g !== this._clearGreen || b !== this._clearBlue || a !== this._clearAlpha) {\n            gl.clearColor(r, g, b, a);\n            this._clearRed = r;\n            this._clearGreen = g;\n            this._clearBlue = b;\n            this._clearAlpha = a;\n        }\n    }\n    /**\n     * Clears the frame buffer of the currently set render target.\n     *\n     * @param {object} [options] - Optional options object that controls the behavior of the clear\n     * operation defined as follows:\n     * @param {number[]} [options.color] - The color to clear the color buffer to in the range 0.0\n     * to 1.0 for each component.\n     * @param {number} [options.depth=1] - The depth value to clear the depth buffer to in the\n     * range 0.0 to 1.0.\n     * @param {number} [options.flags] - The buffers to clear (the types being color, depth and\n     * stencil). Can be any bitwise combination of:\n     *\n     * - {@link CLEARFLAG_COLOR}\n     * - {@link CLEARFLAG_DEPTH}\n     * - {@link CLEARFLAG_STENCIL}\n     *\n     * @param {number} [options.stencil=0] - The stencil value to clear the stencil buffer to. Defaults to 0.\n     * @example\n     * // Clear color buffer to black and depth buffer to 1.0\n     * device.clear();\n     *\n     * // Clear just the color buffer to red\n     * device.clear({\n     *     color: [1, 0, 0, 1],\n     *     flags: pc.CLEARFLAG_COLOR\n     * });\n     *\n     * // Clear color buffer to yellow and depth to 1.0\n     * device.clear({\n     *     color: [1, 1, 0, 1],\n     *     depth: 1,\n     *     flags: pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH\n     * });\n     */\n    clear(options) {\n        const { gl } = this._engine;\n        const defaultOptions = this._defaultClearOptions;\n        options = options || defaultOptions;\n        const flags = options.flags == undefined ? defaultOptions.flags : options.flags;\n        if (flags) {\n            // const gl = this.gl;\n            // Set the clear color\n            if (flags & ClearFlag.CLEARFLAG_COLOR) {\n                const color = options.color == undefined ? defaultOptions.color : options.color;\n                color && this.setClearColor(color.r, color.g, color.b, color.a);\n            }\n            if (flags & ClearFlag.CLEARFLAG_DEPTH) {\n                // Set the clear depth\n                const depth = options.depth == undefined ? defaultOptions.depth : options.depth;\n                depth && this.setClearDepth(depth);\n                if (!this._depthWrite) {\n                    gl.depthMask(true);\n                }\n            }\n            if (flags & ClearFlag.CLEARFLAG_STENCIL) {\n                // Set the clear stencil\n                const stencil = options.stencil == undefined ? defaultOptions.stencil : options.stencil;\n                stencil && this.setClearStencil(stencil);\n            }\n            // Clear the frame buffer\n            gl.clear(this._glClearFlag[flags]);\n            if (flags & ClearFlag.CLEARFLAG_DEPTH) {\n                if (!this._depthWrite) {\n                    gl.depthMask(false);\n                }\n            }\n        }\n    }\n}\n","import { isBrowserInterface } from \"../misc/domManagement\";\nimport { TextureAddress, TextureFormat } from \"./engine.enum\";\nexport class EngineTexture {\n    constructor(engine) {\n        this._engine = engine;\n        this.textureUnit = -1;\n        this.textureUnits = [];\n        this.targetToSlot = {};\n        const { gl } = this._engine;\n        this.targetToSlot[gl.TEXTURE_2D] = 0;\n        this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;\n        this.targetToSlot[gl.TEXTURE_3D] = 2;\n        this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];\n        this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];\n    }\n    /**\n     * Allocate WebGL resources for a texture and add it to the array of textures managed by this\n     * device.\n     *\n     * @param {Texture} texture - The texture to allocate WebGL resources for.\n     * @ignore\n     */\n    initializeTexture(texture) {\n        const { gl, webgl2 } = this._engine;\n        texture.glTexture = gl.createTexture();\n        texture.glTarget = texture.cubemap ? gl.TEXTURE_CUBE_MAP : texture.volume ? gl.TEXTURE_3D : gl.TEXTURE_2D;\n        switch (texture.format) {\n            case TextureFormat.PIXELFORMAT_A8:\n                texture.glFormat = gl.ALPHA;\n                texture.glInternalFormat = gl.ALPHA;\n                texture.glPixelType = gl.UNSIGNED_BYTE;\n                break;\n            case TextureFormat.PIXELFORMAT_L8:\n                texture.glFormat = gl.LUMINANCE;\n                texture.glInternalFormat = gl.LUMINANCE;\n                texture.glPixelType = gl.UNSIGNED_BYTE;\n                break;\n            case TextureFormat.PIXELFORMAT_L8_A8:\n                texture.glFormat = gl.LUMINANCE_ALPHA;\n                texture.glInternalFormat = gl.LUMINANCE_ALPHA;\n                texture.glPixelType = gl.UNSIGNED_BYTE;\n                break;\n            case TextureFormat.PIXELFORMAT_R5_G6_B5:\n                texture.glFormat = gl.RGB;\n                texture.glInternalFormat = gl.RGB;\n                texture.glPixelType = gl.UNSIGNED_SHORT_5_6_5;\n                break;\n            case TextureFormat.PIXELFORMAT_R5_G5_B5_A1:\n                texture.glFormat = gl.RGBA;\n                texture.glInternalFormat = gl.RGBA;\n                texture.glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;\n                break;\n            case TextureFormat.PIXELFORMAT_R4_G4_B4_A4:\n                texture.glFormat = gl.RGBA;\n                texture.glInternalFormat = gl.RGBA;\n                texture.glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;\n                break;\n            case TextureFormat.PIXELFORMAT_R8_G8_B8:\n                texture.glFormat = gl.RGB;\n                texture.glInternalFormat = webgl2 ? gl.RGB8 : gl.RGB;\n                texture.glPixelType = gl.UNSIGNED_BYTE;\n                break;\n            case TextureFormat.PIXELFORMAT_R8_G8_B8_A8:\n                texture.glFormat = gl.RGBA;\n                texture.glInternalFormat = webgl2 ? gl.RGBA8 : gl.RGBA;\n                texture.glPixelType = gl.UNSIGNED_BYTE;\n                break;\n            case TextureFormat.PIXELFORMAT_RGB32F:\n                // definition varies between WebGL1 and 2\n                texture.glFormat = gl.RGB;\n                if (webgl2) {\n                    texture.glInternalFormat = gl.RGB32F;\n                }\n                else {\n                    texture.glInternalFormat = gl.RGB;\n                }\n                texture.glPixelType = gl.FLOAT;\n                break;\n            case TextureFormat.PIXELFORMAT_RGBA32F:\n                // definition varies between WebGL1 and 2\n                texture.glFormat = gl.RGBA;\n                if (webgl2) {\n                    texture.glInternalFormat = gl.RGBA32F;\n                }\n                else {\n                    texture.glInternalFormat = gl.RGBA;\n                }\n                texture.glPixelType = gl.FLOAT;\n                break;\n            case TextureFormat.PIXELFORMAT_R32F: // WebGL2 only\n                texture.glFormat = gl.RED;\n                texture.glInternalFormat = gl.R32F;\n                texture.glPixelType = gl.FLOAT;\n                break;\n            case TextureFormat.PIXELFORMAT_DEPTH:\n                if (webgl2) {\n                    // native WebGL2\n                    texture.glFormat = gl.DEPTH_COMPONENT;\n                    texture.glInternalFormat = gl.DEPTH_COMPONENT32F; // should allow 16/24 bits?\n                    texture.glPixelType = gl.FLOAT;\n                }\n                else {\n                    // using WebGL1 extension\n                    texture.glFormat = gl.DEPTH_COMPONENT;\n                    texture.glInternalFormat = gl.DEPTH_COMPONENT;\n                    texture.glPixelType = gl.UNSIGNED_SHORT; // the only acceptable value?\n                }\n                break;\n            case TextureFormat.PIXELFORMAT_DEPTHSTENCIL: // WebGL2 only\n                texture.glFormat = gl.DEPTH_STENCIL;\n                texture.glInternalFormat = gl.DEPTH24_STENCIL8;\n                texture.glPixelType = gl.UNSIGNED_INT_24_8;\n                break;\n            case TextureFormat.PIXELFORMAT_111110F: // WebGL2 only\n                texture.glFormat = gl.RGB;\n                texture.glInternalFormat = gl.R11F_G11F_B10F;\n                texture.glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;\n                break;\n            case TextureFormat.PIXELFORMAT_SRGB: // WebGL2 only\n                texture.glFormat = gl.RGB;\n                texture.glInternalFormat = gl.SRGB8;\n                texture.glPixelType = gl.UNSIGNED_BYTE;\n                break;\n            case TextureFormat.PIXELFORMAT_SRGBA: // WebGL2 only\n                texture.glFormat = gl.RGBA;\n                texture.glInternalFormat = gl.SRGB8_ALPHA8;\n                texture.glPixelType = gl.UNSIGNED_BYTE;\n                break;\n        }\n    }\n    /**\n     * Activate the specified texture unit.\n     *\n     * @param {number} textureUnit - The texture unit to activate.\n     * @ignore\n     */\n    activeTexture(textureUnit) {\n        const { gl } = this._engine;\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        if (this.textureUnit !== textureUnit) {\n            this.textureUnit = textureUnit;\n        }\n    }\n    /**\n     * If the texture is not already bound on the currently active texture unit, bind it.\n     *\n     * @param {Texture} texture - The texture to bind.\n     * @ignore\n     */\n    bindTexture(texture) {\n        const { gl } = this._engine;\n        const textureTarget = texture.glTarget;\n        const textureObject = texture.glTexture;\n        const textureUnit = this.textureUnit;\n        // const slot = this.targetToSlot[textureTarget];\n        // if (this.textureUnits[textureUnit][slot] !== textureObject) {\n        //     gl.bindTexture(textureTarget, textureObject);\n        //     this.textureUnits[textureUnit][slot] = textureObject;\n        // }\n        gl.bindTexture(textureTarget, textureObject);\n    }\n    /**\n     * Update the texture parameters for a given texture if they have changed.\n     *\n     * @param {Texture} texture - The texture to update.\n     * @ignore\n     */\n    setTextureParameters(texture) {\n        const { gl, webgl2, glComparison } = this._engine;\n        const flags = texture.parameterFlags;\n        const target = texture.glTarget;\n        if (flags & 1) {\n            let filter = texture.minFilter;\n            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);\n        }\n        if (flags & 2) {\n            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture.magFilter]);\n        }\n        if (flags & 4) {\n            if (webgl2) {\n                gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.addressU]);\n            }\n            else {\n                // WebGL1 doesn't support all addressing modes with NPOT textures\n                gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture.addressU : TextureAddress.ADDRESS_CLAMP_TO_EDGE]);\n            }\n        }\n        if (flags & 8) {\n            if (webgl2) {\n                gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.addressV]);\n            }\n            else {\n                // WebGL1 doesn't support all addressing modes with NPOT textures\n                gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture.addressV : TextureAddress.ADDRESS_CLAMP_TO_EDGE]);\n            }\n        }\n        if (flags & 32) {\n            if (webgl2) {\n                gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture.compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);\n            }\n        }\n        if (flags & 64) {\n            if (webgl2) {\n                gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, glComparison[texture.compareFunc]);\n            }\n        }\n    }\n    /**\n     * Sets the specified texture on the specified texture unit.\n     *\n     * @param {Texture} texture - The texture to set.\n     * @param {number} textureUnit - The texture unit to set the texture on.\n     * @ignore\n     */\n    setTexture(texture, textureUnit) {\n        if (!texture.glTexture)\n            this.initializeTexture(texture);\n        if (texture.needsUpload) {\n            // Ensure the specified texture unit is active\n            this.activeTexture(textureUnit);\n            // Ensure the texture is bound on correct target of the specified texture unit\n            this.bindTexture(texture);\n            if (texture.parameterFlags) {\n                this.setTextureParameters(texture);\n                texture.parameterFlags = 0;\n            }\n            this.uploadTexture(texture);\n            texture.needsUpload = false;\n        }\n        else {\n            // Ensure the texture is currently bound to the correct target on the specified texture unit.\n            // If the texture is already bound to the correct target on the specified unit, there's no need\n            // to actually make the specified texture unit active because the texture itself does not need\n            // to be updated.\n            this.bindTextureOnUnit(texture, textureUnit);\n        }\n    }\n    /**\n     * Updates a texture's vertical flip.\n     *\n     * @param {boolean} flipY - True to flip the texture vertically.\n     * @ignore\n     */\n    setUnpackFlipY(flipY) {\n        const { gl } = this._engine;\n        if (this.unpackFlipY !== flipY) {\n            this.unpackFlipY = flipY;\n            // Note: the WebGL spec states that UNPACK_FLIP_Y_WEBGL only affects\n            // texImage2D and texSubImage2D, not compressedTexImage2D\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n        }\n    }\n    /**\n     * Updates a texture to have its RGB channels premultiplied by its alpha channel or not.\n     *\n     * @param {boolean} premultiplyAlpha - True to premultiply the alpha channel against the RGB\n     * channels.\n     * @ignore\n     */\n    setUnpackPremultiplyAlpha(premultiplyAlpha) {\n        const { gl } = this._engine;\n        if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {\n            this.unpackPremultiplyAlpha = premultiplyAlpha;\n            // Note: the WebGL spec states that UNPACK_PREMULTIPLY_ALPHA_WEBGL only affects\n            // texImage2D and texSubImage2D, not compressedTexImage2D\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);\n        }\n    }\n    uploadTexture(texture) {\n        const { gl } = this._engine;\n        let mipLevel = 0;\n        if (isBrowserInterface(texture.source)) {\n            // Upload the image, canvas or video\n            this.setUnpackFlipY(texture.flipY);\n            this.setUnpackPremultiplyAlpha(texture.premultiplyAlpha);\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, texture.glInternalFormat, texture.glFormat, texture.glPixelType, texture.source);\n            gl.generateMipmap(texture.glTarget);\n        }\n        else {\n            this.setUnpackFlipY(false);\n            this.setUnpackPremultiplyAlpha(texture.premultiplyAlpha);\n            // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texture.width, texture.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, texture.glInternalFormat, texture.width, texture.height, 0, texture.glFormat, texture.glPixelType, texture.source);\n        }\n    }\n    /**\n     * If the texture is not bound on the specified texture unit, active the texture unit and bind\n     * the texture to it.\n     *\n     * @param {Texture} texture - The texture to bind.\n     * @param {number} textureUnit - The texture unit to activate and bind the texture to.\n     * @ignore\n     */\n    bindTextureOnUnit(texture, textureUnit) {\n        const { gl } = this._engine;\n        const textureTarget = texture.glTarget;\n        const textureObject = texture.glTexture;\n        this.activeTexture(textureUnit);\n        gl.bindTexture(textureTarget, textureObject);\n    }\n}\n","import { EngineDraw } from \"./engine.draw\";\nimport { EngineProgram } from \"./engine.programs\";\nimport { EngineRenderTarget } from \"./engine.renderTarget\";\nimport { EngineState } from \"./engine.state\";\nimport { EngineTexture } from \"./engine.texture\";\nimport { EngineUniformBuffer } from \"./engine.uniformBuffer\";\nimport { EngineUniform } from \"./engine.uniforms\";\nimport { EngineVertex } from \"./engine.vertex\";\nimport { EngineViewPort } from \"./engine.viewPort\";\nexport class Engine {\n    constructor(canvas) {\n        this._contextWasLost = false;\n        this.webgl2 = true;\n        if (!canvas)\n            return;\n        this.renderingCanvas = canvas;\n        try {\n            this.gl = canvas.getContext(\"webgl2\", {\n                antialias: true,\n                alpha: true,\n            });\n        }\n        catch (err) {\n            throw new Error(\" webgl2.0\");\n        }\n        this._initializeCapabilities();\n        const gl = this.gl;\n        this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];\n        this.engineDraw = new EngineDraw(this);\n        this.engineViewPort = new EngineViewPort(this);\n        this.enginePrograms = new EngineProgram(this);\n        this.engineUniform = new EngineUniform(this);\n        this.engineVertex = new EngineVertex(this);\n        this.engineTexture = new EngineTexture(this);\n        this.engineUniformBuffer = new EngineUniformBuffer(this);\n        this.engineRenderTarget = new EngineRenderTarget(this);\n        this.engineState = new EngineState(this);\n    }\n    _initializeCapabilities() {\n        const gl = this.gl;\n        const contextAttribs = gl.getContextAttributes();\n        this.capabilities = {\n            supportsMsaa: contextAttribs === null || contextAttribs === void 0 ? void 0 : contextAttribs.antialias,\n            supportsStencil: contextAttribs.stencil,\n            maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),\n            maxCubeMapSize: gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE),\n            maxRenderBufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE),\n            maxTextures: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),\n            maxCombinedTextures: gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),\n            maxVertexTextures: gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),\n            vertexUniformsCount: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),\n            fragmentUniformsCount: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),\n            maxDrawBuffers: gl.getParameter(gl.MAX_DRAW_BUFFERS),\n            maxColorAttachments: gl.getParameter(gl.MAX_COLOR_ATTACHMENTS),\n            maxVolumeSize: gl.getParameter(gl.MAX_3D_TEXTURE_SIZE),\n            maxSamples: gl.getParameter(gl.SAMPLES),\n            supportsAreaLights: true,\n        };\n    }\n}\n","import { UniformsType } from \"./engine.enum\";\nexport class EngineUniformBuffer {\n    constructor(engine) {\n        this._engine = engine;\n    }\n    _getUniformBlockCatch(uniformBlock, name) {\n        const { gl } = this._engine;\n        if (!uniformBlock.blockCatch.has(name)) {\n            const ubb = uniformBlock.blockIndex;\n            const ubo = gl.createBuffer();\n            uniformBlock.blockCatch.set(name, {\n                ubb,\n                ubo,\n            });\n            uniformBlock.blockIndex += 1;\n        }\n        return uniformBlock.blockCatch.get(name);\n    }\n    _getBufferData(keys, content) {\n        let len = 0;\n        let offset = [0];\n        for (let i = 0; i < keys.length; i++) {\n            const propName = keys[i];\n            const { type } = content[propName];\n            if (type == UniformsType.Float) {\n                len += 4;\n            }\n            if (type == UniformsType.Vec2) {\n                len += 4;\n            }\n            if (type == UniformsType.Vec3) {\n                len += 4;\n            }\n            if (type == UniformsType.Vec4) {\n                len += 4;\n            }\n            offset.push(len);\n        }\n        const result = new Float32Array(len);\n        for (let i = 0; i < keys.length; i++) {\n            const propName = keys[i];\n            const { value, type } = content[propName];\n            if (type == UniformsType.Float) {\n                result.set([0, 0, 0, value.x], offset[i]);\n            }\n            if (type == UniformsType.Vec2) {\n                result.set([0, 0, value.x, value.y], offset[i]);\n            }\n            if (type == UniformsType.Vec3) {\n                result.set([0, value.x, value.y, value.z], offset[i]);\n            }\n            if (type == UniformsType.Vec4) {\n                result.set([value.x, value.y, value.z, value.w], offset[i]);\n            }\n        }\n        return result;\n    }\n    handleUniformBlock(program, blockName, content, uniformBlock) {\n        const { gl } = this._engine;\n        const ubi = gl.getUniformBlockIndex(program, blockName);\n        const { ubb, ubo } = this._getUniformBlockCatch(uniformBlock, blockName);\n        gl.uniformBlockBinding(program, ubi, ubb);\n        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);\n        const keys = Object.keys(content);\n        const result = this._getBufferData(keys, content);\n        gl.bufferData(gl.UNIFORM_BUFFER, result, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n        gl.bindBufferBase(gl.UNIFORM_BUFFER, ubb, ubo);\n    }\n}\n","// import { bindCubeTexture, bindTexture, activeTexture } from \"./texture.js\";\nimport { Mat3, Vec3 } from \"../maths\";\nimport { UniformsType } from \"./engine.enum\";\nexport class EngineUniform {\n    constructor(engine) {\n        this._engine = engine;\n    }\n    getUniformLocation(program, name) {\n        const { gl } = this._engine;\n        return gl.getUniformLocation(program, name);\n    }\n    setUniform(program, name, value, type) {\n        const { gl } = this._engine;\n        if (value == null) {\n            return;\n        }\n        // const subName = `${name}_${meshName}`\n        // \n        const addr = gl.getUniformLocation(program, name);\n        if (addr == null) {\n            return;\n        }\n        switch (type) {\n            case UniformsType.Float:\n                gl.uniform1f(addr, value);\n                break;\n            case UniformsType.Vec2:\n                gl.uniform2f(addr, value.x, value.y);\n                break;\n            case UniformsType.Vec3:\n                gl.uniform3f(addr, value.x, value.y, value.z);\n                break;\n            case UniformsType.Vec4:\n                gl.uniform4f(addr, value.x, value.y, value.z, value.w);\n                break;\n            case UniformsType.Mat3:\n                gl.uniformMatrix3fv(addr, false, new Float32Array(value));\n                break;\n            case UniformsType.Mat4:\n                gl.uniformMatrix4fv(addr, false, new Float32Array(value));\n                break;\n            case UniformsType.Texture:\n                this._engine.engineTexture.setTexture(value, 0);\n                gl.uniform1i(addr, 0);\n                break;\n            default:\n                console.error(\"error\", type, name);\n                break;\n        }\n    }\n    // \n    handleUniformArray(program, name, content) {\n        const array = content;\n        for (let i = 0; i < array.length; i++) {\n            let baseName = `${name}[${i}]`;\n            const item = array[i];\n            if (item.type == UniformsType.Struct) {\n                const keys = Object.keys(item.value);\n                for (let j = 0; j < keys.length; j++) {\n                    const key = keys[j];\n                    const properties = item.value[key];\n                    const { value, type } = properties;\n                    const addrName = baseName + `.${key}`;\n                    this.setUniform(program, addrName, value, type);\n                }\n            }\n            else {\n                this.setUniform(program, baseName, item.value, item.type);\n            }\n        }\n    }\n    setSystemUniform(program, camera) {\n        let _vector3 = new Vec3();\n        _vector3 = _vector3.setFromMatrixPosition(camera.matrixWorld);\n        this._engine.engineUniform.setUniform(program, \"vEyePosition\", _vector3, UniformsType.Vec3);\n        this._engine.engineUniform.setUniform(program, \"viewMatrix\", camera.matrixWorldInverse.data, UniformsType.Mat4);\n        let _tempMat3 = new Mat3();\n        _tempMat3.setFromMatrix4(camera.matrixWorldInverse).invert();\n        this._engine.engineUniform.setUniform(program, \"inverseViewTransform\", _tempMat3.data, UniformsType.Mat3);\n    }\n    handleUniform(program, obj, uniformBlock) {\n        // const { program } = this;\n        let textureId = 0;\n        const keys = Object.keys(obj);\n        for (let i = 0; i < keys.length; i++) {\n            const name = keys[i];\n            const { value, type } = obj[name];\n            if (type == UniformsType.Array) {\n                this._engine.engineUniform.handleUniformArray(program, name, value);\n            }\n            else if (type == UniformsType.Struct) {\n                this._engine.engineUniformBuffer.handleUniformBlock(program, name, value, uniformBlock);\n            }\n            else {\n                this._engine.engineUniform.setUniform(program, name, value, type);\n            }\n            if (type == UniformsType.Texture) {\n                textureId += 1;\n            }\n        }\n    }\n}\n","export class EngineVertex {\n    constructor(engine) {\n        this._engine = engine;\n    }\n    _unbindVertexArrayObject() {\n        const { gl } = this._engine;\n        if (!this._cachedVertexArrayObject) {\n            return;\n        }\n        this._cachedVertexArrayObject = null;\n        gl.bindVertexArray(null);\n    }\n    createVertexArray() {\n        const { gl } = this._engine;\n        return gl.createVertexArray();\n    }\n    bindVertexArray(vao) {\n        const { gl } = this._engine;\n        gl.bindVertexArray(vao);\n    }\n    deleteVertexArray(vao) {\n        const { gl } = this._engine;\n        gl.deleteVertexArray(vao);\n    }\n    createBuffer() {\n        const { gl } = this._engine;\n        return gl.createBuffer();\n    }\n    setIndicesBuffer(indicesBuffer, indices) {\n        const { gl } = this._engine;\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);\n        const arrayBuffer = ArrayBuffer.isView(indicesBuffer) ? indicesBuffer : new Uint16Array(indices);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);\n    }\n    setAttribBuffer(program, buffer, param) {\n        const { gl } = this._engine;\n        const { attribureName, attriburData, itemSize } = param;\n        // \n        const attribure = gl.getAttribLocation(program, attribureName);\n        if (attribure == -1) {\n            // error.catchError({\n            //     info: `\"error\"`,\n            //     moduleName: moduleName,\n            //     subName: attribureName,\n            // });\n            // console.error(\"error...\");\n            return;\n        }\n        // \n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        const arrayBuffer = ArrayBuffer.isView(attriburData) ? attriburData : new Float32Array(attriburData);\n        // \n        gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);\n        const type = gl.FLOAT;\n        const normalize = false;\n        const stride = 0;\n        const offset = 0;\n        // ,GPU\n        gl.vertexAttribPointer(attribure, itemSize, type, normalize, stride, offset);\n        // error.clear(moduleName, attribureName);\n        gl.enableVertexAttribArray(attribure);\n    }\n    getAttribLocation(program, name) {\n        const { gl } = this._engine;\n        return gl.getAttribLocation(program, name);\n    }\n    disableVertexAttribArray(attribure) {\n        const { gl } = this._engine;\n        gl.disableVertexAttribArray(attribure);\n    }\n    setBuffers() {\n    }\n}\n","export class EngineViewPort {\n    constructor(engine) {\n        this.viewportCached = { x: 0, y: 0, width: 0, height: 0 };\n        this._engine = engine;\n    }\n    /**\n     * Set the WebGL's viewport\n     * @param viewport defines the viewport element to be used\n     * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\n     * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\n     */\n    setViewport(viewport, requiredWidth, requiredHeight) {\n        // var width = requiredWidth || this._engine.engineDraw.getRenderWidth();\n        // var height = requiredHeight || this._engine.engineDraw.getRenderHeight();\n        // var x = viewport.x || 0;\n        // var y = viewport.y || 0;\n        // this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);\n        this._engine.gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);\n    }\n    _viewport(x, y, width, height) {\n        if (x !== this.viewportCached.x || y !== this.viewportCached.y || width !== this.viewportCached.width || height !== this.viewportCached.height) {\n            this.viewportCached.x = x;\n            this.viewportCached.y = y;\n            this.viewportCached.width = width;\n            this.viewportCached.height = height;\n            this._engine.gl.viewport(x, y, width, height);\n        }\n    }\n}\n","export * from \"./engine\";\nexport * from \"./engine.enum\";\n","import { Vec3 } from \"../maths/math.vec3\";\nconst primitiveUv1Padding = 4.0 / 64;\nconst primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\nexport function boxBuilder(opts) {\n    // Check the supplied options and provide defaults for unspecified ones\n    const he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec3(0.5, 0.5, 0.5);\n    const ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;\n    const ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;\n    const hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;\n    const corners = [\n        new Vec3(-he.x, -he.y, he.z),\n        new Vec3(he.x, -he.y, he.z),\n        new Vec3(he.x, he.y, he.z),\n        new Vec3(-he.x, he.y, he.z),\n        new Vec3(he.x, -he.y, -he.z),\n        new Vec3(-he.x, -he.y, -he.z),\n        new Vec3(-he.x, he.y, -he.z),\n        new Vec3(he.x, he.y, -he.z),\n    ];\n    const faceAxes = [\n        [0, 1, 3],\n        [4, 5, 7],\n        [3, 2, 6],\n        [1, 0, 4],\n        [1, 4, 2],\n        [5, 0, 6], // LEFT\n    ];\n    const faceNormals = [\n        [0, 0, 1],\n        [0, 0, -1],\n        [0, 1, 0],\n        [0, -1, 0],\n        [1, 0, 0],\n        [-1, 0, 0], // LEFT\n    ];\n    let Sides;\n    (function (Sides) {\n        Sides[Sides[\"FRONT\"] = 0] = \"FRONT\";\n        Sides[Sides[\"BACK\"] = 1] = \"BACK\";\n        Sides[Sides[\"TOP\"] = 2] = \"TOP\";\n        Sides[Sides[\"BOTTOM\"] = 3] = \"BOTTOM\";\n        Sides[Sides[\"RIGHT\"] = 4] = \"RIGHT\";\n        Sides[Sides[\"LEFT\"] = 5] = \"LEFT\";\n    })(Sides || (Sides = {}));\n    const positions = new Array();\n    const normals = new Array();\n    const uvs = new Array();\n    const uvs1 = new Array();\n    const indices = new Array();\n    let vcounter = 0;\n    const generateFace = (side, uSegments, vSegments) => {\n        const temp1 = new Vec3();\n        const temp2 = new Vec3();\n        const temp3 = new Vec3();\n        const r = new Vec3();\n        for (let i = 0; i <= uSegments; i++) {\n            for (let j = 0; j <= vSegments; j++) {\n                temp1.lerp2(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);\n                temp2.lerp2(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);\n                temp3.sub2(temp2, corners[faceAxes[side][0]]);\n                r.add2(temp1, temp3);\n                let u = i / uSegments;\n                let v = j / vSegments;\n                positions.push(r.x, r.y, r.z);\n                normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);\n                uvs.push(u, 1 - v);\n                // pack as 3x2. 1/3 will be empty, but it's either that or stretched pixels\n                // TODO: generate non-rectangular lightMaps, so we could use space without stretching\n                u = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n                v = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n                u /= 3;\n                v /= 3;\n                u += (side % 3) / 3;\n                v += Math.floor(side / 3) / 3;\n                uvs1.push(u, 1 - v);\n                if (i < uSegments && j < vSegments) {\n                    indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);\n                    indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);\n                }\n                vcounter++;\n            }\n        }\n    };\n    generateFace(Sides.FRONT, ws, hs);\n    generateFace(Sides.BACK, ws, hs);\n    generateFace(Sides.TOP, ws, ls);\n    generateFace(Sides.BOTTOM, ws, ls);\n    generateFace(Sides.RIGHT, ls, hs);\n    generateFace(Sides.LEFT, ls, hs);\n    return {\n        positions: positions,\n        normals: normals,\n        uvs: uvs,\n        // uvs1: uvs1,\n        indices: indices,\n    };\n}\nexport function sphereBuilder(opts) {\n    // Check the supplied options and provide defaults for unspecified ones\n    const radius = opts && opts.radius !== undefined ? opts.radius : 0.5;\n    const latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;\n    const longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;\n    const calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n    // Variable declarations\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n    for (let lat = 0; lat <= latitudeBands; lat++) {\n        const theta = (lat * Math.PI) / latitudeBands;\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n        for (let lon = 0; lon <= longitudeBands; lon++) {\n            // Sweep the sphere from the positive Z axis to match a 3DS Max sphere\n            const phi = (lon * 2 * Math.PI) / longitudeBands - Math.PI / 2;\n            const sinPhi = Math.sin(phi);\n            const cosPhi = Math.cos(phi);\n            const x = cosPhi * sinTheta;\n            const y = cosTheta;\n            const z = sinPhi * sinTheta;\n            const u = 1 - lon / longitudeBands;\n            const v = 1 - lat / latitudeBands;\n            positions.push(x * radius, y * radius, z * radius);\n            normals.push(x, y, z);\n            uvs.push(u, 1 - v);\n        }\n    }\n    for (let lat = 0; lat < latitudeBands; ++lat) {\n        for (let lon = 0; lon < longitudeBands; ++lon) {\n            const first = lat * (longitudeBands + 1) + lon;\n            const second = first + longitudeBands + 1;\n            indices.push(first + 1, second, first);\n            indices.push(first + 1, second + 1, second);\n        }\n    }\n    return {\n        positions: positions,\n        normals: normals,\n        uvs: uvs,\n        // uvs1: uvs, // UV1 = UV0 for sphere\n        indices: indices,\n    };\n    // return createMesh(device, positions, options);\n}\n/**\n * Z\n * @param width\n * @param height\n * @returns\n */\nexport function planeBuilder(width, height) {\n    if (width == undefined) {\n        width = 1;\n    }\n    if (height == undefined) {\n        height = 1;\n    }\n    const vert = [-width, height, 0, -width, -height, 0, width, -height, 0, width, height, 0];\n    const indices = [0, 1, 2, 2, 3, 0];\n    const normal = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];\n    return {\n        positions: vert,\n        normals: normal,\n        uvs: [0, 1, 0, 0, 1, 0, 1, 1],\n        indices: indices,\n    };\n}\n","// import { Sphere } from '../math/Sphere.js';\n// import { Box3 } from '../math/Box3.js';\n// import { Vector3 } from '../math/Vector3.js';\n// import Attribute from './Attribute.js'\nimport { PrimitiveType } from \"../engines/engine.draw\";\nimport { Logger } from \"../misc/logger\";\nexport class Geometry {\n    constructor(engine, geometryInfo) {\n        this._attributeBuffer = new Map();\n        this._engine = engine;\n        this._geometryInfo = geometryInfo;\n        if (!this._geometryInfo.attributes) {\n            Logger.Warn(\"geometry no attributes\");\n        }\n        if (!this._geometryInfo.type) {\n            this._geometryInfo.type = PrimitiveType.PRIMITIVE_TRIANGLES;\n        }\n        // \n        if (this._geometryInfo.indices) {\n            this._geometryInfo.count = this._geometryInfo.indices.length;\n        }\n        this._createVertexArray();\n    }\n    get geometryInfo() {\n        return this._geometryInfo;\n    }\n    /**\n     * VAO\n     */\n    _createVertexArray() {\n        this._VAO = this._engine.engineVertex.createVertexArray();\n        this._engine.engineVertex.bindVertexArray(this._VAO);\n        for (let name in this._geometryInfo.attributes) {\n            this._attributeBuffer.set(name, this._engine.engineVertex.createBuffer());\n        }\n        // \n        this._indicesBuffer = this._engine.engineVertex.createBuffer();\n        this._engine.engineVertex.bindVertexArray(null);\n    }\n    setBuffers(program) {\n        // VAO\n        this._engine.engineVertex.bindVertexArray(this._VAO);\n        const { _attributeBuffer, _indicesBuffer } = this;\n        for (let name in this._geometryInfo.attributes) {\n            const attribute = this._geometryInfo.attributes[name];\n            const { value, itemSize } = attribute;\n            this._engine.engineVertex.setAttribBuffer(program, _attributeBuffer.get(name), {\n                attribureName: name,\n                attriburData: value,\n                itemSize: itemSize,\n            });\n        }\n        // \n        if (this._geometryInfo.indices) {\n            this._engine.engineVertex.setIndicesBuffer(_indicesBuffer, this._geometryInfo.indices);\n        }\n    }\n    disableVertexAttrib(program) {\n        for (let name in this._geometryInfo.attributes) {\n            const attribure = this._engine.engineVertex.getAttribLocation(program, name);\n            attribure != -1 && this._engine.engineVertex.disableVertexAttribArray(attribure);\n        }\n    }\n}\n","export * from \"./builder\";\nexport * from \"./geometry\";\n","export * from \"./engines/index\";\nexport * from \"./cameras/index\";\nexport * from \"./geometry/index\";\nexport * from \"./material/index\";\nexport * from \"./mesh/index\";\nexport * from \"./scene/index\";\nexport * from \"./loader/index\";\nexport * from \"./texture/index\";\nexport * from \"./renderer/index\";\nexport * from \"./postprocessing/index\";\nexport * from \"./maths/index\";\nexport * from \"./misc/fileTools\";\nexport * from \"./application\";\n","// window;\nimport * as lmgl from \"./index\";\nwindow.lmgl = lmgl;\n","export * from \"./texture.loader\";\nexport * from \"./shader.loader\";\n","export class Loader {\n    constructor(engine) {\n        this.engine = engine;\n        this.rootPath = \"\";\n    }\n    setPath(path) {\n        this.rootPath = path;\n        return this;\n    }\n}\n","import { FileTools } from \"../misc/fileTools\";\nimport { Loader } from \"./loader\";\nexport class ShaderLoader extends Loader {\n    constructor(engine) {\n        super(engine);\n    }\n    load(options) {\n        return new Promise((resolve, reject) => {\n            let filesToLoad = [];\n            filesToLoad = filesToLoad.concat(options.vsPaths);\n            filesToLoad = filesToLoad.concat(options.fsPaths);\n            FileTools.LoadTextFiles(filesToLoad, this.rootPath).then((files) => {\n                var vertexShaderSources = [];\n                for (var i = 0; i < options.vsPaths.length; ++i) {\n                    vertexShaderSources.push(files[this.rootPath + options.vsPaths[i]]);\n                }\n                var fragmentShaderSources = [];\n                for (var i = 0; i < options.fsPaths.length; ++i) {\n                    fragmentShaderSources.push(files[this.rootPath + options.fsPaths[i]]);\n                }\n                resolve({\n                    vertexShader: vertexShaderSources.join(\"\\n\"),\n                    fragmentShader: fragmentShaderSources.join(\"\\n\"),\n                });\n            });\n        });\n    }\n}\n","import { __awaiter } from \"tslib\";\nimport { FileTools } from \"../misc/fileTools\";\nimport { Texture } from \"../texture\";\nimport { Loader } from \"./loader\";\nexport class TextureLoader extends Loader {\n    constructor(engine) {\n        super(engine);\n    }\n    load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const image = yield FileTools.LoadImage(url, this.rootPath);\n                const texture = new Texture(this.engine);\n                texture.source = image;\n                return resolve(texture);\n            }));\n        });\n    }\n}\n","export * from \"./material\";\n","import { UniformsType } from \"../engines/engine.enum\";\nimport { cloneUniforms } from \"../misc/tool\";\nexport class Material {\n    constructor(engine, materialInfo) {\n        this._engine = engine;\n        // let mat = matInfo;\n        this.inputVertexShader = JSON.parse(JSON.stringify(materialInfo.vertexShader));\n        this.inputFragmentShader = JSON.parse(JSON.stringify(materialInfo.fragmentShader));\n        this.uniforms = cloneUniforms(materialInfo.uniforms || {});\n        this.uniformBlock = {\n            blockCatch: new Map(),\n            blockIndex: 0,\n        };\n        this.vertexShader = this.inputVertexShader;\n        this.fragmentShader = this.inputFragmentShader;\n        const programInfo = engine.enginePrograms.createProgram({\n            vertexShader: this.vertexShader,\n            fragmentShader: this.fragmentShader,\n        });\n        this.program = programInfo.program;\n        this.vertexShader = programInfo.vertexShader;\n        this.fragmentShader = programInfo.fragmentShader;\n        // this.blending = false;\n        // this.blendingType = BLENDING_TYPE.RGBA;\n        // this.blendRGBASrc = BLENDING_FACTOR.ONE;\n        // this.blendRGBADst = BLENDING_FACTOR.ONE;\n        // this.blendRGB_ASrc = BLENDING_FACTOR.SRC_ALPHA;\n        // this.blendRGB_ADst = BLENDING_FACTOR.ONE_MINUS_SRC_ALPHA;\n        // this.depthTest = true;\n        // this.side = SIDE.FrontSide;\n        // uniform\n        this.needUpdate = true;\n        this.setUniform();\n    }\n    _handleUniform(obj) {\n        const { program } = this;\n        let textureId = 0;\n        const keys = Object.keys(obj);\n        for (let i = 0; i < keys.length; i++) {\n            const name = keys[i];\n            const { value, type } = obj[name];\n            if (type == UniformsType.Array) {\n                this._engine.engineUniform.handleUniformArray(program, name, value);\n            }\n            else if (type == UniformsType.Struct) {\n                this._engine.engineUniformBuffer.handleUniformBlock(program, name, value, this.uniformBlock);\n            }\n            else {\n                this._engine.engineUniform.setUniform(program, name, value, type);\n            }\n            if (type == UniformsType.Texture) {\n                textureId += 1;\n            }\n        }\n    }\n    setUniform() {\n        const { program, uniforms, uniformBlock } = this;\n        this._engine.enginePrograms.useProgram(program);\n        this._engine.engineUniform.handleUniform(program, uniforms, uniformBlock);\n    }\n    clone() {\n        return new Material(this._engine, {\n            vertexShader: this.inputVertexShader,\n            fragmentShader: this.inputFragmentShader,\n            uniforms: this.uniforms,\n        });\n    }\n}\n","export * from \"./math.vec2\";\nexport * from \"./math.vec3\";\nexport * from \"./math.mat3\";\nexport * from \"./math.mat4\";\nexport * from \"./math.euler\";\nexport * from \"./math.quat\";\nexport * from \"./math.tool\";\n","import { Scalar } from './math.scalar';\nimport { ToLinearSpace, ToGammaSpace } from './math.constants';\nimport { ArrayTools } from '../misc/arrayTools';\nimport { _TypeStore } from '../misc/typeStore';\n/**\n * Class used to hold a RBG color\n */\nexport class Color3 {\n    /**\n     * Creates a new Color3 object from red, green, blue values, all between 0 and 1\n     * @param r defines the red component (between 0 and 1, default is 0)\n     * @param g defines the green component (between 0 and 1, default is 0)\n     * @param b defines the blue component (between 0 and 1, default is 0)\n     */\n    constructor(\n    /**\n     * Defines the red component (between 0 and 1, default is 0)\n     */\n    r = 0, \n    /**\n     * Defines the green component (between 0 and 1, default is 0)\n     */\n    g = 0, \n    /**\n     * Defines the blue component (between 0 and 1, default is 0)\n     */\n    b = 0) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n    /**\n     * Creates a string with the Color3 current values\n     * @returns the string representation of the Color3 object\n     */\n    toString() {\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\n    }\n    /**\n     * Returns the string \"Color3\"\n     * @returns \"Color3\"\n     */\n    getClassName() {\n        return \"Color3\";\n    }\n    /**\n     * Compute the Color3 hash code\n     * @returns an unique number that can be used to hash Color3 objects\n     */\n    getHashCode() {\n        let hash = (this.r * 255) | 0;\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\n        return hash;\n    }\n    // Operators\n    /**\n     * Stores in the given array from the given starting index the red, green, blue values as successive elements\n     * @param array defines the array where to store the r,g,b components\n     * @param index defines an optional index in the target array to define where to start storing values\n     * @returns the current Color3 object\n     */\n    toArray(array, index = 0) {\n        array[index] = this.r;\n        array[index + 1] = this.g;\n        array[index + 2] = this.b;\n        return this;\n    }\n    /**\n     * Update the current color with values stored in an array from the starting index of the given array\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns the current Color3 object\n     */\n    fromArray(array, offset = 0) {\n        Color3.FromArrayToRef(array, offset, this);\n        return this;\n    }\n    /**\n     * Returns a new Color4 object from the current Color3 and the given alpha\n     * @param alpha defines the alpha component on the new Color4 object (default is 1)\n     * @returns a new Color4 object\n     */\n    toColor4(alpha = 1) {\n        return new Color4(this.r, this.g, this.b, alpha);\n    }\n    /**\n     * Returns a new array populated with 3 numeric elements : red, green and blue values\n     * @returns the new array\n     */\n    asArray() {\n        var result = new Array();\n        this.toArray(result, 0);\n        return result;\n    }\n    /**\n     * Returns the luminance value\n     * @returns a float value\n     */\n    toLuminance() {\n        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n    }\n    /**\n     * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\n     * @param otherColor defines the second operand\n     * @returns the new Color3 object\n     */\n    multiply(otherColor) {\n        return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n    }\n    /**\n     * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\n     * @param otherColor defines the second operand\n     * @param result defines the Color3 object where to store the result\n     * @returns the current Color3\n     */\n    multiplyToRef(otherColor, result) {\n        result.r = this.r * otherColor.r;\n        result.g = this.g * otherColor.g;\n        result.b = this.b * otherColor.b;\n        return this;\n    }\n    /**\n     * Determines equality between Color3 objects\n     * @param otherColor defines the second operand\n     * @returns true if the rgb values are equal to the given ones\n     */\n    equals(otherColor) {\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\n    }\n    /**\n     * Determines equality between the current Color3 object and a set of r,b,g values\n     * @param r defines the red component to check\n     * @param g defines the green component to check\n     * @param b defines the blue component to check\n     * @returns true if the rgb values are equal to the given ones\n     */\n    equalsFloats(r, g, b) {\n        return this.r === r && this.g === g && this.b === b;\n    }\n    /**\n     * Multiplies in place each rgb value by scale\n     * @param scale defines the scaling factor\n     * @returns the updated Color3\n     */\n    scale(scale) {\n        return new Color3(this.r * scale, this.g * scale, this.b * scale);\n    }\n    /**\n     * Multiplies the rgb values by scale and stores the result into \"result\"\n     * @param scale defines the scaling factor\n     * @param result defines the Color3 object where to store the result\n     * @returns the unmodified current Color3\n     */\n    scaleToRef(scale, result) {\n        result.r = this.r * scale;\n        result.g = this.g * scale;\n        result.b = this.b * scale;\n        return this;\n    }\n    /**\n     * Scale the current Color3 values by a factor and add the result to a given Color3\n     * @param scale defines the scale factor\n     * @param result defines color to store the result into\n     * @returns the unmodified current Color3\n     */\n    scaleAndAddToRef(scale, result) {\n        result.r += this.r * scale;\n        result.g += this.g * scale;\n        result.b += this.b * scale;\n        return this;\n    }\n    /**\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\n     * @param min defines minimum clamping value (default is 0)\n     * @param max defines maximum clamping value (default is 1)\n     * @param result defines color to store the result into\n     * @returns the original Color3\n     */\n    clampToRef(min = 0, max = 1, result) {\n        result.r = Scalar.Clamp(this.r, min, max);\n        result.g = Scalar.Clamp(this.g, min, max);\n        result.b = Scalar.Clamp(this.b, min, max);\n        return this;\n    }\n    /**\n     * Creates a new Color3 set with the added values of the current Color3 and of the given one\n     * @param otherColor defines the second operand\n     * @returns the new Color3\n     */\n    add(otherColor) {\n        return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n    }\n    /**\n     * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\n     * @param otherColor defines the second operand\n     * @param result defines Color3 object to store the result into\n     * @returns the unmodified current Color3\n     */\n    addToRef(otherColor, result) {\n        result.r = this.r + otherColor.r;\n        result.g = this.g + otherColor.g;\n        result.b = this.b + otherColor.b;\n        return this;\n    }\n    /**\n     * Returns a new Color3 set with the subtracted values of the given one from the current Color3\n     * @param otherColor defines the second operand\n     * @returns the new Color3\n     */\n    subtract(otherColor) {\n        return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n    }\n    /**\n     * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\n     * @param otherColor defines the second operand\n     * @param result defines Color3 object to store the result into\n     * @returns the unmodified current Color3\n     */\n    subtractToRef(otherColor, result) {\n        result.r = this.r - otherColor.r;\n        result.g = this.g - otherColor.g;\n        result.b = this.b - otherColor.b;\n        return this;\n    }\n    /**\n     * Copy the current object\n     * @returns a new Color3 copied the current one\n     */\n    clone() {\n        return new Color3(this.r, this.g, this.b);\n    }\n    /**\n     * Copies the rgb values from the source in the current Color3\n     * @param source defines the source Color3 object\n     * @returns the updated Color3 object\n     */\n    copyFrom(source) {\n        this.r = source.r;\n        this.g = source.g;\n        this.b = source.b;\n        return this;\n    }\n    /**\n     * Updates the Color3 rgb values from the given floats\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @returns the current Color3 object\n     */\n    copyFromFloats(r, g, b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        return this;\n    }\n    /**\n     * Updates the Color3 rgb values from the given floats\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @returns the current Color3 object\n     */\n    set(r, g, b) {\n        return this.copyFromFloats(r, g, b);\n    }\n    /**\n     * Compute the Color3 hexadecimal code as a string\n     * @returns a string containing the hexadecimal representation of the Color3 object\n     */\n    toHexString() {\n        var intR = (this.r * 255) | 0;\n        var intG = (this.g * 255) | 0;\n        var intB = (this.b * 255) | 0;\n        return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n    }\n    /**\n     * Computes a new Color3 converted from the current one to linear space\n     * @returns a new Color3 object\n     */\n    toLinearSpace() {\n        var convertedColor = new Color3();\n        this.toLinearSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts current color in rgb space to HSV values\n     * @returns a new color3 representing the HSV values\n     */\n    toHSV() {\n        let result = new Color3();\n        this.toHSVToRef(result);\n        return result;\n    }\n    /**\n     * Converts current color in rgb space to HSV values\n     * @param result defines the Color3 where to store the HSV values\n     */\n    toHSVToRef(result) {\n        var r = this.r;\n        var g = this.g;\n        var b = this.b;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h = 0;\n        var s = 0;\n        var v = max;\n        var dm = max - min;\n        if (max !== 0) {\n            s = dm / max;\n        }\n        if (max != min) {\n            if (max == r) {\n                h = (g - b) / dm;\n                if (g < b) {\n                    h += 6;\n                }\n            }\n            else if (max == g) {\n                h = (b - r) / dm + 2;\n            }\n            else if (max == b) {\n                h = (r - g) / dm + 4;\n            }\n            h *= 60;\n        }\n        result.r = h;\n        result.g = s;\n        result.b = v;\n    }\n    /**\n     * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color3 object where to store the linear space version\n     * @returns the unmodified Color3\n     */\n    toLinearSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToLinearSpace);\n        convertedColor.g = Math.pow(this.g, ToLinearSpace);\n        convertedColor.b = Math.pow(this.b, ToLinearSpace);\n        return this;\n    }\n    /**\n     * Computes a new Color3 converted from the current one to gamma space\n     * @returns a new Color3 object\n     */\n    toGammaSpace() {\n        var convertedColor = new Color3();\n        this.toGammaSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color3 object where to store the gamma space version\n     * @returns the unmodified Color3\n     */\n    toGammaSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToGammaSpace);\n        convertedColor.g = Math.pow(this.g, ToGammaSpace);\n        convertedColor.b = Math.pow(this.b, ToGammaSpace);\n        return this;\n    }\n    /**\n     * Convert Hue, saturation and value to a Color3 (RGB)\n     * @param hue defines the hue\n     * @param saturation defines the saturation\n     * @param value defines the value\n     * @param result defines the Color3 where to store the RGB values\n     */\n    static HSVtoRGBToRef(hue, saturation, value, result) {\n        var chroma = value * saturation;\n        var h = hue / 60;\n        var x = chroma * (1 - Math.abs((h % 2) - 1));\n        var r = 0;\n        var g = 0;\n        var b = 0;\n        if (h >= 0 && h <= 1) {\n            r = chroma;\n            g = x;\n        }\n        else if (h >= 1 && h <= 2) {\n            r = x;\n            g = chroma;\n        }\n        else if (h >= 2 && h <= 3) {\n            g = chroma;\n            b = x;\n        }\n        else if (h >= 3 && h <= 4) {\n            g = x;\n            b = chroma;\n        }\n        else if (h >= 4 && h <= 5) {\n            r = x;\n            b = chroma;\n        }\n        else if (h >= 5 && h <= 6) {\n            r = chroma;\n            b = x;\n        }\n        var m = value - chroma;\n        result.set((r + m), (g + m), (b + m));\n    }\n    /**\n     * Creates a new Color3 from the string containing valid hexadecimal values\n     * @param hex defines a string containing valid hexadecimal values\n     * @returns a new Color3 object\n     */\n    static FromHexString(hex) {\n        if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\n            return new Color3(0, 0, 0);\n        }\n        var r = parseInt(hex.substring(1, 3), 16);\n        var g = parseInt(hex.substring(3, 5), 16);\n        var b = parseInt(hex.substring(5, 7), 16);\n        return Color3.FromInts(r, g, b);\n    }\n    /**\n     * Creates a new Color3 from the starting index of the given array\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns a new Color3 object\n     */\n    static FromArray(array, offset = 0) {\n        return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n    }\n    /**\n     * Creates a new Color3 from the starting index element of the given array\n     * @param array defines the source array to read from\n     * @param offset defines the offset in the source array\n     * @param result defines the target Color3 object\n     */\n    static FromArrayToRef(array, offset = 0, result) {\n        result.r = array[offset];\n        result.g = array[offset + 1];\n        result.b = array[offset + 2];\n    }\n    /**\n     * Creates a new Color3 from integer values (< 256)\n     * @param r defines the red component to read from (value between 0 and 255)\n     * @param g defines the green component to read from (value between 0 and 255)\n     * @param b defines the blue component to read from (value between 0 and 255)\n     * @returns a new Color3 object\n     */\n    static FromInts(r, g, b) {\n        return new Color3(r / 255.0, g / 255.0, b / 255.0);\n    }\n    /**\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n     * @param start defines the start Color3 value\n     * @param end defines the end Color3 value\n     * @param amount defines the gradient value between start and end\n     * @returns a new Color3 object\n     */\n    static Lerp(start, end, amount) {\n        var result = new Color3(0.0, 0.0, 0.0);\n        Color3.LerpToRef(start, end, amount, result);\n        return result;\n    }\n    /**\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n     * @param left defines the start value\n     * @param right defines the end value\n     * @param amount defines the gradient factor\n     * @param result defines the Color3 object where to store the result\n     */\n    static LerpToRef(left, right, amount, result) {\n        result.r = left.r + ((right.r - left.r) * amount);\n        result.g = left.g + ((right.g - left.g) * amount);\n        result.b = left.b + ((right.b - left.b) * amount);\n    }\n    /**\n     * Returns a Color3 value containing a red color\n     * @returns a new Color3 object\n     */\n    static Red() { return new Color3(1, 0, 0); }\n    /**\n     * Returns a Color3 value containing a green color\n     * @returns a new Color3 object\n     */\n    static Green() { return new Color3(0, 1, 0); }\n    /**\n     * Returns a Color3 value containing a blue color\n     * @returns a new Color3 object\n     */\n    static Blue() { return new Color3(0, 0, 1); }\n    /**\n     * Returns a Color3 value containing a black color\n     * @returns a new Color3 object\n     */\n    static Black() { return new Color3(0, 0, 0); }\n    /**\n      * Gets a Color3 value containing a black color that must not be updated\n      */\n    static get BlackReadOnly() {\n        return Color3._BlackReadOnly;\n    }\n    /**\n     * Returns a Color3 value containing a white color\n     * @returns a new Color3 object\n     */\n    static White() { return new Color3(1, 1, 1); }\n    /**\n     * Returns a Color3 value containing a purple color\n     * @returns a new Color3 object\n     */\n    static Purple() { return new Color3(0.5, 0, 0.5); }\n    /**\n     * Returns a Color3 value containing a magenta color\n     * @returns a new Color3 object\n     */\n    static Magenta() { return new Color3(1, 0, 1); }\n    /**\n     * Returns a Color3 value containing a yellow color\n     * @returns a new Color3 object\n     */\n    static Yellow() { return new Color3(1, 1, 0); }\n    /**\n     * Returns a Color3 value containing a gray color\n     * @returns a new Color3 object\n     */\n    static Gray() { return new Color3(0.5, 0.5, 0.5); }\n    /**\n     * Returns a Color3 value containing a teal color\n     * @returns a new Color3 object\n     */\n    static Teal() { return new Color3(0, 1.0, 1.0); }\n    /**\n     * Returns a Color3 value containing a random color\n     * @returns a new Color3 object\n     */\n    static Random() { return new Color3(Math.random(), Math.random(), Math.random()); }\n}\n// Statics\nColor3._BlackReadOnly = Color3.Black();\n/**\n * Class used to hold a RBGA color\n */\nexport class Color4 {\n    /**\n     * Creates a new Color4 object from red, green, blue values, all between 0 and 1\n     * @param r defines the red component (between 0 and 1, default is 0)\n     * @param g defines the green component (between 0 and 1, default is 0)\n     * @param b defines the blue component (between 0 and 1, default is 0)\n     * @param a defines the alpha component (between 0 and 1, default is 1)\n     */\n    constructor(\n    /**\n     * Defines the red component (between 0 and 1, default is 0)\n     */\n    r = 0, \n    /**\n     * Defines the green component (between 0 and 1, default is 0)\n     */\n    g = 0, \n    /**\n     * Defines the blue component (between 0 and 1, default is 0)\n     */\n    b = 0, \n    /**\n     * Defines the alpha component (between 0 and 1, default is 1)\n     */\n    a = 1) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n    // Operators\n    /**\n     * Adds in place the given Color4 values to the current Color4 object\n     * @param right defines the second operand\n     * @returns the current updated Color4 object\n     */\n    addInPlace(right) {\n        this.r += right.r;\n        this.g += right.g;\n        this.b += right.b;\n        this.a += right.a;\n        return this;\n    }\n    /**\n     * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\n     * @returns the new array\n     */\n    asArray() {\n        var result = new Array();\n        this.toArray(result, 0);\n        return result;\n    }\n    /**\n     * Stores from the starting index in the given array the Color4 successive values\n     * @param array defines the array where to store the r,g,b components\n     * @param index defines an optional index in the target array to define where to start storing values\n     * @returns the current Color4 object\n     */\n    toArray(array, index = 0) {\n        array[index] = this.r;\n        array[index + 1] = this.g;\n        array[index + 2] = this.b;\n        array[index + 3] = this.a;\n        return this;\n    }\n    /**\n     * Update the current color with values stored in an array from the starting index of the given array\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns the current Color4 object\n     */\n    fromArray(array, offset = 0) {\n        Color4.FromArrayToRef(array, offset, this);\n        return this;\n    }\n    /**\n     * Determines equality between Color4 objects\n     * @param otherColor defines the second operand\n     * @returns true if the rgba values are equal to the given ones\n     */\n    equals(otherColor) {\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\n    }\n    /**\n     * Creates a new Color4 set with the added values of the current Color4 and of the given one\n     * @param right defines the second operand\n     * @returns a new Color4 object\n     */\n    add(right) {\n        return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\n    }\n    /**\n     * Creates a new Color4 set with the subtracted values of the given one from the current Color4\n     * @param right defines the second operand\n     * @returns a new Color4 object\n     */\n    subtract(right) {\n        return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\n    }\n    /**\n     * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\n     * @param right defines the second operand\n     * @param result defines the Color4 object where to store the result\n     * @returns the current Color4 object\n     */\n    subtractToRef(right, result) {\n        result.r = this.r - right.r;\n        result.g = this.g - right.g;\n        result.b = this.b - right.b;\n        result.a = this.a - right.a;\n        return this;\n    }\n    /**\n     * Creates a new Color4 with the current Color4 values multiplied by scale\n     * @param scale defines the scaling factor to apply\n     * @returns a new Color4 object\n     */\n    scale(scale) {\n        return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n    }\n    /**\n     * Multiplies the current Color4 values by scale and stores the result in \"result\"\n     * @param scale defines the scaling factor to apply\n     * @param result defines the Color4 object where to store the result\n     * @returns the current unmodified Color4\n     */\n    scaleToRef(scale, result) {\n        result.r = this.r * scale;\n        result.g = this.g * scale;\n        result.b = this.b * scale;\n        result.a = this.a * scale;\n        return this;\n    }\n    /**\n     * Scale the current Color4 values by a factor and add the result to a given Color4\n     * @param scale defines the scale factor\n     * @param result defines the Color4 object where to store the result\n     * @returns the unmodified current Color4\n     */\n    scaleAndAddToRef(scale, result) {\n        result.r += this.r * scale;\n        result.g += this.g * scale;\n        result.b += this.b * scale;\n        result.a += this.a * scale;\n        return this;\n    }\n    /**\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\n     * @param min defines minimum clamping value (default is 0)\n     * @param max defines maximum clamping value (default is 1)\n     * @param result defines color to store the result into.\n     * @returns the cuurent Color4\n     */\n    clampToRef(min = 0, max = 1, result) {\n        result.r = Scalar.Clamp(this.r, min, max);\n        result.g = Scalar.Clamp(this.g, min, max);\n        result.b = Scalar.Clamp(this.b, min, max);\n        result.a = Scalar.Clamp(this.a, min, max);\n        return this;\n    }\n    /**\n      * Multipy an Color4 value by another and return a new Color4 object\n      * @param color defines the Color4 value to multiply by\n      * @returns a new Color4 object\n      */\n    multiply(color) {\n        return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\n    }\n    /**\n     * Multipy a Color4 value by another and push the result in a reference value\n     * @param color defines the Color4 value to multiply by\n     * @param result defines the Color4 to fill the result in\n     * @returns the result Color4\n     */\n    multiplyToRef(color, result) {\n        result.r = this.r * color.r;\n        result.g = this.g * color.g;\n        result.b = this.b * color.b;\n        result.a = this.a * color.a;\n        return result;\n    }\n    /**\n     * Creates a string with the Color4 current values\n     * @returns the string representation of the Color4 object\n     */\n    toString() {\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\n    }\n    /**\n     * Returns the string \"Color4\"\n     * @returns \"Color4\"\n     */\n    getClassName() {\n        return \"Color4\";\n    }\n    /**\n     * Compute the Color4 hash code\n     * @returns an unique number that can be used to hash Color4 objects\n     */\n    getHashCode() {\n        let hash = (this.r * 255) | 0;\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\n        hash = (hash * 397) ^ ((this.a * 255) | 0);\n        return hash;\n    }\n    /**\n     * Creates a new Color4 copied from the current one\n     * @returns a new Color4 object\n     */\n    clone() {\n        return new Color4(this.r, this.g, this.b, this.a);\n    }\n    /**\n     * Copies the given Color4 values into the current one\n     * @param source defines the source Color4 object\n     * @returns the current updated Color4 object\n     */\n    copyFrom(source) {\n        this.r = source.r;\n        this.g = source.g;\n        this.b = source.b;\n        this.a = source.a;\n        return this;\n    }\n    /**\n     * Copies the given float values into the current one\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @param a defines the alpha component to read from\n     * @returns the current updated Color4 object\n     */\n    copyFromFloats(r, g, b, a) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        return this;\n    }\n    /**\n     * Copies the given float values into the current one\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @param a defines the alpha component to read from\n     * @returns the current updated Color4 object\n     */\n    set(r, g, b, a) {\n        return this.copyFromFloats(r, g, b, a);\n    }\n    /**\n     * Compute the Color4 hexadecimal code as a string\n     * @param returnAsColor3 defines if the string should only contains RGB values (off by default)\n     * @returns a string containing the hexadecimal representation of the Color4 object\n     */\n    toHexString(returnAsColor3 = false) {\n        var intR = (this.r * 255) | 0;\n        var intG = (this.g * 255) | 0;\n        var intB = (this.b * 255) | 0;\n        if (returnAsColor3) {\n            return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n        }\n        var intA = (this.a * 255) | 0;\n        return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);\n    }\n    /**\n     * Computes a new Color4 converted from the current one to linear space\n     * @returns a new Color4 object\n     */\n    toLinearSpace() {\n        var convertedColor = new Color4();\n        this.toLinearSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color4 object where to store the linear space version\n     * @returns the unmodified Color4\n     */\n    toLinearSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToLinearSpace);\n        convertedColor.g = Math.pow(this.g, ToLinearSpace);\n        convertedColor.b = Math.pow(this.b, ToLinearSpace);\n        convertedColor.a = this.a;\n        return this;\n    }\n    /**\n     * Computes a new Color4 converted from the current one to gamma space\n     * @returns a new Color4 object\n     */\n    toGammaSpace() {\n        var convertedColor = new Color4();\n        this.toGammaSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color4 object where to store the gamma space version\n     * @returns the unmodified Color4\n     */\n    toGammaSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToGammaSpace);\n        convertedColor.g = Math.pow(this.g, ToGammaSpace);\n        convertedColor.b = Math.pow(this.b, ToGammaSpace);\n        convertedColor.a = this.a;\n        return this;\n    }\n    // Statics\n    /**\n     * Creates a new Color4 from the string containing valid hexadecimal values\n     * @param hex defines a string containing valid hexadecimal values\n     * @returns a new Color4 object\n     */\n    static FromHexString(hex) {\n        if (hex.substring(0, 1) !== \"#\" || hex.length !== 9) {\n            return new Color4(0.0, 0.0, 0.0, 0.0);\n        }\n        var r = parseInt(hex.substring(1, 3), 16);\n        var g = parseInt(hex.substring(3, 5), 16);\n        var b = parseInt(hex.substring(5, 7), 16);\n        var a = parseInt(hex.substring(7, 9), 16);\n        return Color4.FromInts(r, g, b, a);\n    }\n    /**\n     * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n     * @param left defines the start value\n     * @param right defines the end value\n     * @param amount defines the gradient factor\n     * @returns a new Color4 object\n     */\n    static Lerp(left, right, amount) {\n        var result = new Color4(0.0, 0.0, 0.0, 0.0);\n        Color4.LerpToRef(left, right, amount, result);\n        return result;\n    }\n    /**\n     * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n     * @param left defines the start value\n     * @param right defines the end value\n     * @param amount defines the gradient factor\n     * @param result defines the Color4 object where to store data\n     */\n    static LerpToRef(left, right, amount, result) {\n        result.r = left.r + (right.r - left.r) * amount;\n        result.g = left.g + (right.g - left.g) * amount;\n        result.b = left.b + (right.b - left.b) * amount;\n        result.a = left.a + (right.a - left.a) * amount;\n    }\n    /**\n     * Creates a new Color4 from a Color3 and an alpha value\n     * @param color3 defines the source Color3 to read from\n     * @param alpha defines the alpha component (1.0 by default)\n     * @returns a new Color4 object\n     */\n    static FromColor3(color3, alpha = 1.0) {\n        return new Color4(color3.r, color3.g, color3.b, alpha);\n    }\n    /**\n     * Creates a new Color4 from the starting index element of the given array\n     * @param array defines the source array to read from\n     * @param offset defines the offset in the source array\n     * @returns a new Color4 object\n     */\n    static FromArray(array, offset = 0) {\n        return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    }\n    /**\n     * Creates a new Color4 from the starting index element of the given array\n     * @param array defines the source array to read from\n     * @param offset defines the offset in the source array\n     * @param result defines the target Color4 object\n     */\n    static FromArrayToRef(array, offset = 0, result) {\n        result.r = array[offset];\n        result.g = array[offset + 1];\n        result.b = array[offset + 2];\n        result.a = array[offset + 3];\n    }\n    /**\n     * Creates a new Color3 from integer values (< 256)\n     * @param r defines the red component to read from (value between 0 and 255)\n     * @param g defines the green component to read from (value between 0 and 255)\n     * @param b defines the blue component to read from (value between 0 and 255)\n     * @param a defines the alpha component to read from (value between 0 and 255)\n     * @returns a new Color3 object\n     */\n    static FromInts(r, g, b, a) {\n        return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n    }\n    /**\n     * Check the content of a given array and convert it to an array containing RGBA data\n     * If the original array was already containing count * 4 values then it is returned directly\n     * @param colors defines the array to check\n     * @param count defines the number of RGBA data to expect\n     * @returns an array containing count * 4 values (RGBA)\n     */\n    static CheckColors4(colors, count) {\n        // Check if color3 was used\n        if (colors.length === count * 3) {\n            var colors4 = [];\n            for (var index = 0; index < colors.length; index += 3) {\n                var newIndex = (index / 3) * 4;\n                colors4[newIndex] = colors[index];\n                colors4[newIndex + 1] = colors[index + 1];\n                colors4[newIndex + 2] = colors[index + 2];\n                colors4[newIndex + 3] = 1.0;\n            }\n            return colors4;\n        }\n        return colors;\n    }\n}\n/**\n * @hidden\n */\nexport class TmpColors {\n}\nTmpColors.Color3 = ArrayTools.BuildArray(3, Color3.Black);\nTmpColors.Color4 = ArrayTools.BuildArray(3, () => new Color4(0, 0, 0, 0));\n_TypeStore.RegisteredTypes[\"BABYLON.Color3\"] = Color3;\n_TypeStore.RegisteredTypes[\"BABYLON.Color4\"] = Color4;\n","/**\n * Constant used to convert a value to gamma space\n * @ignorenaming\n */\nexport const ToGammaSpace = 1 / 2.2;\n/**\n * Constant used to convert a value to linear space\n * @ignorenaming\n */\nexport const ToLinearSpace = 2.2;\nexport const DEG2RAD = Math.PI / 180;\nexport const RAD2DEG = 180 / Math.PI;\n/**\n * Constant used to define the minimal number value in Babylon.js\n * @ignorenaming\n */\nlet Epsilon = 0.001;\nexport { Epsilon };\n","import { Quat } from './math.quat';\nimport { Vec3 } from \"./math.vec3\";\nimport { Mat4 } from \"./math.mat4\";\nimport { MathTool } from \"./math.tool\";\nconst _matrix = /*@__PURE__*/ new Mat4();\nconst _quaternion = /*@__PURE__*/ new Quat();\nclass Euler {\n    constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._order = order;\n    }\n    get x() {\n        return this._x;\n    }\n    set x(value) {\n        this._x = value;\n        this._onChangeCallback();\n    }\n    get y() {\n        return this._y;\n    }\n    set y(value) {\n        this._y = value;\n        this._onChangeCallback();\n    }\n    get z() {\n        return this._z;\n    }\n    set z(value) {\n        this._z = value;\n        this._onChangeCallback();\n    }\n    get order() {\n        return this._order;\n    }\n    set order(value) {\n        this._order = value;\n        this._onChangeCallback();\n    }\n    set(x, y, z, order = this._order) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._order = order;\n        this._onChangeCallback();\n        return this;\n    }\n    clone() {\n        return new Euler(this._x, this._y, this._z, this._order);\n    }\n    copy(euler) {\n        this._x = euler._x;\n        this._y = euler._y;\n        this._z = euler._z;\n        this._order = euler._order;\n        this._onChangeCallback();\n        return this;\n    }\n    setFromRotationMatrix(m, order = this._order, update = true) {\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n        const te = m.data;\n        const m11 = te[0], m12 = te[4], m13 = te[8];\n        const m21 = te[1], m22 = te[5], m23 = te[9];\n        const m31 = te[2], m32 = te[6], m33 = te[10];\n        switch (order) {\n            case 'XYZ':\n                this._y = Math.asin(MathTool.clamp(m13, -1, 1));\n                if (Math.abs(m13) < 0.9999999) {\n                    this._x = Math.atan2(-m23, m33);\n                    this._z = Math.atan2(-m12, m11);\n                }\n                else {\n                    this._x = Math.atan2(m32, m22);\n                    this._z = 0;\n                }\n                break;\n            case 'YXZ':\n                this._x = Math.asin(-MathTool.clamp(m23, -1, 1));\n                if (Math.abs(m23) < 0.9999999) {\n                    this._y = Math.atan2(m13, m33);\n                    this._z = Math.atan2(m21, m22);\n                }\n                else {\n                    this._y = Math.atan2(-m31, m11);\n                    this._z = 0;\n                }\n                break;\n            case 'ZXY':\n                this._x = Math.asin(MathTool.clamp(m32, -1, 1));\n                if (Math.abs(m32) < 0.9999999) {\n                    this._y = Math.atan2(-m31, m33);\n                    this._z = Math.atan2(-m12, m22);\n                }\n                else {\n                    this._y = 0;\n                    this._z = Math.atan2(m21, m11);\n                }\n                break;\n            case 'ZYX':\n                this._y = Math.asin(-MathTool.clamp(m31, -1, 1));\n                if (Math.abs(m31) < 0.9999999) {\n                    this._x = Math.atan2(m32, m33);\n                    this._z = Math.atan2(m21, m11);\n                }\n                else {\n                    this._x = 0;\n                    this._z = Math.atan2(-m12, m22);\n                }\n                break;\n            case 'YZX':\n                this._z = Math.asin(MathTool.clamp(m21, -1, 1));\n                if (Math.abs(m21) < 0.9999999) {\n                    this._x = Math.atan2(-m23, m22);\n                    this._y = Math.atan2(-m31, m11);\n                }\n                else {\n                    this._x = 0;\n                    this._y = Math.atan2(m13, m33);\n                }\n                break;\n            case 'XZY':\n                this._z = Math.asin(-MathTool.clamp(m12, -1, 1));\n                if (Math.abs(m12) < 0.9999999) {\n                    this._x = Math.atan2(m32, m22);\n                    this._y = Math.atan2(m13, m11);\n                }\n                else {\n                    this._x = Math.atan2(-m23, m33);\n                    this._y = 0;\n                }\n                break;\n            default:\n                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);\n        }\n        this._order = order;\n        if (update === true)\n            this._onChangeCallback();\n        return this;\n    }\n    setFromQuaternion(q, order, update) {\n        _matrix.makeRotationFromQuaternion(q);\n        return this.setFromRotationMatrix(_matrix, order, update);\n    }\n    setFromVector3(v, order = this._order) {\n        return this.set(v.x, v.y, v.z, order);\n    }\n    reorder(newOrder) {\n        // WARNING: this discards revolution information -bhouston\n        _quaternion.setFromEuler(this);\n        return this.setFromQuaternion(_quaternion, newOrder);\n    }\n    equals(euler) {\n        return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);\n    }\n    fromArray(array) {\n        this._x = array[0];\n        this._y = array[1];\n        this._z = array[2];\n        if (array[3] !== undefined)\n            this._order = array[3];\n        this._onChangeCallback();\n        return this;\n    }\n    toArray(array, offset = 0) {\n        array[offset] = this._x;\n        array[offset + 1] = this._y;\n        array[offset + 2] = this._z;\n        array[offset + 3] = this._order;\n        return array;\n    }\n    toVector3(optionalResult) {\n        if (optionalResult) {\n            return optionalResult.set(this._x, this._y, this._z);\n        }\n        else {\n            return new Vec3(this._x, this._y, this._z);\n        }\n    }\n    _onChange(callback) {\n        this._onChangeCallback = callback;\n        return this;\n    }\n    _onChangeCallback() { }\n}\nEuler.prototype.isEuler = true;\nEuler.DefaultOrder = 'XYZ';\nEuler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];\nexport { Euler };\n","import { Vec3 } from \"./math.vec3\";\n/**\n * A 3x3 matrix.\n */\nclass Mat3 {\n    /**\n     * Create a new Mat3 instance. It is initialized to the identity matrix.\n     */\n    constructor() {\n        // Create an identity matrix. Note that a new Float32Array has all elements set\n        // to zero by default, so we only need to set the relevant elements to one.\n        const data = new Float32Array(9);\n        data[0] = data[4] = data[8] = 1;\n        /**\n         * Matrix elements in the form of a flat array.\n         *\n         * @type {Float32Array}\n         */\n        this.data = data;\n    }\n    invert() {\n        const te = this.data, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n        if (det === 0)\n            return this.set([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n        const detInv = 1 / det;\n        te[0] = t11 * detInv;\n        te[1] = (n31 * n23 - n33 * n21) * detInv;\n        te[2] = (n32 * n21 - n31 * n22) * detInv;\n        te[3] = t12 * detInv;\n        te[4] = (n33 * n11 - n31 * n13) * detInv;\n        te[5] = (n31 * n12 - n32 * n11) * detInv;\n        te[6] = t13 * detInv;\n        te[7] = (n21 * n13 - n23 * n11) * detInv;\n        te[8] = (n22 * n11 - n21 * n12) * detInv;\n        return this;\n    }\n    setFromMatrix4(m) {\n        const me = m.data;\n        this.set([me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]]);\n        return this;\n    }\n    /**\n     * Creates a duplicate of the specified matrix.\n     *\n     * @returns {Mat3} A duplicate matrix.\n     * @example\n     * var src = new pc.Mat3().translate(10, 20, 30);\n     * var dst = src.clone();\n     * console.log(\"The two matrices are \" + (src.equals(dst) ? \"equal\" : \"different\"));\n     */\n    clone() {\n        return new Mat3().copy(this);\n    }\n    /**\n     * Copies the contents of a source 3x3 matrix to a destination 3x3 matrix.\n     *\n     * @param {Mat3} rhs - A 3x3 matrix to be copied.\n     * @returns {Mat3} Self for chaining.\n     * @example\n     * var src = new pc.Mat3().translate(10, 20, 30);\n     * var dst = new pc.Mat3();\n     * dst.copy(src);\n     * console.log(\"The two matrices are \" + (src.equals(dst) ? \"equal\" : \"different\"));\n     */\n    copy(rhs) {\n        const src = rhs.data;\n        const dst = this.data;\n        dst[0] = src[0];\n        dst[1] = src[1];\n        dst[2] = src[2];\n        dst[3] = src[3];\n        dst[4] = src[4];\n        dst[5] = src[5];\n        dst[6] = src[6];\n        dst[7] = src[7];\n        dst[8] = src[8];\n        return this;\n    }\n    /**\n     * Copies the contents of a source array[9] to a destination 3x3 matrix.\n     *\n     * @param {number[]} src - An array[9] to be copied.\n     * @returns {Mat3} Self for chaining.\n     * @example\n     * var dst = new pc.Mat3();\n     * dst.set([0, 1, 2, 3, 4, 5, 6, 7, 8]);\n     */\n    set(src) {\n        const dst = this.data;\n        dst[0] = src[0];\n        dst[1] = src[1];\n        dst[2] = src[2];\n        dst[3] = src[3];\n        dst[4] = src[4];\n        dst[5] = src[5];\n        dst[6] = src[6];\n        dst[7] = src[7];\n        dst[8] = src[8];\n        return this;\n    }\n    /**\n     * Reports whether two matrices are equal.\n     *\n     * @param {Mat3} rhs - The other matrix.\n     * @returns {boolean} True if the matrices are equal and false otherwise.\n     * @example\n     * var a = new pc.Mat3().translate(10, 20, 30);\n     * var b = new pc.Mat3();\n     * console.log(\"The two matrices are \" + (a.equals(b) ? \"equal\" : \"different\"));\n     */\n    equals(rhs) {\n        const l = this.data;\n        const r = rhs.data;\n        return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];\n    }\n    /**\n     * Reports whether the specified matrix is the identity matrix.\n     *\n     * @returns {boolean} True if the matrix is identity and false otherwise.\n     * @example\n     * var m = new pc.Mat3();\n     * console.log(\"The matrix is \" + (m.isIdentity() ? \"identity\" : \"not identity\"));\n     */\n    isIdentity() {\n        const m = this.data;\n        return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;\n    }\n    /**\n     * Sets the matrix to the identity matrix.\n     *\n     * @returns {Mat3} Self for chaining.\n     * @example\n     * m.setIdentity();\n     * console.log(\"The matrix is \" + (m.isIdentity() ? \"identity\" : \"not identity\"));\n     */\n    setIdentity() {\n        const m = this.data;\n        m[0] = 1;\n        m[1] = 0;\n        m[2] = 0;\n        m[3] = 0;\n        m[4] = 1;\n        m[5] = 0;\n        m[6] = 0;\n        m[7] = 0;\n        m[8] = 1;\n        return this;\n    }\n    /**\n     * Converts the matrix to string form.\n     *\n     * @returns {string} The matrix in string form.\n     * @example\n     * var m = new pc.Mat3();\n     * // Outputs [1, 0, 0, 0, 1, 0, 0, 0, 1]\n     * console.log(m.toString());\n     */\n    toString() {\n        let t = \"[\";\n        for (let i = 0; i < 9; i++) {\n            t += this.data[i];\n            t += i !== 8 ? \", \" : \"\";\n        }\n        t += \"]\";\n        return t;\n    }\n    /**\n     * Generates the transpose of the specified 3x3 matrix.\n     *\n     * @returns {Mat3} Self for chaining.\n     * @example\n     * var m = new pc.Mat3();\n     *\n     * // Transpose in place\n     * m.transpose();\n     */\n    transpose() {\n        const m = this.data;\n        let tmp;\n        tmp = m[1];\n        m[1] = m[3];\n        m[3] = tmp;\n        tmp = m[2];\n        m[2] = m[6];\n        m[6] = tmp;\n        tmp = m[5];\n        m[5] = m[7];\n        m[7] = tmp;\n        return this;\n    }\n    /**\n     * Converts the specified 4x4 matrix to a Mat3.\n     *\n     * @param {Mat4} m - The 4x4 matrix to convert.\n     * @returns {Mat3} Self for chaining.\n     */\n    setFromMat4(m) {\n        const src = m.data;\n        const dst = this.data;\n        dst[0] = src[0];\n        dst[1] = src[1];\n        dst[2] = src[2];\n        dst[3] = src[4];\n        dst[4] = src[5];\n        dst[5] = src[6];\n        dst[6] = src[8];\n        dst[7] = src[9];\n        dst[8] = src[10];\n        return this;\n    }\n    /**\n     * Transforms a 3-dimensional vector by a 3x3 matrix.\n     *\n     * @param {Vec3} vec - The 3-dimensional vector to be transformed.\n     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the\n     * transformation.\n     * @returns {Vec3} The input vector v transformed by the current instance.\n     */\n    transformVector(vec, res = new Vec3()) {\n        const m = this.data;\n        const x = vec.x;\n        const y = vec.y;\n        const z = vec.z;\n        res.x = x * m[0] + y * m[3] + z * m[6];\n        res.y = x * m[1] + y * m[4] + z * m[7];\n        res.z = x * m[2] + y * m[5] + z * m[8];\n        return res;\n    }\n    getNormalMatrix(matrix4) {\n        return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n}\n/**\n * A constant matrix set to the identity.\n *\n * @type {Mat3}\n * @readonly\n */\nMat3.IDENTITY = Object.freeze(new Mat3());\n/**\n * A constant matrix with all elements set to 0.\n *\n * @type {Mat3}\n * @readonly\n */\nMat3.ZERO = Object.freeze(new Mat3().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));\nexport { Mat3 };\n","/** @typedef {import('./quat.js').Quat} Quat */\nimport { MathTool } from \"./math.tool\";\nimport { Vec2 } from \"./math.vec2\";\nimport { Vec3 } from \"./math.vec3\";\nimport { Vec4 } from \"./math.vec4\";\nconst _halfSize = new Vec2();\nconst x = new Vec3();\nconst y = new Vec3();\nconst z = new Vec3();\nconst scale = new Vec3();\nconst _v1 = /*@__PURE__*/ new Vec3();\n/**\n * A 4x4 matrix.\n */\nclass Mat4 {\n    /**\n     * Create a new Mat4 instance. It is initialized to the identity matrix.\n     */\n    constructor() {\n        // Create an identity matrix. Note that a new Float32Array has all elements set\n        // to zero by default, so we only need to set the relevant elements to one.\n        const data = new Float32Array(16);\n        data[0] = data[5] = data[10] = data[15] = 1;\n        /**\n         * Matrix elements in the form of a flat array.\n         *\n         * @type {Float32Array}\n         */\n        this.data = data;\n    }\n    // \n    makePerspectiveLH(left, right, top, bottom, near, far) {\n        if (far === undefined) {\n            console.warn(\"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\");\n        }\n        const te = this.data;\n        const x = (2 * near) / (right - left);\n        const y = (2 * near) / (top - bottom);\n        const a = (right + left) / (right - left);\n        const b = (top + bottom) / (top - bottom);\n        const c = (far + near) / (far - near);\n        const d = (-2 * far * near) / (far - near);\n        te[0] = x;\n        te[4] = 0;\n        te[8] = a;\n        te[12] = 0;\n        te[1] = 0;\n        te[5] = y;\n        te[9] = b;\n        te[13] = 0;\n        te[2] = 0;\n        te[6] = 0;\n        te[10] = c;\n        te[14] = d;\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = 1;\n        te[15] = 0;\n        return this;\n    }\n    // \n    makePerspectiveRH(left, right, top, bottom, near, far) {\n        if (far === undefined) {\n            console.warn(\"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\");\n        }\n        var te = this.data;\n        const x = (2 * near) / (right - left);\n        const y = (2 * near) / (top - bottom);\n        const a = (right + left) / (right - left);\n        const b = (top + bottom) / (top - bottom);\n        const c = -(far + near) / (far - near);\n        const d = (-2 * far * near) / (far - near);\n        te[0] = x;\n        te[4] = 0;\n        te[8] = a;\n        te[12] = 0;\n        te[1] = 0;\n        te[5] = y;\n        te[9] = b;\n        te[13] = 0;\n        te[2] = 0;\n        te[6] = 0;\n        te[10] = c;\n        te[14] = d;\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = -1;\n        te[15] = 0;\n        return this;\n    }\n    makeRotationFromQuaternion(q) {\n        return this.compose(_zero, q, _one);\n    }\n    // Static function which evaluates perspective projection matrix half size at the near plane\n    static _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {\n        if (fovIsHorizontal) {\n            halfSize.x = znear * Math.tan((fov * Math.PI) / 360);\n            halfSize.y = halfSize.x / aspect;\n        }\n        else {\n            halfSize.y = znear * Math.tan((fov * Math.PI) / 360);\n            halfSize.x = halfSize.y * aspect;\n        }\n    }\n    /**\n     * Adds the specified 4x4 matrices together and stores the result in the current instance.\n     *\n     * @param {Mat4} lhs - The 4x4 matrix used as the first operand of the addition.\n     * @param {Mat4} rhs - The 4x4 matrix used as the second operand of the addition.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var m = new pc.Mat4();\n     *\n     * m.add2(pc.Mat4.IDENTITY, pc.Mat4.ONE);\n     *\n     * console.log(\"The result of the addition is: \" + m.toString());\n     */\n    add2(lhs, rhs) {\n        const a = lhs.data, b = rhs.data, r = this.data;\n        r[0] = a[0] + b[0];\n        r[1] = a[1] + b[1];\n        r[2] = a[2] + b[2];\n        r[3] = a[3] + b[3];\n        r[4] = a[4] + b[4];\n        r[5] = a[5] + b[5];\n        r[6] = a[6] + b[6];\n        r[7] = a[7] + b[7];\n        r[8] = a[8] + b[8];\n        r[9] = a[9] + b[9];\n        r[10] = a[10] + b[10];\n        r[11] = a[11] + b[11];\n        r[12] = a[12] + b[12];\n        r[13] = a[13] + b[13];\n        r[14] = a[14] + b[14];\n        r[15] = a[15] + b[15];\n        return this;\n    }\n    /**\n     * Adds the specified 4x4 matrix to the current instance.\n     *\n     * @param {Mat4} rhs - The 4x4 matrix used as the second operand of the addition.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var m = new pc.Mat4();\n     *\n     * m.add(pc.Mat4.ONE);\n     *\n     * console.log(\"The result of the addition is: \" + m.toString());\n     */\n    add(rhs) {\n        return this.add2(this, rhs);\n    }\n    /**\n     * Creates a duplicate of the specified matrix.\n     *\n     * @returns {Mat4} A duplicate matrix.\n     * @example\n     * var src = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     * var dst = src.clone();\n     * console.log(\"The two matrices are \" + (src.equals(dst) ? \"equal\" : \"different\"));\n     */\n    clone() {\n        return new Mat4().copy(this);\n    }\n    /**\n     * Copies the contents of a source 4x4 matrix to a destination 4x4 matrix.\n     *\n     * @param {Mat4} rhs - A 4x4 matrix to be copied.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var src = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     * var dst = new pc.Mat4();\n     * dst.copy(src);\n     * console.log(\"The two matrices are \" + (src.equals(dst) ? \"equal\" : \"different\"));\n     */\n    copy(rhs) {\n        const src = rhs.data, dst = this.data;\n        dst[0] = src[0];\n        dst[1] = src[1];\n        dst[2] = src[2];\n        dst[3] = src[3];\n        dst[4] = src[4];\n        dst[5] = src[5];\n        dst[6] = src[6];\n        dst[7] = src[7];\n        dst[8] = src[8];\n        dst[9] = src[9];\n        dst[10] = src[10];\n        dst[11] = src[11];\n        dst[12] = src[12];\n        dst[13] = src[13];\n        dst[14] = src[14];\n        dst[15] = src[15];\n        return this;\n    }\n    /**\n     * Reports whether two matrices are equal.\n     *\n     * @param {Mat4} rhs - The other matrix.\n     * @returns {boolean} True if the matrices are equal and false otherwise.\n     * @example\n     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     * var b = new pc.Mat4();\n     * console.log(\"The two matrices are \" + (a.equals(b) ? \"equal\" : \"different\"));\n     */\n    equals(rhs) {\n        const l = this.data, r = rhs.data;\n        return (l[0] === r[0] &&\n            l[1] === r[1] &&\n            l[2] === r[2] &&\n            l[3] === r[3] &&\n            l[4] === r[4] &&\n            l[5] === r[5] &&\n            l[6] === r[6] &&\n            l[7] === r[7] &&\n            l[8] === r[8] &&\n            l[9] === r[9] &&\n            l[10] === r[10] &&\n            l[11] === r[11] &&\n            l[12] === r[12] &&\n            l[13] === r[13] &&\n            l[14] === r[14] &&\n            l[15] === r[15]);\n    }\n    /**\n     * Reports whether the specified matrix is the identity matrix.\n     *\n     * @returns {boolean} True if the matrix is identity and false otherwise.\n     * @example\n     * var m = new pc.Mat4();\n     * console.log(\"The matrix is \" + (m.isIdentity() ? \"identity\" : \"not identity\"));\n     */\n    isIdentity() {\n        const m = this.data;\n        return (m[0] === 1 &&\n            m[1] === 0 &&\n            m[2] === 0 &&\n            m[3] === 0 &&\n            m[4] === 0 &&\n            m[5] === 1 &&\n            m[6] === 0 &&\n            m[7] === 0 &&\n            m[8] === 0 &&\n            m[9] === 0 &&\n            m[10] === 1 &&\n            m[11] === 0 &&\n            m[12] === 0 &&\n            m[13] === 0 &&\n            m[14] === 0 &&\n            m[15] === 1);\n    }\n    /**\n     * Multiplies the specified 4x4 matrices together and stores the result in the current\n     * instance.\n     *\n     * @param {Mat4} lhs - The 4x4 matrix used as the first multiplicand of the operation.\n     * @param {Mat4} rhs - The 4x4 matrix used as the second multiplicand of the operation.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     * var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);\n     * var r = new pc.Mat4();\n     *\n     * // r = a * b\n     * r.mul2(a, b);\n     *\n     * console.log(\"The result of the multiplication is: \" + r.toString());\n     */\n    mul2(lhs, rhs) {\n        const a = lhs.data;\n        const b = rhs.data;\n        const r = this.data;\n        const a00 = a[0];\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        let b0, b1, b2, b3;\n        b0 = b[0];\n        b1 = b[1];\n        b2 = b[2];\n        b3 = b[3];\n        r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n        r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n        r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n        r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n        b0 = b[4];\n        b1 = b[5];\n        b2 = b[6];\n        b3 = b[7];\n        r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n        r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n        r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n        r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n        b0 = b[8];\n        b1 = b[9];\n        b2 = b[10];\n        b3 = b[11];\n        r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n        r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n        r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n        r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n        b0 = b[12];\n        b1 = b[13];\n        b2 = b[14];\n        b3 = b[15];\n        r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n        r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n        r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n        r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n        return this;\n    }\n    /**\n     * Multiplies the specified 4x4 matrices together and stores the result in the current\n     * instance. This function assumes the matrices are affine transformation matrices, where the\n     * upper left 3x3 elements are a rotation matrix, and the bottom left 3 elements are\n     * translation. The rightmost column is assumed to be [0, 0, 0, 1]. The parameters are not\n     * verified to be in the expected format. This function is faster than general\n     * {@link Mat4#mul2}.\n     *\n     * @param {Mat4} lhs - The affine transformation 4x4 matrix used as the first multiplicand of\n     * the operation.\n     * @param {Mat4} rhs - The affine transformation 4x4 matrix used as the second multiplicand of\n     * the operation.\n     * @returns {Mat4} Self for chaining.\n     */\n    mulAffine2(lhs, rhs) {\n        const a = lhs.data;\n        const b = rhs.data;\n        const r = this.data;\n        const a00 = a[0];\n        const a01 = a[1];\n        const a02 = a[2];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        let b0, b1, b2;\n        b0 = b[0];\n        b1 = b[1];\n        b2 = b[2];\n        r[0] = a00 * b0 + a10 * b1 + a20 * b2;\n        r[1] = a01 * b0 + a11 * b1 + a21 * b2;\n        r[2] = a02 * b0 + a12 * b1 + a22 * b2;\n        r[3] = 0;\n        b0 = b[4];\n        b1 = b[5];\n        b2 = b[6];\n        r[4] = a00 * b0 + a10 * b1 + a20 * b2;\n        r[5] = a01 * b0 + a11 * b1 + a21 * b2;\n        r[6] = a02 * b0 + a12 * b1 + a22 * b2;\n        r[7] = 0;\n        b0 = b[8];\n        b1 = b[9];\n        b2 = b[10];\n        r[8] = a00 * b0 + a10 * b1 + a20 * b2;\n        r[9] = a01 * b0 + a11 * b1 + a21 * b2;\n        r[10] = a02 * b0 + a12 * b1 + a22 * b2;\n        r[11] = 0;\n        b0 = b[12];\n        b1 = b[13];\n        b2 = b[14];\n        r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;\n        r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;\n        r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;\n        r[15] = 1;\n        return this;\n    }\n    /**\n     * Multiplies the current instance by the specified 4x4 matrix.\n     *\n     * @param {Mat4} rhs - The 4x4 matrix used as the second multiplicand of the operation.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     * var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);\n     *\n     * // a = a * b\n     * a.mul(b);\n     *\n     * console.log(\"The result of the multiplication is: \" + a.toString());\n     */\n    mul(rhs) {\n        return this.mul2(this, rhs);\n    }\n    /**\n     * Transforms a 3-dimensional point by a 4x4 matrix.\n     *\n     * @param {Vec3} vec - The 3-dimensional point to be transformed.\n     * @param {Vec3} [res] - An optional 3-dimensional point to receive the result of the\n     * transformation.\n     * @returns {Vec3} The input point v transformed by the current instance.\n     * @example\n     * // Create a 3-dimensional point\n     * var v = new pc.Vec3(1, 2, 3);\n     *\n     * // Create a 4x4 rotation matrix\n     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     *\n     * var tv = m.transformPoint(v);\n     */\n    transformPoint(vec, res = new Vec3()) {\n        const m = this.data;\n        const x = vec.x;\n        const y = vec.y;\n        const z = vec.z;\n        res.x = x * m[0] + y * m[4] + z * m[8] + m[12];\n        res.y = x * m[1] + y * m[5] + z * m[9] + m[13];\n        res.z = x * m[2] + y * m[6] + z * m[10] + m[14];\n        return res;\n    }\n    /**\n     * Transforms a 3-dimensional vector by a 4x4 matrix.\n     *\n     * @param {Vec3} vec - The 3-dimensional vector to be transformed.\n     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the\n     * transformation.\n     * @returns {Vec3} The input vector v transformed by the current instance.\n     * @example\n     * // Create a 3-dimensional vector\n     * var v = new pc.Vec3(1, 2, 3);\n     *\n     * // Create a 4x4 rotation matrix\n     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     *\n     * var tv = m.transformVector(v);\n     */\n    transformVector(vec, res = new Vec3()) {\n        const m = this.data;\n        const x = vec.x;\n        const y = vec.y;\n        const z = vec.z;\n        res.x = x * m[0] + y * m[4] + z * m[8];\n        res.y = x * m[1] + y * m[5] + z * m[9];\n        res.z = x * m[2] + y * m[6] + z * m[10];\n        return res;\n    }\n    /**\n     * Transforms a 4-dimensional vector by a 4x4 matrix.\n     *\n     * @param {Vec4} vec - The 4-dimensional vector to be transformed.\n     * @param {Vec4} [res] - An optional 4-dimensional vector to receive the result of the\n     * transformation.\n     * @returns {Vec4} The input vector v transformed by the current instance.\n     * @example\n     * // Create an input 4-dimensional vector\n     * var v = new pc.Vec4(1, 2, 3, 4);\n     *\n     * // Create an output 4-dimensional vector\n     * var result = new pc.Vec4();\n     *\n     * // Create a 4x4 rotation matrix\n     * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);\n     *\n     * m.transformVec4(v, result);\n     */\n    transformVec4(vec, res = new Vec4()) {\n        const m = this.data;\n        const x = vec.x;\n        const y = vec.y;\n        const z = vec.z;\n        const w = vec.w;\n        res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];\n        res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];\n        res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];\n        res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];\n        return res;\n    }\n    /**\n     * Sets the specified matrix to a viewing matrix derived from an eye point, a target point and\n     * an up vector. The matrix maps the target point to the negative z-axis and the eye point to\n     * the origin, so that when you use a typical projection matrix, the center of the scene maps\n     * to the center of the viewport. Similarly, the direction described by the up vector projected\n     * onto the viewing plane is mapped to the positive y-axis so that it points upward in the\n     * viewport. The up vector must not be parallel to the line of sight from the eye to the\n     * reference point.\n     *\n     * @param {Vec3} position - 3-d vector holding view position.\n     * @param {Vec3} target - 3-d vector holding reference point.\n     * @param {Vec3} up - 3-d vector holding the up direction.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var position = new pc.Vec3(10, 10, 10);\n     * var target = new pc.Vec3(0, 0, 0);\n     * var up = new pc.Vec3(0, 1, 0);\n     * var m = new pc.Mat4().setLookAt(position, target, up);\n     */\n    setLookAt(position, target, up) {\n        z.sub2(position, target).normalize();\n        y.copy(up).normalize();\n        x.cross(y, z).normalize();\n        y.cross(z, x);\n        const r = this.data;\n        r[0] = x.x;\n        r[1] = x.y;\n        r[2] = x.z;\n        r[3] = 0;\n        r[4] = y.x;\n        r[5] = y.y;\n        r[6] = y.z;\n        r[7] = 0;\n        r[8] = z.x;\n        r[9] = z.y;\n        r[10] = z.z;\n        r[11] = 0;\n        r[12] = position.x;\n        r[13] = position.y;\n        r[14] = position.z;\n        r[15] = 1;\n        return this;\n    }\n    /**\n     * Sets the specified matrix to a perspective projection matrix. The function's parameters\n     * define the shape of a frustum.\n     *\n     * @param {number} left - The x-coordinate for the left edge of the camera's projection plane\n     * in eye space.\n     * @param {number} right - The x-coordinate for the right edge of the camera's projection plane\n     * in eye space.\n     * @param {number} bottom - The y-coordinate for the bottom edge of the camera's projection\n     * plane in eye space.\n     * @param {number} top - The y-coordinate for the top edge of the camera's projection plane in\n     * eye space.\n     * @param {number} znear - The near clip plane in eye coordinates.\n     * @param {number} zfar - The far clip plane in eye coordinates.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 perspective projection matrix\n     * var f = pc.Mat4().setFrustum(-2, 2, -1, 1, 1, 1000);\n     * @ignore\n     */\n    setFrustum(left, right, bottom, top, znear, zfar) {\n        const temp1 = 2 * znear;\n        const temp2 = right - left;\n        const temp3 = top - bottom;\n        const temp4 = zfar - znear;\n        const r = this.data;\n        r[0] = temp1 / temp2;\n        r[1] = 0;\n        r[2] = 0;\n        r[3] = 0;\n        r[4] = 0;\n        r[5] = temp1 / temp3;\n        r[6] = 0;\n        r[7] = 0;\n        r[8] = (right + left) / temp2;\n        r[9] = (top + bottom) / temp3;\n        r[10] = (-zfar - znear) / temp4;\n        r[11] = -1;\n        r[12] = 0;\n        r[13] = 0;\n        r[14] = (-temp1 * zfar) / temp4;\n        r[15] = 0;\n        return this;\n    }\n    /**\n     * Sets the specified matrix to a perspective projection matrix. The function's parameters\n     * define the shape of a frustum.\n     *\n     * @param {number} fov - The frustum's field of view in degrees. The fovIsHorizontal parameter\n     * controls whether this is a vertical or horizontal field of view. By default, it's a vertical\n     * field of view.\n     * @param {number} aspect - The aspect ratio of the frustum's projection plane\n     * (width / height).\n     * @param {number} znear - The near clip plane in eye coordinates.\n     * @param {number} zfar - The far clip plane in eye coordinates.\n     * @param {boolean} [fovIsHorizontal=false] - Set to true to treat the fov as horizontal\n     * (x-axis) and false for vertical (y-axis). Defaults to false.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 perspective projection matrix\n     * var persp = pc.Mat4().setPerspective(45, 16 / 9, 1, 1000);\n     */\n    setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {\n        Mat4._getPerspectiveHalfSize(_halfSize, fov, aspect, znear, fovIsHorizontal);\n        return this.setFrustum(-_halfSize.x, _halfSize.x, -_halfSize.y, _halfSize.y, znear, zfar);\n    }\n    /**\n     * Sets the specified matrix to an orthographic projection matrix. The function's parameters\n     * define the shape of a cuboid-shaped frustum.\n     *\n     * @param {number} left - The x-coordinate for the left edge of the camera's projection plane\n     * in eye space.\n     * @param {number} right - The x-coordinate for the right edge of the camera's projection plane\n     * in eye space.\n     * @param {number} bottom - The y-coordinate for the bottom edge of the camera's projection\n     * plane in eye space.\n     * @param {number} top - The y-coordinate for the top edge of the camera's projection plane in\n     * eye space.\n     * @param {number} near - The near clip plane in eye coordinates.\n     * @param {number} far - The far clip plane in eye coordinates.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 orthographic projection matrix\n     * var ortho = pc.Mat4().ortho(-2, 2, -2, 2, 1, 1000);\n     */\n    setOrtho(left, right, bottom, top, near, far) {\n        const r = this.data;\n        r[0] = 2 / (right - left);\n        r[1] = 0;\n        r[2] = 0;\n        r[3] = 0;\n        r[4] = 0;\n        r[5] = 2 / (top - bottom);\n        r[6] = 0;\n        r[7] = 0;\n        r[8] = 0;\n        r[9] = 0;\n        r[10] = -2 / (far - near);\n        r[11] = 0;\n        r[12] = -(right + left) / (right - left);\n        r[13] = -(top + bottom) / (top - bottom);\n        r[14] = -(far + near) / (far - near);\n        r[15] = 1;\n        return this;\n    }\n    /**\n     * Sets the specified matrix to a rotation matrix equivalent to a rotation around an axis. The\n     * axis must be normalized (unit length) and the angle must be specified in degrees.\n     *\n     * @param {Vec3} axis - The normalized axis vector around which to rotate.\n     * @param {number} angle - The angle of rotation in degrees.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 rotation matrix\n     * var rm = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 90);\n     */\n    setFromAxisAngle(axis, angle) {\n        angle *= MathTool.DEG_TO_RAD;\n        const x = axis.x;\n        const y = axis.y;\n        const z = axis.z;\n        const c = Math.cos(angle);\n        const s = Math.sin(angle);\n        const t = 1 - c;\n        const tx = t * x;\n        const ty = t * y;\n        const m = this.data;\n        m[0] = tx * x + c;\n        m[1] = tx * y + s * z;\n        m[2] = tx * z - s * y;\n        m[3] = 0;\n        m[4] = tx * y - s * z;\n        m[5] = ty * y + c;\n        m[6] = ty * z + s * x;\n        m[7] = 0;\n        m[8] = tx * z + s * y;\n        m[9] = ty * z - x * s;\n        m[10] = t * z * z + c;\n        m[11] = 0;\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n        return this;\n    }\n    /**\n     * Sets the specified matrix to a translation matrix.\n     *\n     * @param {number} x - The x-component of the translation.\n     * @param {number} y - The y-component of the translation.\n     * @param {number} z - The z-component of the translation.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 translation matrix\n     * var tm = new pc.Mat4().setTranslate(10, 10, 10);\n     * @ignore\n     */\n    setTranslate(x, y, z) {\n        const m = this.data;\n        m[0] = 1;\n        m[1] = 0;\n        m[2] = 0;\n        m[3] = 0;\n        m[4] = 0;\n        m[5] = 1;\n        m[6] = 0;\n        m[7] = 0;\n        m[8] = 0;\n        m[9] = 0;\n        m[10] = 1;\n        m[11] = 0;\n        m[12] = x;\n        m[13] = y;\n        m[14] = z;\n        m[15] = 1;\n        return this;\n    }\n    /**\n     * Sets the specified matrix to a scale matrix.\n     *\n     * @param {number} x - The x-component of the scale.\n     * @param {number} y - The y-component of the scale.\n     * @param {number} z - The z-component of the scale.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 scale matrix\n     * var sm = new pc.Mat4().setScale(10, 10, 10);\n     * @ignore\n     */\n    setScale(x, y, z) {\n        const m = this.data;\n        m[0] = x;\n        m[1] = 0;\n        m[2] = 0;\n        m[3] = 0;\n        m[4] = 0;\n        m[5] = y;\n        m[6] = 0;\n        m[7] = 0;\n        m[8] = 0;\n        m[9] = 0;\n        m[10] = z;\n        m[11] = 0;\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n        return this;\n    }\n    /**\n     * Sets the specified matrix to a matrix transforming a normalized view volume (in range of\n     * -1 .. 1) to their position inside a viewport (in range of 0 .. 1). This encapsulates a\n     * scaling to the size of the viewport and a translation to the position of the viewport.\n     *\n     * @param {number} x - The x-component of the position of the viewport (in 0..1 range).\n     * @param {number} y - The y-component of the position of the viewport (in 0..1 range).\n     * @param {number} width - The width of the viewport (in 0..1 range).\n     * @param {number} height - The height of the viewport (in 0..1 range).\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 viewport matrix which scales normalized view volume to full texture viewport\n     * var vm = new pc.Mat4().setViewport(0, 0, 1, 1);\n     * @ignore\n     */\n    setViewport(x, y, width, height) {\n        const m = this.data;\n        m[0] = width * 0.5;\n        m[1] = 0;\n        m[2] = 0;\n        m[3] = 0;\n        m[4] = 0;\n        m[5] = height * 0.5;\n        m[6] = 0;\n        m[7] = 0;\n        m[8] = 0;\n        m[9] = 0;\n        m[10] = 0.5;\n        m[11] = 0;\n        m[12] = x + width * 0.5;\n        m[13] = y + height * 0.5;\n        m[14] = 0.5;\n        m[15] = 1;\n        return this;\n    }\n    /**\n     * Sets the specified matrix to its inverse.\n     *\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * // Create a 4x4 rotation matrix of 180 degrees around the y-axis\n     * var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);\n     *\n     * // Invert in place\n     * rot.invert();\n     */\n    invert() {\n        const m = this.data;\n        const a00 = m[0];\n        const a01 = m[1];\n        const a02 = m[2];\n        const a03 = m[3];\n        const a10 = m[4];\n        const a11 = m[5];\n        const a12 = m[6];\n        const a13 = m[7];\n        const a20 = m[8];\n        const a21 = m[9];\n        const a22 = m[10];\n        const a23 = m[11];\n        const a30 = m[12];\n        const a31 = m[13];\n        const a32 = m[14];\n        const a33 = m[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n        const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n        if (det === 0) {\n            this.setIdentity();\n        }\n        else {\n            const invDet = 1 / det;\n            m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n            m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n            m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n            m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n            m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n            m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n            m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n            m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n            m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n            m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n            m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n            m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n            m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n            m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n            m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n            m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n        }\n        return this;\n    }\n    /**\n     * Sets matrix data from an array.\n     *\n     * @param {number[]} src - Source array. Must have 16 values.\n     * @returns {Mat4} Self for chaining.\n     */\n    set(src) {\n        const dst = this.data;\n        dst[0] = src[0];\n        dst[1] = src[1];\n        dst[2] = src[2];\n        dst[3] = src[3];\n        dst[4] = src[4];\n        dst[5] = src[5];\n        dst[6] = src[6];\n        dst[7] = src[7];\n        dst[8] = src[8];\n        dst[9] = src[9];\n        dst[10] = src[10];\n        dst[11] = src[11];\n        dst[12] = src[12];\n        dst[13] = src[13];\n        dst[14] = src[14];\n        dst[15] = src[15];\n        return this;\n    }\n    /**\n     * Sets the specified matrix to the identity matrix.\n     *\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * m.setIdentity();\n     * console.log(\"The matrix is \" + (m.isIdentity() ? \"identity\" : \"not identity\"));\n     */\n    setIdentity() {\n        const m = this.data;\n        m[0] = 1;\n        m[1] = 0;\n        m[2] = 0;\n        m[3] = 0;\n        m[4] = 0;\n        m[5] = 1;\n        m[6] = 0;\n        m[7] = 0;\n        m[8] = 0;\n        m[9] = 0;\n        m[10] = 1;\n        m[11] = 0;\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n        return this;\n    }\n    /**\n     * Sets the specified matrix to the concatenation of a translation, a quaternion rotation and a\n     * scale.\n     *\n     * @param {Vec3} t - A 3-d vector translation.\n     * @param {Quat} r - A quaternion rotation.\n     * @param {Vec3} s - A 3-d vector scale.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var t = new pc.Vec3(10, 20, 30);\n     * var r = new pc.Quat();\n     * var s = new pc.Vec3(2, 2, 2);\n     *\n     * var m = new pc.Mat4();\n     * m.setTRS(t, r, s);\n     */\n    setTRS(t, r, s) {\n        const qx = r.x;\n        const qy = r.y;\n        const qz = r.z;\n        const qw = r.w;\n        const sx = s.x;\n        const sy = s.y;\n        const sz = s.z;\n        const x2 = qx + qx;\n        const y2 = qy + qy;\n        const z2 = qz + qz;\n        const xx = qx * x2;\n        const xy = qx * y2;\n        const xz = qx * z2;\n        const yy = qy * y2;\n        const yz = qy * z2;\n        const zz = qz * z2;\n        const wx = qw * x2;\n        const wy = qw * y2;\n        const wz = qw * z2;\n        const m = this.data;\n        m[0] = (1 - (yy + zz)) * sx;\n        m[1] = (xy + wz) * sx;\n        m[2] = (xz - wy) * sx;\n        m[3] = 0;\n        m[4] = (xy - wz) * sy;\n        m[5] = (1 - (xx + zz)) * sy;\n        m[6] = (yz + wx) * sy;\n        m[7] = 0;\n        m[8] = (xz + wy) * sz;\n        m[9] = (yz - wx) * sz;\n        m[10] = (1 - (xx + yy)) * sz;\n        m[11] = 0;\n        m[12] = t.x;\n        m[13] = t.y;\n        m[14] = t.z;\n        m[15] = 1;\n        return this;\n    }\n    /**\n     * Sets the specified matrix to its transpose.\n     *\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var m = new pc.Mat4();\n     *\n     * // Transpose in place\n     * m.transpose();\n     */\n    transpose() {\n        let tmp;\n        const m = this.data;\n        tmp = m[1];\n        m[1] = m[4];\n        m[4] = tmp;\n        tmp = m[2];\n        m[2] = m[8];\n        m[8] = tmp;\n        tmp = m[3];\n        m[3] = m[12];\n        m[12] = tmp;\n        tmp = m[6];\n        m[6] = m[9];\n        m[9] = tmp;\n        tmp = m[7];\n        m[7] = m[13];\n        m[13] = tmp;\n        tmp = m[11];\n        m[11] = m[14];\n        m[14] = tmp;\n        return this;\n    }\n    invertTo3x3(res) {\n        const m = this.data;\n        const r = res.data;\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const a11 = m10 * m5 - m6 * m9;\n        const a21 = -m10 * m1 + m2 * m9;\n        const a31 = m6 * m1 - m2 * m5;\n        const a12 = -m10 * m4 + m6 * m8;\n        const a22 = m10 * m0 - m2 * m8;\n        const a32 = -m6 * m0 + m2 * m4;\n        const a13 = m9 * m4 - m5 * m8;\n        const a23 = -m9 * m0 + m1 * m8;\n        const a33 = m5 * m0 - m1 * m4;\n        const det = m0 * a11 + m1 * a12 + m2 * a13;\n        if (det === 0) {\n            // no inverse\n            return this;\n        }\n        const idet = 1 / det;\n        r[0] = idet * a11;\n        r[1] = idet * a21;\n        r[2] = idet * a31;\n        r[3] = idet * a12;\n        r[4] = idet * a22;\n        r[5] = idet * a32;\n        r[6] = idet * a13;\n        r[7] = idet * a23;\n        r[8] = idet * a33;\n        return this;\n    }\n    /**\n     * Extracts the translational component from the specified 4x4 matrix.\n     *\n     * @param {Vec3} [t] - The vector to receive the translation of the matrix.\n     * @returns {Vec3} The translation of the specified 4x4 matrix.\n     * @example\n     * // Create a 4x4 matrix\n     * var m = new pc.Mat4();\n     *\n     * // Query the z-axis component\n     * var t = new pc.Vec3();\n     * m.getTranslation(t);\n     */\n    getTranslation(t = new Vec3()) {\n        return t.set(this.data[12], this.data[13], this.data[14]);\n    }\n    /**\n     * Extracts the x-axis from the specified 4x4 matrix.\n     *\n     * @param {Vec3} [x] - The vector to receive the x axis of the matrix.\n     * @returns {Vec3} The x-axis of the specified 4x4 matrix.\n     * @example\n     * // Create a 4x4 matrix\n     * var m = new pc.Mat4();\n     *\n     * // Query the z-axis component\n     * var x = new pc.Vec3();\n     * m.getX(x);\n     */\n    getX(x = new Vec3()) {\n        return x.set(this.data[0], this.data[1], this.data[2]);\n    }\n    /**\n     * Extracts the y-axis from the specified 4x4 matrix.\n     *\n     * @param {Vec3} [y] - The vector to receive the y axis of the matrix.\n     * @returns {Vec3} The y-axis of the specified 4x4 matrix.\n     * @example\n     * // Create a 4x4 matrix\n     * var m = new pc.Mat4();\n     *\n     * // Query the z-axis component\n     * var y = new pc.Vec3();\n     * m.getY(y);\n     */\n    getY(y = new Vec3()) {\n        return y.set(this.data[4], this.data[5], this.data[6]);\n    }\n    /**\n     * Extracts the z-axis from the specified 4x4 matrix.\n     *\n     * @param {Vec3} [z] - The vector to receive the z axis of the matrix.\n     * @returns {Vec3} The z-axis of the specified 4x4 matrix.\n     * @example\n     * // Create a 4x4 matrix\n     * var m = new pc.Mat4();\n     *\n     * // Query the z-axis component\n     * var z = new pc.Vec3();\n     * m.getZ(z);\n     */\n    getZ(z = new Vec3()) {\n        return z.set(this.data[8], this.data[9], this.data[10]);\n    }\n    /**\n     * Extracts the scale component from the specified 4x4 matrix.\n     *\n     * @param {Vec3} [scale] - Vector to receive the scale.\n     * @returns {Vec3} The scale in X, Y and Z of the specified 4x4 matrix.\n     * @example\n     * // Query the scale component\n     * var scale = m.getScale();\n     */\n    getScale(scale = new Vec3()) {\n        this.getX(x);\n        this.getY(y);\n        this.getZ(z);\n        scale.set(x.length(), y.length(), z.length());\n        return scale;\n    }\n    /**\n     * Sets the specified matrix to a rotation matrix defined by Euler angles. The Euler angles are\n     * specified in XYZ order and in degrees.\n     *\n     * @param {number} ex - Angle to rotate around X axis in degrees.\n     * @param {number} ey - Angle to rotate around Y axis in degrees.\n     * @param {number} ez - Angle to rotate around Z axis in degrees.\n     * @returns {Mat4} Self for chaining.\n     * @example\n     * var m = new pc.Mat4();\n     * m.setFromEulerAngles(45, 90, 180);\n     */\n    setFromEulerAngles(ex, ey, ez) {\n        // http://en.wikipedia.org/wiki/Rotation_matrix#Conversion_from_and_to_axis-angle\n        // The 3D space is right-handed, so the rotation around each axis will be counterclockwise\n        // for an observer placed so that the axis goes in his or her direction (Right-hand rule).\n        ex *= MathTool.DEG_TO_RAD;\n        ey *= MathTool.DEG_TO_RAD;\n        ez *= MathTool.DEG_TO_RAD;\n        // Solution taken from http://en.wikipedia.org/wiki/Euler_angles#Matrix_orientation\n        const s1 = Math.sin(-ex);\n        const c1 = Math.cos(-ex);\n        const s2 = Math.sin(-ey);\n        const c2 = Math.cos(-ey);\n        const s3 = Math.sin(-ez);\n        const c3 = Math.cos(-ez);\n        const m = this.data;\n        // Set rotation elements\n        m[0] = c2 * c3;\n        m[1] = -c2 * s3;\n        m[2] = s2;\n        m[3] = 0;\n        m[4] = c1 * s3 + c3 * s1 * s2;\n        m[5] = c1 * c3 - s1 * s2 * s3;\n        m[6] = -c2 * s1;\n        m[7] = 0;\n        m[8] = s1 * s3 - c1 * c3 * s2;\n        m[9] = c3 * s1 + c1 * s2 * s3;\n        m[10] = c1 * c2;\n        m[11] = 0;\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n        return this;\n    }\n    /**\n     * Extracts the Euler angles equivalent to the rotational portion of the specified matrix. The\n     * returned Euler angles are in XYZ order an in degrees.\n     *\n     * @param {Vec3} [eulers] - A 3-d vector to receive the Euler angles.\n     * @returns {Vec3} A 3-d vector containing the Euler angles.\n     * @example\n     * // Create a 4x4 rotation matrix of 45 degrees around the y-axis\n     * var m = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 45);\n     *\n     * var eulers = m.getEulerAngles();\n     */\n    getEulerAngles(eulers = new Vec3()) {\n        this.getScale(scale);\n        const sx = scale.x;\n        const sy = scale.y;\n        const sz = scale.z;\n        if (sx === 0 || sy === 0 || sz === 0)\n            return eulers.set(0, 0, 0);\n        const m = this.data;\n        const y = Math.asin(-m[2] / sx);\n        const halfPi = Math.PI * 0.5;\n        let x, z;\n        if (y < halfPi) {\n            if (y > -halfPi) {\n                x = Math.atan2(m[6] / sy, m[10] / sz);\n                z = Math.atan2(m[1] / sx, m[0] / sx);\n            }\n            else {\n                // Not a unique solution\n                z = 0;\n                x = -Math.atan2(m[4] / sy, m[5] / sy);\n            }\n        }\n        else {\n            // Not a unique solution\n            z = 0;\n            x = Math.atan2(m[4] / sy, m[5] / sy);\n        }\n        return eulers.set(x, y, z).mulScalar(MathTool.RAD_TO_DEG);\n    }\n    /**\n     * Converts the specified matrix to string form.\n     *\n     * @returns {string} The matrix in string form.\n     * @example\n     * var m = new pc.Mat4();\n     * // Outputs [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]\n     * console.log(m.toString());\n     */\n    toString() {\n        let t = \"[\";\n        for (let i = 0; i < 16; i += 1) {\n            t += this.data[i];\n            t += i !== 15 ? \", \" : \"\";\n        }\n        t += \"]\";\n        return t;\n    }\n    determinant() {\n        const te = this.data;\n        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n        //TODO: make this more efficient\n        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n        return (n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) +\n            n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) +\n            n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) +\n            n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31));\n    }\n    compose(position, quaternion, scale) {\n        const te = this.data;\n        const x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;\n        const x2 = x + x, y2 = y + y, z2 = z + z;\n        const xx = x * x2, xy = x * y2, xz = x * z2;\n        const yy = y * y2, yz = y * z2, zz = z * z2;\n        const wx = w * x2, wy = w * y2, wz = w * z2;\n        const sx = scale.x, sy = scale.y, sz = scale.z;\n        te[0] = (1 - (yy + zz)) * sx;\n        te[1] = (xy + wz) * sx;\n        te[2] = (xz - wy) * sx;\n        te[3] = 0;\n        te[4] = (xy - wz) * sy;\n        te[5] = (1 - (xx + zz)) * sy;\n        te[6] = (yz + wx) * sy;\n        te[7] = 0;\n        te[8] = (xz + wy) * sz;\n        te[9] = (yz - wx) * sz;\n        te[10] = (1 - (xx + yy)) * sz;\n        te[11] = 0;\n        te[12] = position.x;\n        te[13] = position.y;\n        te[14] = position.z;\n        te[15] = 1;\n        return this;\n    }\n    decompose(position, quaternion, scale) {\n        const te = this.data;\n        let sx = _v1.set(te[0], te[1], te[2]).length();\n        const sy = _v1.set(te[4], te[5], te[6]).length();\n        const sz = _v1.set(te[8], te[9], te[10]).length();\n        // if determine is negative, we need to invert one scale\n        const det = this.determinant();\n        if (det < 0)\n            sx = -sx;\n        position.x = te[12];\n        position.y = te[13];\n        position.z = te[14];\n        // scale the rotation part\n        _m1.copy(this);\n        const invSX = 1 / sx;\n        const invSY = 1 / sy;\n        const invSZ = 1 / sz;\n        _m1.data[0] *= invSX;\n        _m1.data[1] *= invSX;\n        _m1.data[2] *= invSX;\n        _m1.data[4] *= invSY;\n        _m1.data[5] *= invSY;\n        _m1.data[6] *= invSY;\n        _m1.data[8] *= invSZ;\n        _m1.data[9] *= invSZ;\n        _m1.data[10] *= invSZ;\n        quaternion.setFromMat4(_m1);\n        scale.x = sx;\n        scale.y = sy;\n        scale.z = sz;\n        return this;\n    }\n}\n/**\n * A constant matrix set to the identity.\n *\n * @type {Mat4}\n * @readonly\n */\nMat4.IDENTITY = Object.freeze(new Mat4());\n/**\n * A constant matrix with all elements set to 0.\n *\n * @type {Mat4}\n * @readonly\n */\nMat4.ZERO = Object.freeze(new Mat4().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));\nconst _m1 = /*@__PURE__*/ new Mat4();\nconst _zero = /*@__PURE__*/ new Vec3(0, 0, 0);\nconst _one = /*@__PURE__*/ new Vec3(1, 1, 1);\nexport { Mat4 };\n","/** @typedef {import('./mat4.js').Mat4} Mat4 */\nimport { MathTool } from \"./math.tool\";\nimport { Vec3 } from \"./math.vec3\";\n/**\n * A quaternion.\n */\nclass Quat {\n    /**\n     * Create a new Quat instance.\n     *\n     * @param {number} [x] - The quaternion's x component. Defaults to 0. If x is an array\n     * of length 4, the array will be used to populate all components.\n     * @param {number} [y] - The quaternion's y component. Defaults to 0.\n     * @param {number} [z] - The quaternion's z component. Defaults to 0.\n     * @param {number} [w] - The quaternion's w component. Defaults to 1.\n     */\n    constructor(x = 0, y = 0, z = 0, w = 1) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    /**\n     * Returns an identical copy of the specified quaternion.\n     *\n     * @returns {Quat} A quaternion containing the result of the cloning.\n     * @example\n     * var q = new pc.Quat(-0.11, -0.15, -0.46, 0.87);\n     * var qclone = q.clone();\n     *\n     * console.log(\"The result of the cloning is: \" + q.toString());\n     */\n    clone() {\n        return new Quat(this.x, this.y, this.z, this.w);\n    }\n    conjugate() {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        return this;\n    }\n    /**\n     * Copies the contents of a source quaternion to a destination quaternion.\n     *\n     * @param {Quat} rhs - The quaternion to be copied.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var src = new pc.Quat();\n     * var dst = new pc.Quat();\n     * dst.copy(src, src);\n     * console.log(\"The two quaternions are \" + (src.equals(dst) ? \"equal\" : \"different\"));\n     */\n    copy(rhs) {\n        this.x = rhs.x;\n        this.y = rhs.y;\n        this.z = rhs.z;\n        this.w = rhs.w;\n        return this;\n    }\n    /**\n     * Reports whether two quaternions are equal.\n     *\n     * @param {Quat} rhs - The quaternion to be compared against.\n     * @returns {boolean} True if the quaternions are equal and false otherwise.\n     * @example\n     * var a = new pc.Quat();\n     * var b = new pc.Quat();\n     * console.log(\"The two quaternions are \" + (a.equals(b) ? \"equal\" : \"different\"));\n     */\n    equals(rhs) {\n        return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;\n    }\n    /**\n     * Gets the rotation axis and angle for a given quaternion. If a quaternion is created with\n     * `setFromAxisAngle`, this method will return the same values as provided in the original\n     * parameter list OR functionally equivalent values.\n     *\n     * @param {Vec3} axis - The 3-dimensional vector to receive the axis of rotation.\n     * @returns {number} Angle, in degrees, of the rotation.\n     * @example\n     * var q = new pc.Quat();\n     * q.setFromAxisAngle(new pc.Vec3(0, 1, 0), 90);\n     * var v = new pc.Vec3();\n     * var angle = q.getAxisAngle(v);\n     * // Outputs 90\n     * console.log(angle);\n     * // Outputs [0, 1, 0]\n     * console.log(v.toString());\n     */\n    getAxisAngle(axis) {\n        let rad = Math.acos(this.w) * 2;\n        const s = Math.sin(rad / 2);\n        if (s !== 0) {\n            axis.x = this.x / s;\n            axis.y = this.y / s;\n            axis.z = this.z / s;\n            if (axis.x < 0 || axis.y < 0 || axis.z < 0) {\n                // Flip the sign\n                axis.x *= -1;\n                axis.y *= -1;\n                axis.z *= -1;\n                rad *= -1;\n            }\n        }\n        else {\n            // If s is zero, return any axis (no rotation - axis does not matter)\n            axis.x = 1;\n            axis.y = 0;\n            axis.z = 0;\n        }\n        return rad * MathTool.RAD_TO_DEG;\n    }\n    /**\n     * Converts the supplied quaternion to Euler angles.\n     *\n     * @param {Vec3} [eulers] - The 3-dimensional vector to receive the Euler angles.\n     * @returns {Vec3} The 3-dimensional vector holding the Euler angles that\n     * correspond to the supplied quaternion.\n     */\n    getEulerAngles(eulers = new Vec3()) {\n        let x, y, z;\n        const qx = this.x;\n        const qy = this.y;\n        const qz = this.z;\n        const qw = this.w;\n        const a2 = 2 * (qw * qy - qx * qz);\n        if (a2 <= -0.99999) {\n            x = 2 * Math.atan2(qx, qw);\n            y = -Math.PI / 2;\n            z = 0;\n        }\n        else if (a2 >= 0.99999) {\n            x = 2 * Math.atan2(qx, qw);\n            y = Math.PI / 2;\n            z = 0;\n        }\n        else {\n            x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));\n            y = Math.asin(a2);\n            z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));\n        }\n        return eulers.set(x, y, z).mulScalar(MathTool.RAD_TO_DEG);\n    }\n    /**\n     * Generates the inverse of the specified quaternion.\n     *\n     * @returns {Quat} Self for chaining.\n     * @example\n     * // Create a quaternion rotated 180 degrees around the y-axis\n     * var rot = new pc.Quat().setFromEulerAngles(0, 180, 0);\n     *\n     * // Invert in place\n     * rot.invert();\n     */\n    invert() {\n        return this.conjugate().normalize();\n    }\n    /**\n     * Returns the magnitude of the specified quaternion.\n     *\n     * @returns {number} The magnitude of the specified quaternion.\n     * @example\n     * var q = new pc.Quat(0, 0, 0, 5);\n     * var len = q.length();\n     * // Outputs 5\n     * console.log(\"The length of the quaternion is: \" + len);\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    /**\n     * Returns the magnitude squared of the specified quaternion.\n     *\n     * @returns {number} The magnitude of the specified quaternion.\n     * @example\n     * var q = new pc.Quat(3, 4, 0);\n     * var lenSq = q.lengthSq();\n     * // Outputs 25\n     * console.log(\"The length squared of the quaternion is: \" + lenSq);\n     */\n    lengthSq() {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    /**\n     * Returns the result of multiplying the specified quaternions together.\n     *\n     * @param {Quat} rhs - The quaternion used as the second multiplicand of the operation.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var a = new pc.Quat().setFromEulerAngles(0, 30, 0);\n     * var b = new pc.Quat().setFromEulerAngles(0, 60, 0);\n     *\n     * // a becomes a 90 degree rotation around the Y axis\n     * // In other words, a = a * b\n     * a.mul(b);\n     *\n     * console.log(\"The result of the multiplication is: \" + a.toString());\n     */\n    mul(rhs) {\n        const q1x = this.x;\n        const q1y = this.y;\n        const q1z = this.z;\n        const q1w = this.w;\n        const q2x = rhs.x;\n        const q2y = rhs.y;\n        const q2z = rhs.z;\n        const q2w = rhs.w;\n        this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\n        this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\n        this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\n        this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\n        return this;\n    }\n    /**\n     * Returns the result of multiplying the specified quaternions together.\n     *\n     * @param {Quat} lhs - The quaternion used as the first multiplicand of the operation.\n     * @param {Quat} rhs - The quaternion used as the second multiplicand of the operation.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var a = new pc.Quat().setFromEulerAngles(0, 30, 0);\n     * var b = new pc.Quat().setFromEulerAngles(0, 60, 0);\n     * var r = new pc.Quat();\n     *\n     * // r is set to a 90 degree rotation around the Y axis\n     * // In other words, r = a * b\n     * r.mul2(a, b);\n     *\n     * console.log(\"The result of the multiplication is: \" + r.toString());\n     */\n    mul2(lhs, rhs) {\n        const q1x = lhs.x;\n        const q1y = lhs.y;\n        const q1z = lhs.z;\n        const q1w = lhs.w;\n        const q2x = rhs.x;\n        const q2y = rhs.y;\n        const q2z = rhs.z;\n        const q2w = rhs.w;\n        this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\n        this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\n        this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\n        this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\n        return this;\n    }\n    /**\n     * Returns the specified quaternion converted in place to a unit quaternion.\n     *\n     * @returns {Quat} The result of the normalization.\n     * @example\n     * var v = new pc.Quat(0, 0, 0, 5);\n     *\n     * v.normalize();\n     *\n     * // Outputs 0, 0, 0, 1\n     * console.log(\"The result of the vector normalization is: \" + v.toString());\n     */\n    normalize() {\n        let len = this.length();\n        if (len === 0) {\n            this.x = this.y = this.z = 0;\n            this.w = 1;\n        }\n        else {\n            len = 1 / len;\n            this.x *= len;\n            this.y *= len;\n            this.z *= len;\n            this.w *= len;\n        }\n        return this;\n    }\n    /**\n     * Sets the specified quaternion to the supplied numerical values.\n     *\n     * @param {number} x - The x component of the quaternion.\n     * @param {number} y - The y component of the quaternion.\n     * @param {number} z - The z component of the quaternion.\n     * @param {number} w - The w component of the quaternion.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var q = new pc.Quat();\n     * q.set(1, 0, 0, 0);\n     *\n     * // Outputs 1, 0, 0, 0\n     * console.log(\"The result of the vector set is: \" + q.toString());\n     */\n    set(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    }\n    /**\n     * Sets a quaternion from an angular rotation around an axis.\n     *\n     * @param {Vec3} axis - World space axis around which to rotate.\n     * @param {number} angle - Angle to rotate around the given axis in degrees.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var q = new pc.Quat();\n     * q.setFromAxisAngle(pc.Vec3.UP, Math.PI/2);\n     */\n    setFromAxisAngle(axis, angle) {\n        angle *= 0.5;\n        const sa = Math.sin(angle);\n        const ca = Math.cos(angle);\n        this.x = sa * axis.x;\n        this.y = sa * axis.y;\n        this.z = sa * axis.z;\n        this.w = ca;\n        return this;\n    }\n    /**\n     * Sets a quaternion from Euler angles specified in XYZ order.\n     *\n     * @param {number} ex - Angle to rotate around X axis in degrees.\n     * @param {number} ey - Angle to rotate around Y axis in degrees.\n     * @param {number} ez - Angle to rotate around Z axis in degrees.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var q = new pc.Quat();\n     * q.setFromEulerAngles(45, 90, 180);\n     */\n    setFromEulerAngles(ex, ey, ez) {\n        const halfToRad = 0.5 * MathTool.DEG_TO_RAD;\n        ex *= halfToRad;\n        ey *= halfToRad;\n        ez *= halfToRad;\n        const sx = Math.sin(ex);\n        const cx = Math.cos(ex);\n        const sy = Math.sin(ey);\n        const cy = Math.cos(ey);\n        const sz = Math.sin(ez);\n        const cz = Math.cos(ez);\n        this.x = sx * cy * cz - cx * sy * sz;\n        this.y = cx * sy * cz + sx * cy * sz;\n        this.z = cx * cy * sz - sx * sy * cz;\n        this.w = cx * cy * cz + sx * sy * sz;\n        return this;\n    }\n    /**\n     *\n     * @param euler \n     * @returns\n     */\n    setFromEuler(euler) {\n        if (!(euler && euler.isEuler)) {\n            throw new Error(\"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.\");\n        }\n        const x = euler.x, y = euler.y, z = euler.z;\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n        const cos = Math.cos;\n        const sin = Math.sin;\n        const c1 = cos(x / 2);\n        const c2 = cos(y / 2);\n        const c3 = cos(z / 2);\n        const s1 = sin(x / 2);\n        const s2 = sin(y / 2);\n        const s3 = sin(z / 2);\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n        return this;\n    }\n    /**\n     * Converts the specified 4x4 matrix to a quaternion. Note that since a quaternion is purely a\n     * representation for orientation, only the translational part of the matrix is lost.\n     *\n     * @param {Mat4} m - The 4x4 matrix to convert.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * // Create a 4x4 rotation matrix of 180 degrees around the y-axis\n     * var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);\n     *\n     * // Convert to a quaternion\n     * var q = new pc.Quat().setFromMat4(rot);\n     */\n    setFromMat4(m) {\n        let m00, m01, m02, m10, m11, m12, m20, m21, m22, s, rs, lx, ly, lz;\n        var mData = m.data;\n        // Cache matrix values for super-speed\n        m00 = mData[0];\n        m01 = mData[1];\n        m02 = mData[2];\n        m10 = mData[4];\n        m11 = mData[5];\n        m12 = mData[6];\n        m20 = mData[8];\n        m21 = mData[9];\n        m22 = mData[10];\n        // Remove the scale from the matrix\n        lx = m00 * m00 + m01 * m01 + m02 * m02;\n        if (lx === 0)\n            return this;\n        lx = 1 / Math.sqrt(lx);\n        ly = m10 * m10 + m11 * m11 + m12 * m12;\n        if (ly === 0)\n            return this;\n        ly = 1 / Math.sqrt(ly);\n        lz = m20 * m20 + m21 * m21 + m22 * m22;\n        if (lz === 0)\n            return this;\n        lz = 1 / Math.sqrt(lz);\n        m00 *= lx;\n        m01 *= lx;\n        m02 *= lx;\n        m10 *= ly;\n        m11 *= ly;\n        m12 *= ly;\n        m20 *= lz;\n        m21 *= lz;\n        m22 *= lz;\n        // http://www.cs.ucr.edu/~vbz/resources/quatut.pdf\n        const tr = m00 + m11 + m22;\n        if (tr >= 0) {\n            s = Math.sqrt(tr + 1);\n            this.w = s * 0.5;\n            s = 0.5 / s;\n            this.x = (m12 - m21) * s;\n            this.y = (m20 - m02) * s;\n            this.z = (m01 - m10) * s;\n        }\n        else {\n            if (m00 > m11) {\n                if (m00 > m22) {\n                    // XDiagDomMatrix\n                    rs = m00 - (m11 + m22) + 1;\n                    rs = Math.sqrt(rs);\n                    this.x = rs * 0.5;\n                    rs = 0.5 / rs;\n                    this.w = (m12 - m21) * rs;\n                    this.y = (m01 + m10) * rs;\n                    this.z = (m02 + m20) * rs;\n                }\n                else {\n                    // ZDiagDomMatrix\n                    rs = m22 - (m00 + m11) + 1;\n                    rs = Math.sqrt(rs);\n                    this.z = rs * 0.5;\n                    rs = 0.5 / rs;\n                    this.w = (m01 - m10) * rs;\n                    this.x = (m20 + m02) * rs;\n                    this.y = (m21 + m12) * rs;\n                }\n            }\n            else if (m11 > m22) {\n                // YDiagDomMatrix\n                rs = m11 - (m22 + m00) + 1;\n                rs = Math.sqrt(rs);\n                this.y = rs * 0.5;\n                rs = 0.5 / rs;\n                this.w = (m20 - m02) * rs;\n                this.z = (m12 + m21) * rs;\n                this.x = (m10 + m01) * rs;\n            }\n            else {\n                // ZDiagDomMatrix\n                rs = m22 - (m00 + m11) + 1;\n                rs = Math.sqrt(rs);\n                this.z = rs * 0.5;\n                rs = 0.5 / rs;\n                this.w = (m01 - m10) * rs;\n                this.x = (m20 + m02) * rs;\n                this.y = (m21 + m12) * rs;\n            }\n        }\n        return this;\n    }\n    /**\n     * Performs a spherical interpolation between two quaternions. The result of the interpolation\n     * is written to the quaternion calling the function.\n     *\n     * @param {Quat} lhs - The quaternion to interpolate from.\n     * @param {Quat} rhs - The quaternion to interpolate to.\n     * @param {number} alpha - The value controlling the interpolation in relation to the two input\n     * quaternions. The value is in the range 0 to 1, 0 generating q1, 1 generating q2 and anything\n     * in between generating a spherical interpolation between the two.\n     * @returns {Quat} Self for chaining.\n     * @example\n     * var q1 = new pc.Quat(-0.11, -0.15, -0.46, 0.87);\n     * var q2 = new pc.Quat(-0.21, -0.21, -0.67, 0.68);\n     *\n     * var result;\n     * result = new pc.Quat().slerp(q1, q2, 0);   // Return q1\n     * result = new pc.Quat().slerp(q1, q2, 0.5); // Return the midpoint interpolant\n     * result = new pc.Quat().slerp(q1, q2, 1);   // Return q2\n     */\n    slerp(lhs, rhs, alpha) {\n        // Algorithm sourced from:\n        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n        const lx = lhs.x;\n        const ly = lhs.y;\n        const lz = lhs.z;\n        const lw = lhs.w;\n        let rx = rhs.x;\n        let ry = rhs.y;\n        let rz = rhs.z;\n        let rw = rhs.w;\n        // Calculate angle between them.\n        let cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;\n        if (cosHalfTheta < 0) {\n            rw = -rw;\n            rx = -rx;\n            ry = -ry;\n            rz = -rz;\n            cosHalfTheta = -cosHalfTheta;\n        }\n        // If lhs == rhs or lhs == -rhs then theta == 0 and we can return lhs\n        if (Math.abs(cosHalfTheta) >= 1) {\n            this.w = lw;\n            this.x = lx;\n            this.y = ly;\n            this.z = lz;\n            return this;\n        }\n        // Calculate temporary values.\n        const halfTheta = Math.acos(cosHalfTheta);\n        const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);\n        // If theta = 180 degrees then result is not fully defined\n        // we could rotate around any axis normal to qa or qb\n        if (Math.abs(sinHalfTheta) < 0.001) {\n            this.w = lw * 0.5 + rw * 0.5;\n            this.x = lx * 0.5 + rx * 0.5;\n            this.y = ly * 0.5 + ry * 0.5;\n            this.z = lz * 0.5 + rz * 0.5;\n            return this;\n        }\n        const ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;\n        const ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;\n        // Calculate Quaternion.\n        this.w = lw * ratioA + rw * ratioB;\n        this.x = lx * ratioA + rx * ratioB;\n        this.y = ly * ratioA + ry * ratioB;\n        this.z = lz * ratioA + rz * ratioB;\n        return this;\n    }\n    /**\n     * Transforms a 3-dimensional vector by the specified quaternion.\n     *\n     * @param {Vec3} vec - The 3-dimensional vector to be transformed.\n     * @param {Vec3} [res] - An optional 3-dimensional vector to receive the result of the transformation.\n     * @returns {Vec3} The input vector v transformed by the current instance.\n     * @example\n     * // Create a 3-dimensional vector\n     * var v = new pc.Vec3(1, 2, 3);\n     *\n     * // Create a 4x4 rotation matrix\n     * var q = new pc.Quat().setFromEulerAngles(10, 20, 30);\n     *\n     * var tv = q.transformVector(v);\n     */\n    transformVector(vec, res = new Vec3()) {\n        const x = vec.x, y = vec.y, z = vec.z;\n        const qx = this.x, qy = this.y, qz = this.z, qw = this.w;\n        // calculate quat * vec\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n        // calculate result * inverse quat\n        res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n        return res;\n    }\n    /**\n     * Converts the quaternion to string form.\n     *\n     * @returns {string} The quaternion in string form.\n     * @example\n     * var v = new pc.Quat(0, 0, 0, 1);\n     * // Outputs [0, 0, 0, 1]\n     * console.log(v.toString());\n     */\n    toString() {\n        return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;\n    }\n}\n/**\n * A constant quaternion set to [0, 0, 0, 1] (the identity).\n *\n * @type {Quat}\n * @readonly\n */\nQuat.IDENTITY = Object.freeze(new Quat(0, 0, 0, 1));\n/**\n * A constant quaternion set to [0, 0, 0, 0].\n *\n * @type {Quat}\n * @readonly\n */\nQuat.ZERO = Object.freeze(new Quat(0, 0, 0, 0));\nexport { Quat };\n","/**\n * Scalar computation library\n */\nexport class Scalar {\n    /**\n     * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n     * @param a number\n     * @param b number\n     * @param epsilon (default = 1.401298E-45)\n     * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n     */\n    static WithinEpsilon(a, b, epsilon = 1.401298E-45) {\n        return Math.abs(a - b) <= epsilon;\n    }\n    /**\n     * Returns a string : the upper case translation of the number i to hexadecimal.\n     * @param i number\n     * @returns the upper case translation of the number i to hexadecimal.\n     */\n    static ToHex(i) {\n        var str = i.toString(16);\n        if (i <= 15) {\n            return (\"0\" + str).toUpperCase();\n        }\n        return str.toUpperCase();\n    }\n    /**\n     * Returns -1 if value is negative and +1 is value is positive.\n     * @param value the value\n     * @returns the value itself if it's equal to zero.\n     */\n    static Sign(value) {\n        value = +value; // convert to a number\n        if (value === 0 || isNaN(value)) {\n            return value;\n        }\n        return value > 0 ? 1 : -1;\n    }\n    /**\n     * Returns the value itself if it's between min and max.\n     * Returns min if the value is lower than min.\n     * Returns max if the value is greater than max.\n     * @param value the value to clmap\n     * @param min the min value to clamp to (default: 0)\n     * @param max the max value to clamp to (default: 1)\n     * @returns the clamped value\n     */\n    static Clamp(value, min = 0, max = 1) {\n        return Math.min(max, Math.max(min, value));\n    }\n    /**\n     * the log2 of value.\n     * @param value the value to compute log2 of\n     * @returns the log2 of value.\n     */\n    static Log2(value) {\n        return Math.log(value) * Math.LOG2E;\n    }\n    /**\n     * the floor part of a log2 value.\n     * @param value the value to compute log2 of\n     * @returns the log2 of value.\n     */\n    static ILog2(value) {\n        if (Math.log2) {\n            return Math.floor(Math.log2(value));\n        }\n        if (value < 0) {\n            return NaN;\n        }\n        else if (value === 0) {\n            return -Infinity;\n        }\n        let n = 0;\n        if (value < 1) {\n            while (value < 1) {\n                n++;\n                value = value * 2;\n            }\n            n = -n;\n        }\n        else if (value > 1) {\n            while (value > 1) {\n                n++;\n                value = Math.floor(value / 2);\n            }\n        }\n        return n;\n    }\n    /**\n    * Loops the value, so that it is never larger than length and never smaller than 0.\n    *\n    * This is similar to the modulo operator but it works with floating point numbers.\n    * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\n    * With t = 5 and length = 2.5, the result would be 0.0.\n    * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\n    * @param value the value\n    * @param length the length\n    * @returns the looped value\n    */\n    static Repeat(value, length) {\n        return value - Math.floor(value / length) * length;\n    }\n    /**\n     * Normalize the value between 0.0 and 1.0 using min and max values\n     * @param value value to normalize\n     * @param min max to normalize between\n     * @param max min to normalize between\n     * @returns the normalized value\n     */\n    static Normalize(value, min, max) {\n        return (value - min) / (max - min);\n    }\n    /**\n    * Denormalize the value from 0.0 and 1.0 using min and max values\n    * @param normalized value to denormalize\n    * @param min max to denormalize between\n    * @param max min to denormalize between\n    * @returns the denormalized value\n    */\n    static Denormalize(normalized, min, max) {\n        return (normalized * (max - min) + min);\n    }\n    /**\n    * Calculates the shortest difference between two given angles given in degrees.\n    * @param current current angle in degrees\n    * @param target target angle in degrees\n    * @returns the delta\n    */\n    static DeltaAngle(current, target) {\n        var num = Scalar.Repeat(target - current, 360.0);\n        if (num > 180.0) {\n            num -= 360.0;\n        }\n        return num;\n    }\n    /**\n    * PingPongs the value t, so that it is never larger than length and never smaller than 0.\n    * @param tx value\n    * @param length length\n    * @returns The returned value will move back and forth between 0 and length\n    */\n    static PingPong(tx, length) {\n        var t = Scalar.Repeat(tx, length * 2.0);\n        return length - Math.abs(t - length);\n    }\n    /**\n    * Interpolates between min and max with smoothing at the limits.\n    *\n    * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\n    * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\n    * @param from from\n    * @param to to\n    * @param tx value\n    * @returns the smooth stepped value\n    */\n    static SmoothStep(from, to, tx) {\n        var t = Scalar.Clamp(tx);\n        t = -2.0 * t * t * t + 3.0 * t * t;\n        return to * t + from * (1.0 - t);\n    }\n    /**\n    * Moves a value current towards target.\n    *\n    * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\n    * Negative values of maxDelta pushes the value away from target.\n    * @param current current value\n    * @param target target value\n    * @param maxDelta max distance to move\n    * @returns resulting value\n    */\n    static MoveTowards(current, target, maxDelta) {\n        var result = 0;\n        if (Math.abs(target - current) <= maxDelta) {\n            result = target;\n        }\n        else {\n            result = current + Scalar.Sign(target - current) * maxDelta;\n        }\n        return result;\n    }\n    /**\n    * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\n    *\n    * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\n    *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\n    * @param current current value\n    * @param target target value\n    * @param maxDelta max distance to move\n    * @returns resulting angle\n    */\n    static MoveTowardsAngle(current, target, maxDelta) {\n        var num = Scalar.DeltaAngle(current, target);\n        var result = 0;\n        if (-maxDelta < num && num < maxDelta) {\n            result = target;\n        }\n        else {\n            target = current + num;\n            result = Scalar.MoveTowards(current, target, maxDelta);\n        }\n        return result;\n    }\n    /**\n     * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n     * @param start start value\n     * @param end target value\n     * @param amount amount to lerp between\n     * @returns the lerped value\n     */\n    static Lerp(start, end, amount) {\n        return start + ((end - start) * amount);\n    }\n    /**\n    * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\n    * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\n    * @param start start value\n    * @param end target value\n    * @param amount amount to lerp between\n    * @returns the lerped value\n    */\n    static LerpAngle(start, end, amount) {\n        var num = Scalar.Repeat(end - start, 360.0);\n        if (num > 180.0) {\n            num -= 360.0;\n        }\n        return start + num * Scalar.Clamp(amount);\n    }\n    /**\n    * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\n    * @param a start value\n    * @param b target value\n    * @param value value between a and b\n    * @returns the inverseLerp value\n    */\n    static InverseLerp(a, b, value) {\n        var result = 0;\n        if (a != b) {\n            result = Scalar.Clamp((value - a) / (b - a));\n        }\n        else {\n            result = 0.0;\n        }\n        return result;\n    }\n    /**\n     * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n     * @see http://mathworld.wolfram.com/HermitePolynomial.html\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\n     * @returns hermite result\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        var squared = amount * amount;\n        var cubed = amount * squared;\n        var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\n        var part2 = (-2.0 * cubed) + (3.0 * squared);\n        var part3 = (cubed - (2.0 * squared)) + amount;\n        var part4 = cubed - squared;\n        return (((value1 * part1) + (value2 * part2)) + (tangent1 * part3)) + (tangent2 * part4);\n    }\n    /**\n     * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n        const t2 = time * time;\n        return ((t2 - time) * 6 * value1 +\n            (3 * t2 - 4 * time + 1) * tangent1 +\n            (-t2 + time) * 6 * value2 +\n            (3 * t2 - 2 * time) * tangent2);\n    }\n    /**\n    * Returns a random float number between and min and max values\n    * @param min min value of random\n    * @param max max value of random\n    * @returns random value\n    */\n    static RandomRange(min, max) {\n        if (min === max) {\n            return min;\n        }\n        return ((Math.random() * (max - min)) + min);\n    }\n    /**\n    * This function returns percentage of a number in a given range.\n    *\n    * RangeToPercent(40,20,60) will return 0.5 (50%)\n    * RangeToPercent(34,0,100) will return 0.34 (34%)\n    * @param number to convert to percentage\n    * @param min min range\n    * @param max max range\n    * @returns the percentage\n    */\n    static RangeToPercent(number, min, max) {\n        return ((number - min) / (max - min));\n    }\n    /**\n    * This function returns number that corresponds to the percentage in a given range.\n    *\n    * PercentToRange(0.34,0,100) will return 34.\n    * @param percent to convert to number\n    * @param min min range\n    * @param max max range\n    * @returns the number\n    */\n    static PercentToRange(percent, min, max) {\n        return ((max - min) * percent + min);\n    }\n    /**\n     * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\n     * @param angle The angle to normalize in radian.\n     * @return The converted angle.\n     */\n    static NormalizeRadians(angle) {\n        // More precise but slower version kept for reference.\n        // angle = angle % Tools.TwoPi;\n        // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\n        //if (angle > Math.PI) {\n        //\tangle -= Tools.TwoPi;\n        //}\n        angle -= (Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi));\n        return angle;\n    }\n    /**\n     * Returns the highest common factor of two integers.\n     * @param a first parameter\n     * @param b second parameter\n     * @return HCF of a and b\n     */\n    static HCF(a, b) {\n        const r = a % b;\n        if (r === 0) {\n            return b;\n        }\n        return Scalar.HCF(b, r);\n    }\n}\n/**\n * Two pi constants convenient for computation.\n */\nScalar.TwoPi = Math.PI * 2;\n","import { DEG2RAD, RAD2DEG } from \"./math.constants\";\n/**\n * @name math\n * @namespace\n * @description Math API.\n */\nexport class MathTool {\n    // \n    static degToRad(degrees) {\n        return degrees * DEG2RAD;\n    }\n    static radToDeg(radians) {\n        return radians * RAD2DEG;\n    }\n    /**\n     * @function\n     * @name math.clamp\n     * @description Clamp a number between min and max inclusive.\n     * @param {number} value - Number to clamp.\n     * @param {number} min - Min value.\n     * @param {number} max - Max value.\n     * @returns {number} The clamped value.\n     */\n    static clamp(value, min, max) {\n        if (value >= max)\n            return max;\n        if (value <= min)\n            return min;\n        return value;\n    }\n    /**\n     * @function\n     * @name math.intToBytes24\n     * @description Convert an 24 bit integer into an array of 3 bytes.\n     * @param {number} i - Number holding an integer value.\n     * @returns {number[]} An array of 3 bytes.\n     * @example\n     * // Set bytes to [0x11, 0x22, 0x33]\n     * var bytes = pc.math.intToBytes24(0x112233);\n     */\n    static intToBytes24(i) {\n        var r, g, b;\n        r = (i >> 16) & 0xff;\n        g = (i >> 8) & 0xff;\n        b = i & 0xff;\n        return [r, g, b];\n    }\n    /**\n     * @function\n     * @name math.intToBytes32\n     * @description Convert an 32 bit integer into an array of 4 bytes.\n     * @returns {number[]} An array of 4 bytes.\n     * @param {number} i - Number holding an integer value.\n     * @example\n     * // Set bytes to [0x11, 0x22, 0x33, 0x44]\n     * var bytes = pc.math.intToBytes32(0x11223344);\n     */\n    static intToBytes32(i) {\n        var r, g, b, a;\n        r = (i >> 24) & 0xff;\n        g = (i >> 16) & 0xff;\n        b = (i >> 8) & 0xff;\n        a = i & 0xff;\n        return [r, g, b, a];\n    }\n    /**\n     * @function\n     * @name math.bytesToInt24\n     * @description Convert 3 8 bit Numbers into a single unsigned 24 bit Number.\n     * @example\n     * // Set result1 to 0x112233 from an array of 3 values\n     * var result1 = pc.math.bytesToInt24([0x11, 0x22, 0x33]);\n     *\n     * // Set result2 to 0x112233 from 3 discrete values\n     * var result2 = pc.math.bytesToInt24(0x11, 0x22, 0x33);\n     * @param {number} r - A single byte (0-255).\n     * @param {number} g - A single byte (0-255).\n     * @param {number} b - A single byte (0-255).\n     * @returns {number} A single unsigned 24 bit Number.\n     */\n    static bytesToInt24(bytes) {\n        const b = bytes[2];\n        const g = bytes[1];\n        const r = bytes[0];\n        return (r << 16) | (g << 8) | b;\n    }\n    /**\n     * @function\n     * @name math.bytesToInt32\n     * @description Convert 4 1-byte Numbers into a single unsigned 32bit Number.\n     * @returns {number} A single unsigned 32bit Number.\n     * @example\n     * // Set result1 to 0x11223344 from an array of 4 values\n     * var result1 = pc.math.bytesToInt32([0x11, 0x22, 0x33, 0x44]);\n     *\n     * // Set result2 to 0x11223344 from 4 discrete values\n     * var result2 = pc.math.bytesToInt32(0x11, 0x22, 0x33, 0x44);\n     * @param {number} r - A single byte (0-255).\n     * @param {number} g - A single byte (0-255).\n     * @param {number} b - A single byte (0-255).\n     * @param {number} a - A single byte (0-255).\n     */\n    static bytesToInt32(bytes) {\n        const a = bytes[3];\n        const b = bytes[2];\n        const g = bytes[1];\n        const r = bytes[0];\n        // Why ((r << 24)>>>32)?\n        // << operator uses signed 32 bit numbers, so 128<<24 is negative.\n        // >>> used unsigned so >>>32 converts back to an unsigned.\n        // See http://stackoverflow.com/questions/1908492/unsigned-integer-in-javascript\n        return ((r << 24) | (g << 16) | (b << 8) | a) >>> 32;\n    }\n    /**\n     * @function\n     * @name math.lerp\n     * @returns {number} The linear interpolation of two numbers.\n     * @description Calculates the linear interpolation of two numbers.\n     * @param {number} a - Number to linearly interpolate from.\n     * @param {number} b - Number to linearly interpolate to.\n     * @param {number} alpha - The value controlling the result of interpolation. When alpha is 0,\n     * a is returned. When alpha is 1, b is returned. Between 0 and 1, a linear interpolation between\n     * a and b is returned. alpha is clamped between 0 and 1.\n     */\n    static lerp(a, b, alpha) {\n        return a + (b - a) * MathTool.clamp(alpha, 0, 1);\n    }\n    /**\n     * @function\n     * @name math.lerpAngle\n     * @description Calculates the linear interpolation of two angles ensuring that interpolation\n     * is correctly performed across the 360 to 0 degree boundary. Angles are supplied in degrees.\n     * @returns {number} The linear interpolation of two angles.\n     * @param {number} a - Angle (in degrees) to linearly interpolate from.\n     * @param {number} b - Angle (in degrees) to linearly interpolate to.\n     * @param {number} alpha - The value controlling the result of interpolation. When alpha is 0,\n     * a is returned. When alpha is 1, b is returned. Between 0 and 1, a linear interpolation between\n     * a and b is returned. alpha is clamped between 0 and 1.\n     */\n    static lerpAngle(a, b, alpha) {\n        if (b - a > 180) {\n            b -= 360;\n        }\n        if (b - a < -180) {\n            b += 360;\n        }\n        return MathTool.lerp(a, b, MathTool.clamp(alpha, 0, 1));\n    }\n    /**\n     * @function\n     * @name math.powerOfTwo\n     * @description Returns true if argument is a power-of-two and false otherwise.\n     * @param {number} x - Number to check for power-of-two property.\n     * @returns {boolean} True if power-of-two and false otherwise.\n     */\n    static powerOfTwo(x) {\n        return x !== 0 && !(x & (x - 1));\n    }\n    /**\n     * @function\n     * @name math.nextPowerOfTwo\n     * @description Returns the next power of 2 for the specified value.\n     * @param {number} val - The value for which to calculate the next power of 2.\n     * @returns {number} The next power of 2.\n     */\n    static nextPowerOfTwo(val) {\n        val--;\n        val |= val >> 1;\n        val |= val >> 2;\n        val |= val >> 4;\n        val |= val >> 8;\n        val |= val >> 16;\n        val++;\n        return val;\n    }\n    /**\n     * @function\n     * @name math.random\n     * @description Return a pseudo-random number between min and max.\n     * The number generated is in the range [min, max), that is inclusive of the minimum but exclusive of the maximum.\n     * @param {number} min - Lower bound for range.\n     * @param {number} max - Upper bound for range.\n     * @returns {number} Pseudo-random number between the supplied range.\n     */\n    static random(min, max) {\n        var diff = max - min;\n        return Math.random() * diff + min;\n    }\n    /**\n     * @function\n     * @name math.smoothstep\n     * @description The function interpolates smoothly between two input values based on\n     * a third one that should be between the first two. The returned value is clamped\n     * between 0 and 1.\n     * <br/>The slope (i.e. derivative) of the smoothstep function starts at 0 and ends at 0.\n     * This makes it easy to create a sequence of transitions using smoothstep to interpolate\n     * each segment rather than using a more sophisticated or expensive interpolation technique.\n     * <br/>See http://en.wikipedia.org/wiki/Smoothstep for more details.\n     * @param {number} min - The lower bound of the interpolation range.\n     * @param {number} max - The upper bound of the interpolation range.\n     * @param {number} x - The value to interpolate.\n     * @returns {number} The smoothly interpolated value clamped between zero and one.\n     */\n    static smoothstep(min, max, x) {\n        if (x <= min)\n            return 0;\n        if (x >= max)\n            return 1;\n        x = (x - min) / (max - min);\n        return x * x * (3 - 2 * x);\n    }\n    /**\n     * @function\n     * @name math.smootherstep\n     * @description An improved version of the {@link math.smoothstep} function which has zero\n     * 1st and 2nd order derivatives at t=0 and t=1.\n     * <br/>See http://en.wikipedia.org/wiki/Smoothstep for more details.\n     * @param {number} min - The lower bound of the interpolation range.\n     * @param {number} max - The upper bound of the interpolation range.\n     * @param {number} x - The value to interpolate.\n     * @returns {number} The smoothly interpolated value clamped between zero and one.\n     */\n    static smootherstep(min, max, x) {\n        if (x <= min)\n            return 0;\n        if (x >= max)\n            return 1;\n        x = (x - min) / (max - min);\n        return x * x * x * (x * (x * 6 - 15) + 10);\n    }\n    /**\n     * @function\n     * @name math.roundUp\n     * @description Rounds a number up to nearest multiple.\n     * @param {number} numToRound - The number to round up.\n     * @param {number} multiple - The multiple to round up to.\n     * @returns {number} A number rounded up to nearest multiple.\n     */\n    static roundUp(numToRound, multiple) {\n        if (multiple === 0)\n            return numToRound;\n        return Math.ceil(numToRound / multiple) * multiple;\n    }\n    /**\n     * @function\n     * @name math.float2Half\n     * @description Converts float number to half float representation.\n     * @param {number} val - The float number.\n     * @returns {number} A 16 bit number representing half float representation as used by GPU.\n     */\n    static float2Half(val) {\n        // based on based on https://esdiscuss.org/topic/float16array\n        var floatView = new Float32Array(1);\n        var int32View = new Int32Array(floatView.buffer);\n        // This method is faster than the OpenEXR implementation (very often\n        // used, eg. in Ogre), with the additional benefit of rounding, inspired\n        // by James Tursa?s half-precision code.\n        floatView[0] = val;\n        var x = int32View[0];\n        var bits = (x >> 16) & 0x8000; // Get the sign\n        var m = (x >> 12) & 0x07ff; // Keep one extra bit for rounding\n        var e = (x >> 23) & 0xff; // Using int is faster here\n        // If zero, or denormal, or exponent underflows too much for a denormal half, return signed zero.\n        if (e < 103) {\n            return bits;\n        }\n        // If NaN, return NaN. If Inf or exponent overflow, return Inf.\n        if (e > 142) {\n            bits |= 0x7c00;\n            // If exponent was 0xff and one mantissa bit was set, it means NaN,\n            // not Inf, so make sure we set one mantissa bit too.\n            bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n            return bits;\n        }\n        // If exponent underflows but not too much, return a denormal\n        if (e < 113) {\n            m |= 0x0800;\n            // Extra rounding may overflow and set mantissa to 0 and exponent to 1, which is OK.\n            bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n            return bits;\n        }\n        bits |= ((e - 112) << 10) | (m >> 1);\n        // Extra rounding. An overflow will set mantissa to 0 and increment the exponent, which is OK.\n        bits += m & 1;\n        return bits;\n    }\n    /**\n     * @function\n     * @private\n     * @name math.between\n     * @description Checks whether a given number resides between two other given numbers.\n     * @returns {boolean} true if between or false otherwise.\n     * @param {number} num - The number to check the position of.\n     * @param {number} a - The first upper or lower threshold to check between.\n     * @param {number} b - The second upper or lower threshold to check between.\n     * @param {boolean} inclusive - If true, a num param which is equal to a or b will return true.\n     */\n    static between(num, a, b, inclusive) {\n        var min = Math.min(a, b), max = Math.max(a, b);\n        return inclusive ? num >= min && num <= max : num > min && num < max;\n    }\n    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n    static generateUUID() {\n        const d0 = (Math.random() * 0xffffffff) | 0;\n        const d1 = (Math.random() * 0xffffffff) | 0;\n        const d2 = (Math.random() * 0xffffffff) | 0;\n        const d3 = (Math.random() * 0xffffffff) | 0;\n        const _lut = [];\n        const uuid = _lut[d0 & 0xff] +\n            _lut[(d0 >> 8) & 0xff] +\n            _lut[(d0 >> 16) & 0xff] +\n            _lut[(d0 >> 24) & 0xff] +\n            \"-\" +\n            _lut[d1 & 0xff] +\n            _lut[(d1 >> 8) & 0xff] +\n            \"-\" +\n            _lut[((d1 >> 16) & 0x0f) | 0x40] +\n            _lut[(d1 >> 24) & 0xff] +\n            \"-\" +\n            _lut[(d2 & 0x3f) | 0x80] +\n            _lut[(d2 >> 8) & 0xff] +\n            \"-\" +\n            _lut[(d2 >> 16) & 0xff] +\n            _lut[(d2 >> 24) & 0xff] +\n            _lut[d3 & 0xff] +\n            _lut[(d3 >> 8) & 0xff] +\n            _lut[(d3 >> 16) & 0xff] +\n            _lut[(d3 >> 24) & 0xff];\n        // .toUpperCase() here flattens concatenated strings to save heap memory space.\n        return uuid.toUpperCase();\n    }\n    static zTween(_val, _target, _ratio) {\n        return Math.abs(_target - _val) < 0.00001 ? _target : _val + (_target - _val) * Math.min(_ratio, 1);\n    }\n}\n/**\n * @constant\n * @type {number}\n * @name math.DEG_TO_RAD\n * @description Conversion factor between degrees and radians.\n * @example\n * // Convert 180 degrees to pi radians\n * var rad = 180 * pc.math.DEG_TO_RAD;\n */\nMathTool.DEG_TO_RAD = Math.PI / 180;\n/**\n * @constant\n * @type {number}\n * @name math.RAD_TO_DEG\n * @description Conversion factor between degrees and radians.\n * @example\n * // Convert pi radians to 180 degrees\n * var deg = Math.PI * pc.math.RAD_TO_DEG;\n */\nMathTool.RAD_TO_DEG = 180 / Math.PI;\n","/**\n * A 2-dimensional vector.\n */\nexport class Vec2 {\n    /**\n     * Create a new Vec2 instance.\n     *\n     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 2, the\n     * array will be used to populate all components.\n     * @param {number} [y] - The y value. Defaults to 0.\n     * @example\n     * var v = new pc.Vec2(1, 2);\n     */\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Adds a 2-dimensional vector to another in place.\n     *\n     * @param {Vec2} rhs - The vector to add to the specified vector.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(10, 10);\n     * var b = new pc.Vec2(20, 20);\n     *\n     * a.add(b);\n     *\n     * // Outputs [30, 30]\n     * console.log(\"The result of the addition is: \" + a.toString());\n     */\n    add(rhs) {\n        this.x += rhs.x;\n        this.y += rhs.y;\n        return this;\n    }\n    /**\n     * Adds two 2-dimensional vectors together and returns the result.\n     *\n     * @param {Vec2} lhs - The first vector operand for the addition.\n     * @param {Vec2} rhs - The second vector operand for the addition.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(10, 10);\n     * var b = new pc.Vec2(20, 20);\n     * var r = new pc.Vec2();\n     *\n     * r.add2(a, b);\n     * // Outputs [30, 30]\n     *\n     * console.log(\"The result of the addition is: \" + r.toString());\n     */\n    add2(lhs, rhs) {\n        this.x = lhs.x + rhs.x;\n        this.y = lhs.y + rhs.y;\n        return this;\n    }\n    /**\n     * Adds a number to each element of a vector.\n     *\n     * @param {number} scalar - The number to add.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var vec = new pc.Vec2(3, 4);\n     *\n     * vec.addScalar(2);\n     *\n     * // Outputs [5, 6]\n     * console.log(\"The result of the addition is: \" + vec.toString());\n     */\n    addScalar(scalar) {\n        this.x += scalar;\n        this.y += scalar;\n        return this;\n    }\n    /**\n     * Returns an identical copy of the specified 2-dimensional vector.\n     *\n     * @returns {Vec2} A 2-dimensional vector containing the result of the cloning.\n     * @example\n     * var v = new pc.Vec2(10, 20);\n     * var vclone = v.clone();\n     * console.log(\"The result of the cloning is: \" + vclone.toString());\n     */\n    clone() {\n        return new Vec2(this.x, this.y);\n    }\n    /**\n     * Copies the contents of a source 2-dimensional vector to a destination 2-dimensional vector.\n     *\n     * @param {Vec2} rhs - A vector to copy to the specified vector.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var src = new pc.Vec2(10, 20);\n     * var dst = new pc.Vec2();\n     *\n     * dst.copy(src);\n     *\n     * console.log(\"The two vectors are \" + (dst.equals(src) ? \"equal\" : \"different\"));\n     */\n    copy(rhs) {\n        this.x = rhs.x;\n        this.y = rhs.y;\n        return this;\n    }\n    /**\n     * Returns the result of a cross product operation performed on the two specified 2-dimensional\n     * vectors.\n     *\n     * @param {Vec2} rhs - The second 2-dimensional vector operand of the cross product.\n     * @returns {number} The cross product of the two vectors.\n     * @example\n     * var right = new pc.Vec2(1, 0);\n     * var up = new pc.Vec2(0, 1);\n     * var crossProduct = right.cross(up);\n     *\n     * // Prints 1\n     * console.log(\"The result of the cross product is: \" + crossProduct);\n     */\n    cross(rhs) {\n        return this.x * rhs.y - this.y * rhs.x;\n    }\n    /**\n     * Returns the distance between the two specified 2-dimensional vectors.\n     *\n     * @param {Vec2} rhs - The second 2-dimensional vector to test.\n     * @returns {number} The distance between the two vectors.\n     * @example\n     * var v1 = new pc.Vec2(5, 10);\n     * var v2 = new pc.Vec2(10, 20);\n     * var d = v1.distance(v2);\n     * console.log(\"The distance between v1 and v2 is: \" + d);\n     */\n    distance(rhs) {\n        const x = this.x - rhs.x;\n        const y = this.y - rhs.y;\n        return Math.sqrt(x * x + y * y);\n    }\n    /**\n     * Divides a 2-dimensional vector by another in place.\n     *\n     * @param {Vec2} rhs - The vector to divide the specified vector by.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(4, 9);\n     * var b = new pc.Vec2(2, 3);\n     *\n     * a.div(b);\n     *\n     * // Outputs [2, 3]\n     * console.log(\"The result of the division is: \" + a.toString());\n     */\n    div(rhs) {\n        this.x /= rhs.x;\n        this.y /= rhs.y;\n        return this;\n    }\n    /**\n     * Divides one 2-dimensional vector by another and writes the result to the specified vector.\n     *\n     * @param {Vec2} lhs - The dividend vector (the vector being divided).\n     * @param {Vec2} rhs - The divisor vector (the vector dividing the dividend).\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(4, 9);\n     * var b = new pc.Vec2(2, 3);\n     * var r = new pc.Vec2();\n     *\n     * r.div2(a, b);\n     * // Outputs [2, 3]\n     *\n     * console.log(\"The result of the division is: \" + r.toString());\n     */\n    div2(lhs, rhs) {\n        this.x = lhs.x / rhs.x;\n        this.y = lhs.y / rhs.y;\n        return this;\n    }\n    /**\n     * Divides each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to divide by.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var vec = new pc.Vec2(3, 6);\n     *\n     * vec.divScalar(3);\n     *\n     * // Outputs [1, 2]\n     * console.log(\"The result of the division is: \" + vec.toString());\n     */\n    divScalar(scalar) {\n        this.x /= scalar;\n        this.y /= scalar;\n        return this;\n    }\n    /**\n     * Returns the result of a dot product operation performed on the two specified 2-dimensional\n     * vectors.\n     *\n     * @param {Vec2} rhs - The second 2-dimensional vector operand of the dot product.\n     * @returns {number} The result of the dot product operation.\n     * @example\n     * var v1 = new pc.Vec2(5, 10);\n     * var v2 = new pc.Vec2(10, 20);\n     * var v1dotv2 = v1.dot(v2);\n     * console.log(\"The result of the dot product is: \" + v1dotv2);\n     */\n    dot(rhs) {\n        return this.x * rhs.x + this.y * rhs.y;\n    }\n    /**\n     * Reports whether two vectors are equal.\n     *\n     * @param {Vec2} rhs - The vector to compare to the specified vector.\n     * @returns {boolean} True if the vectors are equal and false otherwise.\n     * @example\n     * var a = new pc.Vec2(1, 2);\n     * var b = new pc.Vec2(4, 5);\n     * console.log(\"The two vectors are \" + (a.equals(b) ? \"equal\" : \"different\"));\n     */\n    equals(rhs) {\n        return this.x === rhs.x && this.y === rhs.y;\n    }\n    /**\n     * Returns the magnitude of the specified 2-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 2-dimensional vector.\n     * @example\n     * var vec = new pc.Vec2(3, 4);\n     * var len = vec.length();\n     * // Outputs 5\n     * console.log(\"The length of the vector is: \" + len);\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    /**\n     * Returns the magnitude squared of the specified 2-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 2-dimensional vector.\n     * @example\n     * var vec = new pc.Vec2(3, 4);\n     * var len = vec.lengthSq();\n     * // Outputs 25\n     * console.log(\"The length squared of the vector is: \" + len);\n     */\n    lengthSq() {\n        return this.x * this.x + this.y * this.y;\n    }\n    /**\n     * Returns the result of a linear interpolation between two specified 2-dimensional vectors.\n     *\n     * @param {Vec2} lhs - The 2-dimensional to interpolate from.\n     * @param {Vec2} rhs - The 2-dimensional to interpolate to.\n     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,\n     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this\n     * range, the linear interpolant will occur on a ray extrapolated from this line.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(0, 0);\n     * var b = new pc.Vec2(10, 10);\n     * var r = new pc.Vec2();\n     *\n     * r.lerp(a, b, 0);   // r is equal to a\n     * r.lerp(a, b, 0.5); // r is 5, 5\n     * r.lerp(a, b, 1);   // r is equal to b\n     */\n    lerp(lhs, rhs, alpha) {\n        this.x = lhs.x + alpha * (rhs.x - lhs.x);\n        this.y = lhs.y + alpha * (rhs.y - lhs.y);\n        return this;\n    }\n    /**\n     * Multiplies a 2-dimensional vector to another in place.\n     *\n     * @param {Vec2} rhs - The 2-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(2, 3);\n     * var b = new pc.Vec2(4, 5);\n     *\n     * a.mul(b);\n     *\n     * // Outputs 8, 15\n     * console.log(\"The result of the multiplication is: \" + a.toString());\n     */\n    mul(rhs) {\n        this.x *= rhs.x;\n        this.y *= rhs.y;\n        return this;\n    }\n    /**\n     * Returns the result of multiplying the specified 2-dimensional vectors together.\n     *\n     * @param {Vec2} lhs - The 2-dimensional vector used as the first multiplicand of the operation.\n     * @param {Vec2} rhs - The 2-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(2, 3);\n     * var b = new pc.Vec2(4, 5);\n     * var r = new pc.Vec2();\n     *\n     * r.mul2(a, b);\n     *\n     * // Outputs 8, 15\n     * console.log(\"The result of the multiplication is: \" + r.toString());\n     */\n    mul2(lhs, rhs) {\n        this.x = lhs.x * rhs.x;\n        this.y = lhs.y * rhs.y;\n        return this;\n    }\n    /**\n     * Multiplies each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to multiply by.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var vec = new pc.Vec2(3, 6);\n     *\n     * vec.mulScalar(3);\n     *\n     * // Outputs [9, 18]\n     * console.log(\"The result of the multiplication is: \" + vec.toString());\n     */\n    mulScalar(scalar) {\n        this.x *= scalar;\n        this.y *= scalar;\n        return this;\n    }\n    /**\n     * Returns this 2-dimensional vector converted to a unit vector in place. If the vector has a\n     * length of zero, the vector's elements will be set to zero.\n     *\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var v = new pc.Vec2(25, 0);\n     *\n     * v.normalize();\n     *\n     * // Outputs 1, 0\n     * console.log(\"The result of the vector normalization is: \" + v.toString());\n     */\n    normalize() {\n        const lengthSq = this.x * this.x + this.y * this.y;\n        if (lengthSq > 0) {\n            const invLength = 1 / Math.sqrt(lengthSq);\n            this.x *= invLength;\n            this.y *= invLength;\n        }\n        return this;\n    }\n    /**\n     * Each element is set to the largest integer less than or equal to its value.\n     *\n     * @returns {Vec2} Self for chaining.\n     */\n    floor() {\n        this.x = Math.floor(this.x);\n        this.y = Math.floor(this.y);\n        return this;\n    }\n    /**\n     * Each element is rounded up to the next largest integer.\n     *\n     * @returns {Vec2} Self for chaining.\n     */\n    ceil() {\n        this.x = Math.ceil(this.x);\n        this.y = Math.ceil(this.y);\n        return this;\n    }\n    /**\n     * Each element is rounded up or down to the nearest integer.\n     *\n     * @returns {Vec2} Self for chaining.\n     */\n    round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    }\n    /**\n     * Each element is assigned a value from rhs parameter if it is smaller.\n     *\n     * @param {Vec2} rhs - The 2-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec2} Self for chaining.\n     */\n    min(rhs) {\n        if (rhs.x < this.x)\n            this.x = rhs.x;\n        if (rhs.y < this.y)\n            this.y = rhs.y;\n        return this;\n    }\n    /**\n     * Each element is assigned a value from rhs parameter if it is larger.\n     *\n     * @param {Vec2} rhs - The 2-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec2} Self for chaining.\n     */\n    max(rhs) {\n        if (rhs.x > this.x)\n            this.x = rhs.x;\n        if (rhs.y > this.y)\n            this.y = rhs.y;\n        return this;\n    }\n    /**\n     * Sets the specified 2-dimensional vector to the supplied numerical values.\n     *\n     * @param {number} x - The value to set on the first component of the vector.\n     * @param {number} y - The value to set on the second component of the vector.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var v = new pc.Vec2();\n     * v.set(5, 10);\n     *\n     * // Outputs 5, 10\n     * console.log(\"The result of the vector set is: \" + v.toString());\n     */\n    set(x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    /**\n     * Subtracts a 2-dimensional vector from another in place.\n     *\n     * @param {Vec2} rhs - The vector to add to the specified vector.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(10, 10);\n     * var b = new pc.Vec2(20, 20);\n     *\n     * a.sub(b);\n     *\n     * // Outputs [-10, -10]\n     * console.log(\"The result of the subtraction is: \" + a.toString());\n     */\n    sub(rhs) {\n        this.x -= rhs.x;\n        this.y -= rhs.y;\n        return this;\n    }\n    /**\n     * Subtracts two 2-dimensional vectors from one another and returns the result.\n     *\n     * @param {Vec2} lhs - The first vector operand for the addition.\n     * @param {Vec2} rhs - The second vector operand for the addition.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var a = new pc.Vec2(10, 10);\n     * var b = new pc.Vec2(20, 20);\n     * var r = new pc.Vec2();\n     *\n     * r.sub2(a, b);\n     *\n     * // Outputs [-10, -10]\n     * console.log(\"The result of the subtraction is: \" + r.toString());\n     */\n    sub2(lhs, rhs) {\n        this.x = lhs.x - rhs.x;\n        this.y = lhs.y - rhs.y;\n        return this;\n    }\n    /**\n     * Subtracts a number from each element of a vector.\n     *\n     * @param {number} scalar - The number to subtract.\n     * @returns {Vec2} Self for chaining.\n     * @example\n     * var vec = new pc.Vec2(3, 4);\n     *\n     * vec.subScalar(2);\n     *\n     * // Outputs [1, 2]\n     * console.log(\"The result of the subtraction is: \" + vec.toString());\n     */\n    subScalar(scalar) {\n        this.x -= scalar;\n        this.y -= scalar;\n        return this;\n    }\n    /**\n     * Converts the vector to string form.\n     *\n     * @returns {string} The vector in string form.\n     * @example\n     * var v = new pc.Vec2(20, 10);\n     * // Outputs [20, 10]\n     * console.log(v.toString());\n     */\n    toString() {\n        return `[${this.x}, ${this.y}]`;\n    }\n    /**\n     * Calculates the angle between two Vec2's in radians.\n     *\n     * @param {Vec2} lhs - The first vector operand for the calculation.\n     * @param {Vec2} rhs - The second vector operand for the calculation.\n     * @returns {number} The calculated angle in radians.\n     * @ignore\n     */\n    static angleRad(lhs, rhs) {\n        return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);\n    }\n}\n/**\n * A constant vector set to [0, 0].\n *\n * @type {Vec2}\n * @readonly\n */\nVec2.ZERO = Object.freeze(new Vec2(0, 0));\n/**\n * A constant vector set to [1, 1].\n *\n * @type {Vec2}\n * @readonly\n */\nVec2.ONE = Object.freeze(new Vec2(1, 1));\n/**\n * A constant vector set to [0, 1].\n *\n * @type {Vec2}\n * @readonly\n */\nVec2.UP = Object.freeze(new Vec2(0, 1));\n/**\n * A constant vector set to [0, -1].\n *\n * @type {Vec2}\n * @readonly\n */\nVec2.DOWN = Object.freeze(new Vec2(0, -1));\n/**\n * A constant vector set to [1, 0].\n *\n * @type {Vec2}\n * @readonly\n */\nVec2.RIGHT = Object.freeze(new Vec2(1, 0));\n/**\n * A constant vector set to [-1, 0].\n *\n * @type {Vec2}\n * @readonly\n */\nVec2.LEFT = Object.freeze(new Vec2(-1, 0));\n","/**\n * 3-dimensional vector.\n */\nclass Vec3 {\n    /**\n     * Creates a new Vec3 object.\n     *\n     * @param {number} [x] - The x value. Defaults to 0. If x is an array of length 3, the\n     * array will be used to populate all components.\n     * @param {number} [y] - The y value. Defaults to 0.\n     * @param {number} [z] - The z value. Defaults to 0.\n     * @example\n     * var v = new pc.Vec3(1, 2, 3);\n     */\n    constructor(x, y, z) {\n        this.x = x || 0;\n        this.y = y || 0;\n        this.z = z || 0;\n    }\n    applyQuaternion(q) {\n        const x = this.x, y = this.y, z = this.z;\n        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n        // calculate quat * vector\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n        // calculate result * inverse quat\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n        return this;\n    }\n    manhattanDistanceTo(v) {\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n    multiplyScalar(scalar) {\n        this.x *= scalar;\n        this.y *= scalar;\n        this.z *= scalar;\n        return this;\n    }\n    setFromMatrixPosition(m) {\n        const e = m.data;\n        this.x = e[12];\n        this.y = e[13];\n        this.z = e[14];\n        return this;\n    }\n    /**\n     * Adds a 3-dimensional vector to another in place.\n     *\n     * @param {Vec3} rhs - The vector to add to the specified vector.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(10, 10, 10);\n     * var b = new pc.Vec3(20, 20, 20);\n     *\n     * a.add(b);\n     *\n     * // Outputs [30, 30, 30]\n     * console.log(\"The result of the addition is: \" + a.toString());\n     */\n    add(rhs) {\n        this.x += rhs.x;\n        this.y += rhs.y;\n        this.z += rhs.z;\n        return this;\n    }\n    /**\n     * Adds two 3-dimensional vectors together and returns the result.\n     *\n     * @param {Vec3} lhs - The first vector operand for the addition.\n     * @param {Vec3} rhs - The second vector operand for the addition.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(10, 10, 10);\n     * var b = new pc.Vec3(20, 20, 20);\n     * var r = new pc.Vec3();\n     *\n     * r.add2(a, b);\n     * // Outputs [30, 30, 30]\n     *\n     * console.log(\"The result of the addition is: \" + r.toString());\n     */\n    add2(lhs, rhs) {\n        this.x = lhs.x + rhs.x;\n        this.y = lhs.y + rhs.y;\n        this.z = lhs.z + rhs.z;\n        return this;\n    }\n    /**\n     * Adds a number to each element of a vector.\n     *\n     * @param {number} scalar - The number to add.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var vec = new pc.Vec3(3, 4, 5);\n     *\n     * vec.addScalar(2);\n     *\n     * // Outputs [5, 6, 7]\n     * console.log(\"The result of the addition is: \" + vec.toString());\n     */\n    addScalar(scalar) {\n        this.x += scalar;\n        this.y += scalar;\n        this.z += scalar;\n        return this;\n    }\n    /**\n     * Returns an identical copy of the specified 3-dimensional vector.\n     *\n     * @returns {Vec3} A 3-dimensional vector containing the result of the cloning.\n     * @example\n     * var v = new pc.Vec3(10, 20, 30);\n     * var vclone = v.clone();\n     * console.log(\"The result of the cloning is: \" + vclone.toString());\n     */\n    clone() {\n        return new Vec3(this.x, this.y, this.z);\n    }\n    /**\n     * Copies the contents of a source 3-dimensional vector to a destination 3-dimensional vector.\n     *\n     * @param {Vec3} rhs - A vector to copy to the specified vector.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var src = new pc.Vec3(10, 20, 30);\n     * var dst = new pc.Vec3();\n     *\n     * dst.copy(src);\n     *\n     * console.log(\"The two vectors are \" + (dst.equals(src) ? \"equal\" : \"different\"));\n     */\n    copy(rhs) {\n        this.x = rhs.x;\n        this.y = rhs.y;\n        this.z = rhs.z;\n        return this;\n    }\n    /**\n     * Returns the result of a cross product operation performed on the two specified 3-dimensional\n     * vectors.\n     *\n     * @param {Vec3} lhs - The first 3-dimensional vector operand of the cross product.\n     * @param {Vec3} rhs - The second 3-dimensional vector operand of the cross product.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var back = new pc.Vec3().cross(pc.Vec3.RIGHT, pc.Vec3.UP);\n     *\n     * // Prints the Z axis (i.e. [0, 0, 1])\n     * console.log(\"The result of the cross product is: \" + back.toString());\n     */\n    cross(lhs, rhs) {\n        // Create temporary variables in case lhs or rhs are 'this'\n        const lx = lhs.x;\n        const ly = lhs.y;\n        const lz = lhs.z;\n        const rx = rhs.x;\n        const ry = rhs.y;\n        const rz = rhs.z;\n        this.x = ly * rz - ry * lz;\n        this.y = lz * rx - rz * lx;\n        this.z = lx * ry - rx * ly;\n        return this;\n    }\n    /**\n     * Returns the distance between the two specified 3-dimensional vectors.\n     *\n     * @param {Vec3} rhs - The second 3-dimensional vector to test.\n     * @returns {number} The distance between the two vectors.\n     * @example\n     * var v1 = new pc.Vec3(5, 10, 20);\n     * var v2 = new pc.Vec3(10, 20, 40);\n     * var d = v1.distance(v2);\n     * console.log(\"The distance between v1 and v2 is: \" + d);\n     */\n    distance(rhs) {\n        const x = this.x - rhs.x;\n        const y = this.y - rhs.y;\n        const z = this.z - rhs.z;\n        return Math.sqrt(x * x + y * y + z * z);\n    }\n    /**\n     * Divides a 3-dimensional vector by another in place.\n     *\n     * @param {Vec3} rhs - The vector to divide the specified vector by.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(4, 9, 16);\n     * var b = new pc.Vec3(2, 3, 4);\n     *\n     * a.div(b);\n     *\n     * // Outputs [2, 3, 4]\n     * console.log(\"The result of the division is: \" + a.toString());\n     */\n    div(rhs) {\n        this.x /= rhs.x;\n        this.y /= rhs.y;\n        this.z /= rhs.z;\n        return this;\n    }\n    /**\n     * Divides one 3-dimensional vector by another and writes the result to the specified vector.\n     *\n     * @param {Vec3} lhs - The dividend vector (the vector being divided).\n     * @param {Vec3} rhs - The divisor vector (the vector dividing the dividend).\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(4, 9, 16);\n     * var b = new pc.Vec3(2, 3, 4);\n     * var r = new pc.Vec3();\n     *\n     * r.div2(a, b);\n     * // Outputs [2, 3, 4]\n     *\n     * console.log(\"The result of the division is: \" + r.toString());\n     */\n    div2(lhs, rhs) {\n        this.x = lhs.x / rhs.x;\n        this.y = lhs.y / rhs.y;\n        this.z = lhs.z / rhs.z;\n        return this;\n    }\n    /**\n     * Divides each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to divide by.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var vec = new pc.Vec3(3, 6, 9);\n     *\n     * vec.divScalar(3);\n     *\n     * // Outputs [1, 2, 3]\n     * console.log(\"The result of the division is: \" + vec.toString());\n     */\n    divScalar(scalar) {\n        this.x /= scalar;\n        this.y /= scalar;\n        this.z /= scalar;\n        return this;\n    }\n    /**\n     * Returns the result of a dot product operation performed on the two specified 3-dimensional\n     * vectors.\n     *\n     * @param {Vec3} rhs - The second 3-dimensional vector operand of the dot product.\n     * @returns {number} The result of the dot product operation.\n     * @example\n     * var v1 = new pc.Vec3(5, 10, 20);\n     * var v2 = new pc.Vec3(10, 20, 40);\n     * var v1dotv2 = v1.dot(v2);\n     * console.log(\"The result of the dot product is: \" + v1dotv2);\n     */\n    dot(rhs) {\n        return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;\n    }\n    /**\n     * Reports whether two vectors are equal.\n     *\n     * @param {Vec3} rhs - The vector to compare to the specified vector.\n     * @returns {boolean} True if the vectors are equal and false otherwise.\n     * @example\n     * var a = new pc.Vec3(1, 2, 3);\n     * var b = new pc.Vec3(4, 5, 6);\n     * console.log(\"The two vectors are \" + (a.equals(b) ? \"equal\" : \"different\"));\n     */\n    equals(rhs) {\n        return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;\n    }\n    /**\n     * Returns the magnitude of the specified 3-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 3-dimensional vector.\n     * @example\n     * var vec = new pc.Vec3(3, 4, 0);\n     * var len = vec.length();\n     * // Outputs 5\n     * console.log(\"The length of the vector is: \" + len);\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    /**\n     * Returns the magnitude squared of the specified 3-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 3-dimensional vector.\n     * @example\n     * var vec = new pc.Vec3(3, 4, 0);\n     * var len = vec.lengthSq();\n     * // Outputs 25\n     * console.log(\"The length squared of the vector is: \" + len);\n     */\n    lengthSq() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    /**\n     * Returns the result of a linear interpolation between two specified 3-dimensional vectors.\n     *\n     * @param {Vec3} lhs - The 3-dimensional to interpolate from.\n     * @param {Vec3} rhs - The 3-dimensional to interpolate to.\n     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,\n     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this\n     * range, the linear interpolant will occur on a ray extrapolated from this line.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(0, 0, 0);\n     * var b = new pc.Vec3(10, 10, 10);\n     * var r = new pc.Vec3();\n     *\n     * r.lerp(a, b, 0);   // r is equal to a\n     * r.lerp(a, b, 0.5); // r is 5, 5, 5\n     * r.lerp(a, b, 1);   // r is equal to b\n     */\n    lerp2(lhs, rhs, alpha) {\n        this.x = lhs.x + alpha * (rhs.x - lhs.x);\n        this.y = lhs.y + alpha * (rhs.y - lhs.y);\n        this.z = lhs.z + alpha * (rhs.z - lhs.z);\n        return this;\n    }\n    lerp(v, alpha) {\n        this.x += (v.x - this.x) * alpha;\n        this.y += (v.y - this.y) * alpha;\n        this.z += (v.z - this.z) * alpha;\n        return this;\n    }\n    /**\n     * Multiplies a 3-dimensional vector to another in place.\n     *\n     * @param {Vec3} rhs - The 3-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(2, 3, 4);\n     * var b = new pc.Vec3(4, 5, 6);\n     *\n     * a.mul(b);\n     *\n     * // Outputs 8, 15, 24\n     * console.log(\"The result of the multiplication is: \" + a.toString());\n     */\n    mul(rhs) {\n        this.x *= rhs.x;\n        this.y *= rhs.y;\n        this.z *= rhs.z;\n        return this;\n    }\n    /**\n     * Returns the result of multiplying the specified 3-dimensional vectors together.\n     *\n     * @param {Vec3} lhs - The 3-dimensional vector used as the first multiplicand of the operation.\n     * @param {Vec3} rhs - The 3-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(2, 3, 4);\n     * var b = new pc.Vec3(4, 5, 6);\n     * var r = new pc.Vec3();\n     *\n     * r.mul2(a, b);\n     *\n     * // Outputs 8, 15, 24\n     * console.log(\"The result of the multiplication is: \" + r.toString());\n     */\n    mul2(lhs, rhs) {\n        this.x = lhs.x * rhs.x;\n        this.y = lhs.y * rhs.y;\n        this.z = lhs.z * rhs.z;\n        return this;\n    }\n    /**\n     * Multiplies each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to multiply by.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var vec = new pc.Vec3(3, 6, 9);\n     *\n     * vec.mulScalar(3);\n     *\n     * // Outputs [9, 18, 27]\n     * console.log(\"The result of the multiplication is: \" + vec.toString());\n     */\n    mulScalar(scalar) {\n        this.x *= scalar;\n        this.y *= scalar;\n        this.z *= scalar;\n        return this;\n    }\n    /**\n     * Returns this 3-dimensional vector converted to a unit vector in place. If the vector has a\n     * length of zero, the vector's elements will be set to zero.\n     *\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var v = new pc.Vec3(25, 0, 0);\n     *\n     * v.normalize();\n     *\n     * // Outputs 1, 0, 0\n     * console.log(\"The result of the vector normalization is: \" + v.toString());\n     */\n    normalize() {\n        const lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;\n        if (lengthSq > 0) {\n            const invLength = 1 / Math.sqrt(lengthSq);\n            this.x *= invLength;\n            this.y *= invLength;\n            this.z *= invLength;\n        }\n        return this;\n    }\n    /**\n     * Each element is set to the largest integer less than or equal to its value.\n     *\n     * @returns {Vec3} Self for chaining.\n     */\n    floor() {\n        this.x = Math.floor(this.x);\n        this.y = Math.floor(this.y);\n        this.z = Math.floor(this.z);\n        return this;\n    }\n    /**\n     * Each element is rounded up to the next largest integer.\n     *\n     * @returns {Vec3} Self for chaining.\n     */\n    ceil() {\n        this.x = Math.ceil(this.x);\n        this.y = Math.ceil(this.y);\n        this.z = Math.ceil(this.z);\n        return this;\n    }\n    /**\n     * Each element is rounded up or down to the nearest integer.\n     *\n     * @returns {Vec3} Self for chaining.\n     */\n    round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        this.z = Math.round(this.z);\n        return this;\n    }\n    /**\n     * Each element is assigned a value from rhs parameter if it is smaller.\n     *\n     * @param {Vec3} rhs - The 3-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec3} Self for chaining.\n     */\n    min(rhs) {\n        if (rhs.x < this.x)\n            this.x = rhs.x;\n        if (rhs.y < this.y)\n            this.y = rhs.y;\n        if (rhs.z < this.z)\n            this.z = rhs.z;\n        return this;\n    }\n    /**\n     * Each element is assigned a value from rhs parameter if it is larger.\n     *\n     * @param {Vec3} rhs - The 3-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec3} Self for chaining.\n     */\n    max(rhs) {\n        if (rhs.x > this.x)\n            this.x = rhs.x;\n        if (rhs.y > this.y)\n            this.y = rhs.y;\n        if (rhs.z > this.z)\n            this.z = rhs.z;\n        return this;\n    }\n    /**\n     * Projects this 3-dimensional vector onto the specified vector.\n     *\n     * @param {Vec3} rhs - The vector onto which the original vector will be projected on.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var v = new pc.Vec3(5, 5, 5);\n     * var normal = new pc.Vec3(1, 0, 0);\n     *\n     * v.project(normal);\n     *\n     * // Outputs 5, 0, 0\n     * console.log(\"The result of the vector projection is: \" + v.toString());\n     */\n    project(rhs) {\n        const a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;\n        const b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;\n        const s = a_dot_b / b_dot_b;\n        this.x = rhs.x * s;\n        this.y = rhs.y * s;\n        this.z = rhs.z * s;\n        return this;\n    }\n    /**\n     * Sets the specified 3-dimensional vector to the supplied numerical values.\n     *\n     * @param {number} x - The value to set on the first component of the vector.\n     * @param {number} y - The value to set on the second component of the vector.\n     * @param {number} z - The value to set on the third component of the vector.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var v = new pc.Vec3();\n     * v.set(5, 10, 20);\n     *\n     * // Outputs 5, 10, 20\n     * console.log(\"The result of the vector set is: \" + v.toString());\n     */\n    set(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n    }\n    /**\n     * Subtracts a 3-dimensional vector from another in place.\n     *\n     * @param {Vec3} rhs - The vector to add to the specified vector.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(10, 10, 10);\n     * var b = new pc.Vec3(20, 20, 20);\n     *\n     * a.sub(b);\n     *\n     * // Outputs [-10, -10, -10]\n     * console.log(\"The result of the subtraction is: \" + a.toString());\n     */\n    sub(rhs) {\n        this.x -= rhs.x;\n        this.y -= rhs.y;\n        this.z -= rhs.z;\n        return this;\n    }\n    /**\n     * Subtracts two 3-dimensional vectors from one another and returns the result.\n     *\n     * @param {Vec3} lhs - The first vector operand for the addition.\n     * @param {Vec3} rhs - The second vector operand for the addition.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var a = new pc.Vec3(10, 10, 10);\n     * var b = new pc.Vec3(20, 20, 20);\n     * var r = new pc.Vec3();\n     *\n     * r.sub2(a, b);\n     *\n     * // Outputs [-10, -10, -10]\n     * console.log(\"The result of the subtraction is: \" + r.toString());\n     */\n    sub2(lhs, rhs) {\n        this.x = lhs.x - rhs.x;\n        this.y = lhs.y - rhs.y;\n        this.z = lhs.z - rhs.z;\n        return this;\n    }\n    /**\n     * Subtracts a number from each element of a vector.\n     *\n     * @param {number} scalar - The number to subtract.\n     * @returns {Vec3} Self for chaining.\n     * @example\n     * var vec = new pc.Vec3(3, 4, 5);\n     *\n     * vec.subScalar(2);\n     *\n     * // Outputs [1, 2, 3]\n     * console.log(\"The result of the subtraction is: \" + vec.toString());\n     */\n    subScalar(scalar) {\n        this.x -= scalar;\n        this.y -= scalar;\n        this.z -= scalar;\n        return this;\n    }\n    /**\n     * Converts the vector to string form.\n     *\n     * @returns {string} The vector in string form.\n     * @example\n     * var v = new pc.Vec3(20, 10, 5);\n     * // Outputs [20, 10, 5]\n     * console.log(v.toString());\n     */\n    toString() {\n        return `[${this.x}, ${this.y}, ${this.z}]`;\n    }\n}\n/**\n * A constant vector set to [0, 0, 0].\n *\n * @type {Vec3}\n * @readonly\n */\nVec3.ZERO = Object.freeze(new Vec3(0, 0, 0));\n/**\n * A constant vector set to [1, 1, 1].\n *\n * @type {Vec3}\n * @readonly\n */\nVec3.ONE = Object.freeze(new Vec3(1, 1, 1));\n/**\n * A constant vector set to [0, 1, 0].\n *\n * @type {Vec3}\n * @readonly\n */\nVec3.UP = Object.freeze(new Vec3(0, 1, 0));\n/**\n * A constant vector set to [0, -1, 0].\n *\n * @type {Vec3}\n * @readonly\n */\nVec3.DOWN = Object.freeze(new Vec3(0, -1, 0));\n/**\n * A constant vector set to [1, 0, 0].\n *\n * @type {Vec3}\n * @readonly\n */\nVec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));\n/**\n * A constant vector set to [-1, 0, 0].\n *\n * @type {Vec3}\n * @readonly\n */\nVec3.LEFT = Object.freeze(new Vec3(-1, 0, 0));\n/**\n * A constant vector set to [0, 0, -1].\n *\n * @type {Vec3}\n * @readonly\n */\nVec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));\n/**\n * A constant vector set to [0, 0, 1].\n *\n * @type {Vec3}\n * @readonly\n */\nVec3.BACK = Object.freeze(new Vec3(0, 0, 1));\nVec3.AXIS_X = Object.freeze(new Vec3(1, 0, 0));\nVec3.AXIS_Y = Object.freeze(new Vec3(0, 1, 0));\nVec3.AXIS_Z = Object.freeze(new Vec3(0, 0, 1));\nexport { Vec3 };\n","/**\n * A 4-dimensional vector.\n */\nclass Vec4 {\n    /**\n     * Creates a new Vec4 object.\n     *\n     * @param {number|number[]} [x] - The x value. Defaults to 0. If x is an array of length 4, the\n     * array will be used to populate all components.\n     * @param {number} [y] - The y value. Defaults to 0.\n     * @param {number} [z] - The z value. Defaults to 0.\n     * @param {number} [w] - The w value. Defaults to 0.\n     * @example\n     * var v = new pc.Vec4(1, 2, 3, 4);\n     */\n    constructor(x = 0, y = 0, z = 0, w = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    /**\n     * Adds a 4-dimensional vector to another in place.\n     *\n     * @param {Vec4} rhs - The vector to add to the specified vector.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(10, 10, 10, 10);\n     * var b = new pc.Vec4(20, 20, 20, 20);\n     *\n     * a.add(b);\n     *\n     * // Outputs [30, 30, 30]\n     * console.log(\"The result of the addition is: \" + a.toString());\n     */\n    add(rhs) {\n        this.x += rhs.x;\n        this.y += rhs.y;\n        this.z += rhs.z;\n        this.w += rhs.w;\n        return this;\n    }\n    /**\n     * Adds two 4-dimensional vectors together and returns the result.\n     *\n     * @param {Vec4} lhs - The first vector operand for the addition.\n     * @param {Vec4} rhs - The second vector operand for the addition.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(10, 10, 10, 10);\n     * var b = new pc.Vec4(20, 20, 20, 20);\n     * var r = new pc.Vec4();\n     *\n     * r.add2(a, b);\n     * // Outputs [30, 30, 30]\n     *\n     * console.log(\"The result of the addition is: \" + r.toString());\n     */\n    add2(lhs, rhs) {\n        this.x = lhs.x + rhs.x;\n        this.y = lhs.y + rhs.y;\n        this.z = lhs.z + rhs.z;\n        this.w = lhs.w + rhs.w;\n        return this;\n    }\n    /**\n     * Adds a number to each element of a vector.\n     *\n     * @param {number} scalar - The number to add.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var vec = new pc.Vec4(3, 4, 5, 6);\n     *\n     * vec.addScalar(2);\n     *\n     * // Outputs [5, 6, 7, 8]\n     * console.log(\"The result of the addition is: \" + vec.toString());\n     */\n    addScalar(scalar) {\n        this.x += scalar;\n        this.y += scalar;\n        this.z += scalar;\n        this.w += scalar;\n        return this;\n    }\n    /**\n     * Returns an identical copy of the specified 4-dimensional vector.\n     *\n     * @returns {Vec4} A 4-dimensional vector containing the result of the cloning.\n     * @example\n     * var v = new pc.Vec4(10, 20, 30, 40);\n     * var vclone = v.clone();\n     * console.log(\"The result of the cloning is: \" + vclone.toString());\n     */\n    clone() {\n        return new Vec4(this.x, this.y, this.z, this.w);\n    }\n    /**\n     * Copies the contents of a source 4-dimensional vector to a destination 4-dimensional vector.\n     *\n     * @param {Vec4} rhs - A vector to copy to the specified vector.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var src = new pc.Vec4(10, 20, 30, 40);\n     * var dst = new pc.Vec4();\n     *\n     * dst.copy(src);\n     *\n     * console.log(\"The two vectors are \" + (dst.equals(src) ? \"equal\" : \"different\"));\n     */\n    copy(rhs) {\n        this.x = rhs.x;\n        this.y = rhs.y;\n        this.z = rhs.z;\n        this.w = rhs.w;\n        return this;\n    }\n    /**\n     * Divides a 4-dimensional vector by another in place.\n     *\n     * @param {Vec4} rhs - The vector to divide the specified vector by.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(4, 9, 16, 25);\n     * var b = new pc.Vec4(2, 3, 4, 5);\n     *\n     * a.div(b);\n     *\n     * // Outputs [2, 3, 4, 5]\n     * console.log(\"The result of the division is: \" + a.toString());\n     */\n    div(rhs) {\n        this.x /= rhs.x;\n        this.y /= rhs.y;\n        this.z /= rhs.z;\n        this.w /= rhs.w;\n        return this;\n    }\n    /**\n     * Divides one 4-dimensional vector by another and writes the result to the specified vector.\n     *\n     * @param {Vec4} lhs - The dividend vector (the vector being divided).\n     * @param {Vec4} rhs - The divisor vector (the vector dividing the dividend).\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(4, 9, 16, 25);\n     * var b = new pc.Vec4(2, 3, 4, 5);\n     * var r = new pc.Vec4();\n     *\n     * r.div2(a, b);\n     * // Outputs [2, 3, 4, 5]\n     *\n     * console.log(\"The result of the division is: \" + r.toString());\n     */\n    div2(lhs, rhs) {\n        this.x = lhs.x / rhs.x;\n        this.y = lhs.y / rhs.y;\n        this.z = lhs.z / rhs.z;\n        this.w = lhs.w / rhs.w;\n        return this;\n    }\n    /**\n     * Divides each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to divide by.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var vec = new pc.Vec4(3, 6, 9, 12);\n     *\n     * vec.divScalar(3);\n     *\n     * // Outputs [1, 2, 3, 4]\n     * console.log(\"The result of the division is: \" + vec.toString());\n     */\n    divScalar(scalar) {\n        this.x /= scalar;\n        this.y /= scalar;\n        this.z /= scalar;\n        this.w /= scalar;\n        return this;\n    }\n    /**\n     * Returns the result of a dot product operation performed on the two specified 4-dimensional\n     * vectors.\n     *\n     * @param {Vec4} rhs - The second 4-dimensional vector operand of the dot product.\n     * @returns {number} The result of the dot product operation.\n     * @example\n     * var v1 = new pc.Vec4(5, 10, 20, 40);\n     * var v2 = new pc.Vec4(10, 20, 40, 80);\n     * var v1dotv2 = v1.dot(v2);\n     * console.log(\"The result of the dot product is: \" + v1dotv2);\n     */\n    dot(rhs) {\n        return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;\n    }\n    /**\n     * Reports whether two vectors are equal.\n     *\n     * @param {Vec4} rhs - The vector to compare to the specified vector.\n     * @returns {boolean} True if the vectors are equal and false otherwise.\n     * @example\n     * var a = new pc.Vec4(1, 2, 3, 4);\n     * var b = new pc.Vec4(5, 6, 7, 8);\n     * console.log(\"The two vectors are \" + (a.equals(b) ? \"equal\" : \"different\"));\n     */\n    equals(rhs) {\n        return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;\n    }\n    /**\n     * Returns the magnitude of the specified 4-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 4-dimensional vector.\n     * @example\n     * var vec = new pc.Vec4(3, 4, 0, 0);\n     * var len = vec.length();\n     * // Outputs 5\n     * console.log(\"The length of the vector is: \" + len);\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    /**\n     * Returns the magnitude squared of the specified 4-dimensional vector.\n     *\n     * @returns {number} The magnitude of the specified 4-dimensional vector.\n     * @example\n     * var vec = new pc.Vec4(3, 4, 0);\n     * var len = vec.lengthSq();\n     * // Outputs 25\n     * console.log(\"The length squared of the vector is: \" + len);\n     */\n    lengthSq() {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    /**\n     * Returns the result of a linear interpolation between two specified 4-dimensional vectors.\n     *\n     * @param {Vec4} lhs - The 4-dimensional to interpolate from.\n     * @param {Vec4} rhs - The 4-dimensional to interpolate to.\n     * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1,\n     * the linear interpolant will occur on a straight line between lhs and rhs. Outside of this\n     * range, the linear interpolant will occur on a ray extrapolated from this line.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(0, 0, 0, 0);\n     * var b = new pc.Vec4(10, 10, 10, 10);\n     * var r = new pc.Vec4();\n     *\n     * r.lerp(a, b, 0);   // r is equal to a\n     * r.lerp(a, b, 0.5); // r is 5, 5, 5, 5\n     * r.lerp(a, b, 1);   // r is equal to b\n     */\n    lerp(lhs, rhs, alpha) {\n        this.x = lhs.x + alpha * (rhs.x - lhs.x);\n        this.y = lhs.y + alpha * (rhs.y - lhs.y);\n        this.z = lhs.z + alpha * (rhs.z - lhs.z);\n        this.w = lhs.w + alpha * (rhs.w - lhs.w);\n        return this;\n    }\n    /**\n     * Multiplies a 4-dimensional vector to another in place.\n     *\n     * @param {Vec4} rhs - The 4-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(2, 3, 4, 5);\n     * var b = new pc.Vec4(4, 5, 6, 7);\n     *\n     * a.mul(b);\n     *\n     * // Outputs 8, 15, 24, 35\n     * console.log(\"The result of the multiplication is: \" + a.toString());\n     */\n    mul(rhs) {\n        this.x *= rhs.x;\n        this.y *= rhs.y;\n        this.z *= rhs.z;\n        this.w *= rhs.w;\n        return this;\n    }\n    /**\n     * Returns the result of multiplying the specified 4-dimensional vectors together.\n     *\n     * @param {Vec4} lhs - The 4-dimensional vector used as the first multiplicand of the operation.\n     * @param {Vec4} rhs - The 4-dimensional vector used as the second multiplicand of the operation.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(2, 3, 4, 5);\n     * var b = new pc.Vec4(4, 5, 6, 7);\n     * var r = new pc.Vec4();\n     *\n     * r.mul2(a, b);\n     *\n     * // Outputs 8, 15, 24, 35\n     * console.log(\"The result of the multiplication is: \" + r.toString());\n     */\n    mul2(lhs, rhs) {\n        this.x = lhs.x * rhs.x;\n        this.y = lhs.y * rhs.y;\n        this.z = lhs.z * rhs.z;\n        this.w = lhs.w * rhs.w;\n        return this;\n    }\n    /**\n     * Multiplies each element of a vector by a number.\n     *\n     * @param {number} scalar - The number to multiply by.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var vec = new pc.Vec4(3, 6, 9, 12);\n     *\n     * vec.mulScalar(3);\n     *\n     * // Outputs [9, 18, 27, 36]\n     * console.log(\"The result of the multiplication is: \" + vec.toString());\n     */\n    mulScalar(scalar) {\n        this.x *= scalar;\n        this.y *= scalar;\n        this.z *= scalar;\n        this.w *= scalar;\n        return this;\n    }\n    /**\n     * Returns this 4-dimensional vector converted to a unit vector in place. If the vector has a\n     * length of zero, the vector's elements will be set to zero.\n     *\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var v = new pc.Vec4(25, 0, 0, 0);\n     *\n     * v.normalize();\n     *\n     * // Outputs 1, 0, 0, 0\n     * console.log(\"The result of the vector normalization is: \" + v.toString());\n     */\n    normalize() {\n        const lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n        if (lengthSq > 0) {\n            const invLength = 1 / Math.sqrt(lengthSq);\n            this.x *= invLength;\n            this.y *= invLength;\n            this.z *= invLength;\n            this.w *= invLength;\n        }\n        return this;\n    }\n    /**\n     * Each element is set to the largest integer less than or equal to its value.\n     *\n     * @returns {Vec4} Self for chaining.\n     */\n    floor() {\n        this.x = Math.floor(this.x);\n        this.y = Math.floor(this.y);\n        this.z = Math.floor(this.z);\n        this.w = Math.floor(this.w);\n        return this;\n    }\n    /**\n     * Each element is rounded up to the next largest integer.\n     *\n     * @returns {Vec4} Self for chaining.\n     */\n    ceil() {\n        this.x = Math.ceil(this.x);\n        this.y = Math.ceil(this.y);\n        this.z = Math.ceil(this.z);\n        this.w = Math.ceil(this.w);\n        return this;\n    }\n    /**\n     * Each element is rounded up or down to the nearest integer.\n     *\n     * @returns {Vec4} Self for chaining.\n     */\n    round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        this.z = Math.round(this.z);\n        this.w = Math.round(this.w);\n        return this;\n    }\n    /**\n     * Each element is assigned a value from rhs parameter if it is smaller.\n     *\n     * @param {Vec4} rhs - The 4-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec4} Self for chaining.\n     */\n    min(rhs) {\n        if (rhs.x < this.x)\n            this.x = rhs.x;\n        if (rhs.y < this.y)\n            this.y = rhs.y;\n        if (rhs.z < this.z)\n            this.z = rhs.z;\n        if (rhs.w < this.w)\n            this.w = rhs.w;\n        return this;\n    }\n    /**\n     * Each element is assigned a value from rhs parameter if it is larger.\n     *\n     * @param {Vec4} rhs - The 4-dimensional vector used as the source of elements to compare to.\n     * @returns {Vec4} Self for chaining.\n     */\n    max(rhs) {\n        if (rhs.x > this.x)\n            this.x = rhs.x;\n        if (rhs.y > this.y)\n            this.y = rhs.y;\n        if (rhs.z > this.z)\n            this.z = rhs.z;\n        if (rhs.w > this.w)\n            this.w = rhs.w;\n        return this;\n    }\n    /**\n     * Sets the specified 4-dimensional vector to the supplied numerical values.\n     *\n     * @param {number} x - The value to set on the first component of the vector.\n     * @param {number} y - The value to set on the second component of the vector.\n     * @param {number} z - The value to set on the third component of the vector.\n     * @param {number} w - The value to set on the fourth component of the vector.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var v = new pc.Vec4();\n     * v.set(5, 10, 20, 40);\n     *\n     * // Outputs 5, 10, 20, 40\n     * console.log(\"The result of the vector set is: \" + v.toString());\n     */\n    set(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    }\n    /**\n     * Subtracts a 4-dimensional vector from another in place.\n     *\n     * @param {Vec4} rhs - The vector to add to the specified vector.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(10, 10, 10, 10);\n     * var b = new pc.Vec4(20, 20, 20, 20);\n     *\n     * a.sub(b);\n     *\n     * // Outputs [-10, -10, -10, -10]\n     * console.log(\"The result of the subtraction is: \" + a.toString());\n     */\n    sub(rhs) {\n        this.x -= rhs.x;\n        this.y -= rhs.y;\n        this.z -= rhs.z;\n        this.w -= rhs.w;\n        return this;\n    }\n    /**\n     * Subtracts two 4-dimensional vectors from one another and returns the result.\n     *\n     * @param {Vec4} lhs - The first vector operand for the subtraction.\n     * @param {Vec4} rhs - The second vector operand for the subtraction.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var a = new pc.Vec4(10, 10, 10, 10);\n     * var b = new pc.Vec4(20, 20, 20, 20);\n     * var r = new pc.Vec4();\n     *\n     * r.sub2(a, b);\n     *\n     * // Outputs [-10, -10, -10, -10]\n     * console.log(\"The result of the subtraction is: \" + r.toString());\n     */\n    sub2(lhs, rhs) {\n        this.x = lhs.x - rhs.x;\n        this.y = lhs.y - rhs.y;\n        this.z = lhs.z - rhs.z;\n        this.w = lhs.w - rhs.w;\n        return this;\n    }\n    /**\n     * Subtracts a number from each element of a vector.\n     *\n     * @param {number} scalar - The number to subtract.\n     * @returns {Vec4} Self for chaining.\n     * @example\n     * var vec = new pc.Vec4(3, 4, 5, 6);\n     *\n     * vec.subScalar(2);\n     *\n     * // Outputs [1, 2, 3, 4]\n     * console.log(\"The result of the subtraction is: \" + vec.toString());\n     */\n    subScalar(scalar) {\n        this.x -= scalar;\n        this.y -= scalar;\n        this.z -= scalar;\n        this.w -= scalar;\n        return this;\n    }\n    /**\n     * Converts the vector to string form.\n     *\n     * @returns {string} The vector in string form.\n     * @example\n     * var v = new pc.Vec4(20, 10, 5, 0);\n     * // Outputs [20, 10, 5, 0]\n     * console.log(v.toString());\n     */\n    toString() {\n        return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;\n    }\n}\n/**\n * A constant vector set to [0, 0, 0, 0].\n *\n * @type {Vec4}\n * @readonly\n */\nVec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));\n/**\n * A constant vector set to [1, 1, 1, 1].\n *\n * @type {Vec4}\n * @readonly\n */\nVec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));\nexport { Vec4 };\n","export * from \"./mesh\";\n","import { UniformsType } from \"../engines\";\nimport { PrimitiveType } from \"../engines/engine.draw\";\nimport { Geometry } from \"../geometry\";\nimport { Material } from \"../material/material\";\nimport { Mesh } from \"./mesh\";\nexport class MeshAxis {\n    constructor(engine, size) {\n        this._engine = engine;\n        const geoX = this.getGeoX(size);\n        const geoY = this.getGeoX(size);\n        const geoZ = this.getGeoX(size);\n        geoY.attributes.aPosition.value = [0, 0, 0, 0, 1 * size, 0];\n        geoZ.attributes.aPosition.value = [0, 0, 0, 0, 0, 1 * size];\n        const matX = this.getMat({ x: 1, y: 0, z: 0, w: 1 });\n        const matY = this.getMat({ x: 0, y: 1, z: 0, w: 1 });\n        const matZ = this.getMat({ x: 0, y: 0, z: 1, w: 1 });\n        this.meshX = new Mesh(this._engine, new Geometry(engine, geoX), matX);\n        this.meshY = new Mesh(this._engine, new Geometry(engine, geoY), matY);\n        this.meshZ = new Mesh(this._engine, new Geometry(engine, geoZ), matZ);\n    }\n    getMat(color) {\n        const vertexShader = `\n      in vec3 aPosition;\n\n      uniform mat4 projectionMatrix;\n      uniform mat4 modelViewMatrix;\n\n      void main() {\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(aPosition, 1.0);\n      }\n    `;\n        const fragmentShader = `\n      uniform vec4 uColor;\n      out vec4 FragColor;\n\n      void main() {\n        FragColor = uColor;\n      }\n      `;\n        const mat = new Material(this._engine, {\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                uColor: { type: UniformsType.Vec4, value: color },\n            },\n        });\n        return mat;\n    }\n    getGeoX(size) {\n        return {\n            count: 2,\n            attributes: {\n                aPosition: {\n                    value: [0, 0, 0, 1 * size, 0, 0],\n                    itemSize: 3,\n                },\n            },\n            type: PrimitiveType.PRIMITIVE_LINES,\n        };\n    }\n}\n","import { Euler } from \"../maths/math.euler\";\nimport { Mat3 } from \"../maths/math.mat3\";\nimport { Mat4 } from \"../maths/math.mat4\";\nimport { Quat } from \"../maths/math.quat\";\nimport { MathTool } from \"../maths/math.tool\";\nimport { Vec3 } from \"../maths/math.vec3\";\nimport { addProxy } from \"../misc/tool\";\nexport class Mesh {\n    constructor(engine, geometry, material) {\n        this.geometry = geometry;\n        this._engine = engine;\n        this.uuid = MathTool.generateUUID();\n        this.material = material;\n        this.visible = true;\n        this.matrix = new Mat4();\n        this.normalMatrix = new Mat3();\n        this.position = new Vec3();\n        this.scale = new Vec3(1, 1, 1);\n        this.rotation = new Euler();\n        this.quaternion = new Quat();\n        this.updateMatrix = this.updateMatrix.bind(this);\n        this._onRotationChange = this._onRotationChange.bind(this);\n        this.position = addProxy(this.position, this.updateMatrix);\n        this.scale = addProxy(this.scale, this.updateMatrix);\n        this.rotation = addProxy(this.rotation, this._onRotationChange);\n    }\n    _onRotationChange() {\n        this.quaternion.setFromEuler(this.rotation);\n        this.updateMatrix();\n    }\n    active() {\n        this.geometry.setBuffers(this.material.program);\n        this.material.setUniform();\n    }\n    updateMatrix() {\n        this.matrix.compose(this.position, this.quaternion, this.scale);\n    }\n}\n","/**\n * Class containing a set of static utilities functions for arrays.\n */\nexport class ArrayTools {\n    /**\n     * Returns an array of the given size filled with element built from the given constructor and the paramters\n     * @param size the number of element to construct and put in the array\n     * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.\n     * @returns a new array filled with new objects\n     */\n    static BuildArray(size, itemBuilder) {\n        const a = [];\n        for (let i = 0; i < size; ++i) {\n            a.push(itemBuilder());\n        }\n        return a;\n    }\n}\n","/**\n * Checks if the window object exists\n * @returns true if the window object exists\n */\nexport function IsWindowObjectExist() {\n    return typeof window !== \"undefined\";\n}\n/**\n * Checks if the navigator object exists\n * @returns true if the navigator object exists\n */\nexport function IsNavigatorAvailable() {\n    return typeof navigator !== \"undefined\";\n}\n/**\n * Check if the document object exists\n * @returns true if the document object exists\n */\nexport function IsDocumentAvailable() {\n    return typeof document !== \"undefined\";\n}\n/**\n * Extracts text content from a DOM element hierarchy\n * @param element defines the root element\n * @returns a string\n */\nexport function GetDOMTextContent(element) {\n    var result = \"\";\n    var child = element.firstChild;\n    while (child) {\n        if (child.nodeType === 3) {\n            result += child.textContent;\n        }\n        child = child.nextSibling;\n    }\n    return result;\n}\n/**\n * Reports whether a texture source is a canvas, image, video or ImageBitmap.\n *\n * @param {*} texture - Texture source data.\n * @returns {boolean} True if the texture is a canvas, image, video or ImageBitmap and false\n * otherwise.\n * @private\n */\nexport function isBrowserInterface(texture) {\n    return ((typeof HTMLCanvasElement !== \"undefined\" && texture instanceof HTMLCanvasElement) ||\n        (typeof HTMLImageElement !== \"undefined\" && texture instanceof HTMLImageElement) ||\n        (typeof HTMLVideoElement !== \"undefined\" && texture instanceof HTMLVideoElement) ||\n        (typeof ImageBitmap !== \"undefined\" && texture instanceof ImageBitmap));\n}\n/**\n * Sets of helpers dealing with the DOM and some of the recurrent functions needed in\n * Babylon.js\n */\nexport const DomManagement = {\n    /**\n     * Checks if the window object exists\n     * @returns true if the window object exists\n     */\n    IsWindowObjectExist,\n    /**\n     * Checks if the navigator object exists\n     * @returns true if the navigator object exists\n     */\n    IsNavigatorAvailable,\n    /**\n     * Check if the document object exists\n     * @returns true if the document object exists\n     */\n    IsDocumentAvailable,\n    /**\n     * Extracts text content from a DOM element hierarchy\n     * @param element defines the root element\n     * @returns a string\n     */\n    GetDOMTextContent,\n};\n","/**\n * @hidden\n */\nexport class FileTools {\n    static LoadImage(src, rootPath) {\n        if (rootPath === undefined)\n            rootPath = \"\";\n        return new Promise(function (resolve, reject) {\n            let img = new Image();\n            img.crossOrigin = \"anonymous\";\n            img.onload = function () {\n                resolve(img);\n            };\n            img.onerror = function () {\n                reject(\"ERROR WHILE TRYING TO LOAD SKYBOX TEXTURE\");\n            };\n            img.src = rootPath + src;\n        });\n    }\n    static LoadCubeImages(urls) {\n        return new Promise(function (resolve, reject) {\n            let ct = 0;\n            let img = new Array(6);\n            for (let i = 0; i < 6; i++) {\n                img[i] = new Image();\n                img[i].onload = function () {\n                    ct++;\n                    if (ct == 6) {\n                        resolve(img);\n                    }\n                };\n                img[i].onerror = function () {\n                    reject(\"ERROR WHILE TRYING TO LOAD SKYBOX TEXTURE\");\n                };\n                img[i].src = urls[i];\n            }\n        });\n    }\n    static LoadTextFiles(filenames, rootPath) {\n        if (rootPath === undefined)\n            rootPath = \"\";\n        return new Promise((resolve, reject) => {\n            var loadedSoFar = 0;\n            var results = {};\n            for (var i = 0; i < filenames.length; ++i) {\n                var filename = filenames[i];\n                (function () {\n                    var name = rootPath + filename;\n                    var request = new XMLHttpRequest();\n                    request.onreadystatechange = function () {\n                        if (request.readyState === 4) {\n                            //if this reqest is done\n                            //add this file to the results object\n                            var text = request.responseText;\n                            results[name] = text;\n                            loadedSoFar += 1;\n                            if (loadedSoFar === filenames.length) {\n                                //if we've loaded all of the files\n                                return resolve(results);\n                            }\n                        }\n                    };\n                    request.open(\"GET\", name, true);\n                    request.send();\n                })();\n            }\n        });\n    }\n}\n","/**\n * Logger used througouht the application to allow configuration of\n * the log level required for the messages.\n */\nexport class Logger {\n    static _AddLogEntry(entry) {\n        Logger._LogCache = entry + Logger._LogCache;\n        if (Logger.OnNewCacheEntry) {\n            Logger.OnNewCacheEntry(entry);\n        }\n    }\n    static _FormatMessage(message) {\n        var padStr = (i) => (i < 10 ? \"0\" + i : \"\" + i);\n        var date = new Date();\n        return \"[\" + padStr(date.getHours()) + \":\" + padStr(date.getMinutes()) + \":\" + padStr(date.getSeconds()) + \"]: \" + message;\n    }\n    static _LogDisabled(message) {\n        // nothing to do\n    }\n    static _LogEnabled(message) {\n        var formattedMessage = Logger._FormatMessage(message);\n        console.log(\"EasyCG - \" + formattedMessage);\n        // var entry = \"<div style='color:white'>\" + formattedMessage + \"</div><br>\";\n        // Logger._AddLogEntry(entry);\n    }\n    static _WarnDisabled(message) {\n        // nothing to do\n    }\n    static _WarnEnabled(message) {\n        var formattedMessage = Logger._FormatMessage(message);\n        console.warn(\"EasyCG - \" + formattedMessage);\n        // var entry = \"<div style='color:orange'>\" + formattedMessage + \"</div><br>\";\n        // Logger._AddLogEntry(entry);\n    }\n    static _ErrorDisabled(message) {\n        // nothing to do\n    }\n    static _ErrorEnabled(message) {\n        Logger.errorsCount++;\n        var formattedMessage = Logger._FormatMessage(message);\n        console.error(\"EasyCG - \" + formattedMessage);\n        // var entry = \"<div style='color:red'>\" + formattedMessage + \"</div><br>\";\n        // Logger._AddLogEntry(entry);\n    }\n    /**\n     * Gets current log cache (list of logs)\n     */\n    static get LogCache() {\n        return Logger._LogCache;\n    }\n    /**\n     * Clears the log cache\n     */\n    static ClearLogCache() {\n        Logger._LogCache = \"\";\n        Logger.errorsCount = 0;\n    }\n    /**\n     * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)\n     */\n    static set LogLevels(level) {\n        if ((level & Logger.MessageLogLevel) === Logger.MessageLogLevel) {\n            Logger.Log = Logger._LogEnabled;\n        }\n        else {\n            Logger.Log = Logger._LogDisabled;\n        }\n        if ((level & Logger.WarningLogLevel) === Logger.WarningLogLevel) {\n            Logger.Warn = Logger._WarnEnabled;\n        }\n        else {\n            Logger.Warn = Logger._WarnDisabled;\n        }\n        if ((level & Logger.ErrorLogLevel) === Logger.ErrorLogLevel) {\n            Logger.Error = Logger._ErrorEnabled;\n        }\n        else {\n            Logger.Error = Logger._ErrorDisabled;\n        }\n    }\n    /**\n     * Assertion error message. If the assertion is false, the error message is written to the log.\n     *\n     * @param {boolean} assertion - The assertion to check.\n     * @param {...*} args - The values to be written to the log.\n     */\n    static Assert(assertion, ...args) {\n        if (!assertion) {\n            console.error(\"ASSERT FAILED: \", ...args);\n        }\n    }\n}\n/**\n * No log\n */\nLogger.NoneLogLevel = 0;\n/**\n * Only message logs\n */\nLogger.MessageLogLevel = 1;\n/**\n * Only warning logs\n */\nLogger.WarningLogLevel = 2;\n/**\n * Only error logs\n */\nLogger.ErrorLogLevel = 4;\n/**\n * All logs\n */\nLogger.AllLogLevel = 7;\nLogger._LogCache = \"\";\n/**\n * Gets a value indicating the number of loading errors\n * @ignorenaming\n */\nLogger.errorsCount = 0;\n/**\n * Log a message to the console\n */\nLogger.Log = Logger._LogEnabled;\n/**\n * Write a warning message to the console\n */\nLogger.Warn = Logger._WarnEnabled;\n/**\n * Write an error message to the console\n */\nLogger.Error = Logger._ErrorEnabled;\n","export class ShaderProcess {\n    static generateDefines(defines) {\n        if (defines == undefined)\n            return \"\";\n        const chunks = [];\n        for (const name in defines) {\n            const value = defines[name];\n            if (value === false)\n                continue;\n            chunks.push(\"#define \" + name + \" \" + value);\n        }\n        chunks.push(\"\\r\\n\");\n        return chunks.join(\"\\n\");\n    }\n    static getHead() {\n        const header = `#version 300 es\nprecision mediump float;\n    `;\n        return header;\n        ;\n    }\n}\n","export function addProxy(proxyObj, setCb, getCb) {\n    const handler = {\n        get(target, key) {\n            let result = target[key];\n            getCb && getCb(result);\n            return result;\n        },\n        set(target, key, value) {\n            target[key] = value;\n            setCb && setCb(this);\n            return this;\n        },\n    };\n    return new Proxy(proxyObj, handler);\n}\nexport function cloneUniforms(src) {\n    const dst = {};\n    for (const u in src) {\n        dst[u] = {};\n        for (const p in src[u]) {\n            const property = src[u][p];\n            if (property &&\n                (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n                dst[u][p] = property.clone();\n            }\n            else if (Array.isArray(property)) {\n                dst[u][p] = property.slice();\n            }\n            else {\n                dst[u][p] = property;\n            }\n        }\n    }\n    return dst;\n}\n","/** @hidden */\nexport class _TypeStore {\n    /** @hidden */\n    static GetClass(fqdn) {\n        if (this.RegisteredTypes && this.RegisteredTypes[fqdn]) {\n            return this.RegisteredTypes[fqdn];\n        }\n        return null;\n    }\n}\n/** @hidden */\n_TypeStore.RegisteredTypes = {};\n","import { Mat4 } from \"./maths/math.mat4\";\nimport { Mat3 } from \"./maths/math.mat3\";\nimport { MathTool } from \"./maths/math.tool\";\nimport { Vec3 } from \"./maths/math.vec3\";\nimport { Quat } from \"./maths/math.quat\";\n// import { EventDispatcher } from \"./EventDispatcher.js\";\nimport { Euler } from \"./maths/math.euler\";\n// import { Layers } from './Layers.js';\n// import { Matrix3 } from \"../math/Matrix3.js\";\n// import * as MathUtils from \"../math/MathUtils.js\";\nlet _object3DId = 0;\nconst _v1 = /*@__PURE__*/ new Vec3();\nconst _q1 = /*@__PURE__*/ new Quat();\nconst _m1 = /*@__PURE__*/ new Mat4();\nconst _target = /*@__PURE__*/ new Vec3();\nconst _position = /*@__PURE__*/ new Vec3();\nconst _scale = /*@__PURE__*/ new Vec3();\nconst _quaternion = /*@__PURE__*/ new Quat();\nconst _xAxis = /*@__PURE__*/ new Vec3(1, 0, 0);\nconst _yAxis = /*@__PURE__*/ new Vec3(0, 1, 0);\nconst _zAxis = /*@__PURE__*/ new Vec3(0, 0, 1);\nconst _addedEvent = { type: \"added\" };\nconst _removedEvent = { type: \"removed\" };\nclass Object3D {\n    constructor() {\n        // Object.defineProperty(this, \"id\", { value: _object3DId++ });\n        this.uuid = MathTool.generateUUID();\n        this.name = \"\";\n        this.type = \"Object3D\";\n        this.parent = null;\n        this.children = [];\n        this.up = Object3D.DefaultUp.clone();\n        const position = new Vec3();\n        const rotation = new Euler();\n        const quaternion = new Quat();\n        const scale = new Vec3(1, 1, 1);\n        function onRotationChange() {\n            quaternion.setFromEuler(rotation);\n        }\n        Object.defineProperties(this, {\n            position: {\n                configurable: true,\n                enumerable: true,\n                value: position,\n            },\n            rotation: {\n                configurable: true,\n                enumerable: true,\n                value: rotation,\n            },\n            quaternion: {\n                configurable: true,\n                enumerable: true,\n                value: quaternion,\n            },\n            scale: {\n                configurable: true,\n                enumerable: true,\n                value: scale,\n            },\n            modelViewMatrix: {\n                value: new Mat4(),\n            },\n            normalMatrix: {\n                value: new Mat3(),\n            },\n        });\n        this.matrix = new Mat4();\n        this.matrixWorld = new Mat4();\n        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n        this.matrixWorldNeedsUpdate = false;\n        // this.layers = new Layers();\n        this.visible = true;\n        this.castShadow = false;\n        this.receiveShadow = false;\n        this.frustumCulled = true;\n        this.renderOrder = 0;\n        this.animations = [];\n        this.userData = {};\n    }\n    copy(source, recursive) {\n        throw new Error(\"Method not implemented.\");\n    }\n    onBeforeRender() { }\n    onAfterRender() { }\n    applyMatrix4(matrix) {\n        if (this.matrixAutoUpdate)\n            this.updateMatrix();\n        this.matrix.mul(matrix);\n        this.matrix.decompose(this.position, this.quaternion, this.scale);\n    }\n    applyQuaternion(q) {\n        this.quaternion.mul(q);\n        return this;\n    }\n    setRotationFromAxisAngle(axis, angle) {\n        // assumes axis is normalized\n        this.quaternion.setFromAxisAngle(axis, angle);\n    }\n    setRotationFromEuler(euler) {\n        this.quaternion.setFromEuler(euler);\n    }\n    setRotationFromMatrix(m) {\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n        this.quaternion.setFromMat4(m);\n    }\n    setRotationFromQuaternion(q) {\n        // assumes q is normalized\n        this.quaternion.copy(q);\n    }\n    rotateOnAxis(axis, angle) {\n        // rotate object on axis in object space\n        // axis is assumed to be normalized\n        _q1.setFromAxisAngle(axis, angle);\n        this.quaternion.mul(_q1);\n        return this;\n    }\n    rotateOnWorldAxis(axis, angle) {\n        // rotate object on axis in world space\n        // axis is assumed to be normalized\n        // method assumes no rotated parent\n        _q1.setFromAxisAngle(axis, angle);\n        this.quaternion.mul(_q1);\n        return this;\n    }\n    rotateX(angle) {\n        return this.rotateOnAxis(_xAxis, angle);\n    }\n    rotateY(angle) {\n        return this.rotateOnAxis(_yAxis, angle);\n    }\n    rotateZ(angle) {\n        return this.rotateOnAxis(_zAxis, angle);\n    }\n    translateOnAxis(axis, distance) {\n        // translate object by distance along axis in object space\n        // axis is assumed to be normalized\n        _v1.copy(axis).applyQuaternion(this.quaternion);\n        this.position.add(_v1.multiplyScalar(distance));\n        return this;\n    }\n    translateX(distance) {\n        return this.translateOnAxis(_xAxis, distance);\n    }\n    translateY(distance) {\n        return this.translateOnAxis(_yAxis, distance);\n    }\n    translateZ(distance) {\n        return this.translateOnAxis(_zAxis, distance);\n    }\n    localToWorld(vector) {\n        return vector.applyMatrix4(this.matrixWorld);\n    }\n    worldToLocal(vector) {\n        return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());\n    }\n    lookAt(x) {\n        // This method does not support objects having non-uniformly-scaled parent(s)\n        _target.copy(x);\n        const parent = this.parent;\n        this.updateWorldMatrix(true, false);\n        _position.setFromMatrixPosition(this.matrixWorld);\n        if (this.isCamera || this.isLight) {\n            _m1.setLookAt(_position, _target, this.up);\n        }\n        else {\n            _m1.setLookAt(_target, _position, this.up);\n        }\n        this.quaternion.setFromMat4(_m1);\n        // if (parent) {\n        //     _m1.extractRotation(parent.matrixWorld);\n        //     _q1.setFromMat4(_m1);\n        //     this.quaternion.mul(_q1.invert());\n        // }\n    }\n    getWorldPosition(target) {\n        this.updateWorldMatrix(true, false);\n        return target.setFromMatrixPosition(this.matrixWorld);\n    }\n    getWorldQuaternion(target) {\n        this.updateWorldMatrix(true, false);\n        this.matrixWorld.decompose(_position, target, _scale);\n        return target;\n    }\n    getWorldScale(target) {\n        this.updateWorldMatrix(true, false);\n        this.matrixWorld.decompose(_position, _quaternion, target);\n        return target;\n    }\n    getWorldDirection(target) {\n        this.updateWorldMatrix(true, false);\n        const e = this.matrixWorld.data;\n        return target.set(e[8], e[9], e[10]).normalize();\n    }\n    updateMatrix() {\n        this.matrix.compose(this.position, this.quaternion, this.scale);\n        this.matrixWorldNeedsUpdate = true;\n    }\n    updateMatrixWorld(force) {\n        if (this.matrixAutoUpdate)\n            this.updateMatrix();\n        if (this.matrixWorldNeedsUpdate || force) {\n            if (this.parent === null) {\n                this.matrixWorld.copy(this.matrix);\n            }\n            else {\n                this.matrixWorld.mul2(this.parent.matrixWorld, this.matrix);\n            }\n            this.matrixWorldNeedsUpdate = false;\n            force = true;\n        }\n        // update children\n        // const children = this.children;\n        // for (let i = 0, l = children.length; i < l; i++) {\n        //     children[i].updateMatrixWorld(force);\n        // }\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n        const parent = this.parent;\n        if (updateParents === true && parent !== null) {\n            parent.updateWorldMatrix(true, false);\n        }\n        if (this.matrixAutoUpdate)\n            this.updateMatrix();\n        if (this.parent === null) {\n            this.matrixWorld.copy(this.matrix);\n        }\n        else {\n            this.matrixWorld.mul2(this.parent.matrixWorld, this.matrix);\n        }\n        // update children\n        if (updateChildren === true) {\n            const children = this.children;\n            for (let i = 0, l = children.length; i < l; i++) {\n                children[i].updateWorldMatrix(false, true);\n            }\n        }\n    }\n}\nObject3D.DefaultUp = new Vec3(0, 1, 0);\nObject3D.DefaultMatrixAutoUpdate = true;\nObject3D.prototype.isObject3D = true;\nexport { Object3D };\n","export * from \"./postprocessing\";\n","import { __awaiter } from \"tslib\";\nimport { Geometry, planeBuilder } from \"../geometry\";\nimport { ShaderLoader } from \"../loader/shader.loader\";\nimport { Color4 } from \"../maths/math.color\";\nexport class Postprocessing {\n    constructor(app) {\n        this._engine = app.engine;\n        this._camera = app.camera;\n        this._programs = new Map();\n        this._rootPath = \"/\";\n        const model = planeBuilder(2, 2);\n        const geoInfo = {\n            indices: model.indices,\n            attributes: {\n                aPosition: {\n                    value: model.positions,\n                    itemSize: 3,\n                },\n            },\n        };\n        this._geometry = new Geometry(this._engine, geoInfo);\n        this._activeProgram = null;\n        this.clearColor = new Color4(0.2, 0.19, 0.3, 1.0);\n    }\n    get uniforms() {\n        var _a;\n        return ((_a = this._activeProgram) === null || _a === void 0 ? void 0 : _a.uniforms) || {};\n    }\n    setRootPath(v) {\n        this._rootPath = v;\n        return this;\n    }\n    _createProgramFromFiles(programName, vertexShaderPath, fragmentShaderPath, uniforms, defines) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                const vsPaths = Array.isArray(vertexShaderPath) ? vertexShaderPath : [vertexShaderPath];\n                const fsPaths = Array.isArray(fragmentShaderPath) ? fragmentShaderPath : [fragmentShaderPath];\n                new ShaderLoader(this._engine)\n                    .setPath(this._rootPath)\n                    .load({\n                    vsPaths: vsPaths,\n                    fsPaths: fsPaths,\n                })\n                    .then((shader) => {\n                    const { program, vertexShader, fragmentShader } = this._engine.enginePrograms.createProgram({\n                        vertexShader: shader.vertexShader,\n                        fragmentShader: shader.fragmentShader,\n                        defines: defines,\n                    });\n                    const uniformBlock = {\n                        blockCatch: new Map(),\n                        blockIndex: 0,\n                    };\n                    this._programs.set(programName, {\n                        vertexShader,\n                        fragmentShader,\n                        program,\n                        uniforms,\n                        uniformBlock,\n                    });\n                    resolve(program);\n                });\n            });\n        });\n    }\n    createProgramsFromFiles(programParameters) {\n        return new Promise((resolve, reject) => {\n            for (var programName in programParameters) {\n                var parameters = programParameters[programName];\n                this._createProgramFromFiles(programName, parameters.vertexShader, parameters.fragmentShader, parameters.uniforms, parameters.defines).then(() => {\n                    const total = Object.keys(programParameters).length;\n                    if (this._programs.size === total) {\n                        return resolve(total);\n                    }\n                });\n            }\n        });\n    }\n    bindFramebuffer(target) {\n        this._engine.engineRenderTarget.setRenderTarget(target);\n        return this;\n    }\n    clear() {\n        this._engine.engineState.clear({\n            color: this.clearColor,\n        });\n        return this;\n    }\n    viewport() {\n        const width = this._engine.renderingCanvas.clientWidth;\n        const height = this._engine.renderingCanvas.clientHeight;\n        this._engine.engineViewPort.setViewport({\n            x: 0,\n            y: 0,\n            width,\n            height,\n        });\n        return this;\n    }\n    useProgram(programName) {\n        this._activeProgram = this._programs.get(programName);\n        if (this._activeProgram) {\n            this._engine.enginePrograms.useProgram(this._activeProgram.program);\n        }\n        return this;\n    }\n    render() {\n        if (!this._activeProgram)\n            return this;\n        const { program, uniforms, uniformBlock } = this._activeProgram;\n        const { geometryInfo } = this._geometry;\n        this._geometry.setBuffers(this._activeProgram.program);\n        this._engine.enginePrograms.useProgram(program);\n        if (uniforms) {\n            this._engine.engineUniform.handleUniform(program, uniforms, uniformBlock);\n            this._engine.engineUniform.setSystemUniform(program, this._camera);\n        }\n        this._engine.engineDraw.draw({\n            type: geometryInfo.type,\n            indexed: geometryInfo.indices,\n            count: geometryInfo.count,\n        });\n        return this;\n    }\n    setUniform(name, value) {\n        if (this._activeProgram && this._activeProgram.uniforms && this._activeProgram.uniforms[name]) {\n            this._activeProgram.uniforms[name].value = value;\n        }\n        return this;\n    }\n}\n","export * from \"./render.target\";\nexport * from \"./renderer\";\n","import { TextureAddress, TextureFilter, TextureFormat } from \"../engines\";\nimport { Texture } from \"../texture\";\nexport class RenderTarget {\n    constructor(engine, options) {\n        this._engine = engine;\n        this.glFrameBuffer = null;\n        this.glDepthBuffer = null;\n        this.name = options.name;\n        this.colorBuffer = new Texture(engine, {\n            width: options.width,\n            height: options.height,\n            format: TextureFormat.PIXELFORMAT_R8_G8_B8_A8,\n            addressU: TextureAddress.ADDRESS_CLAMP_TO_EDGE,\n            addressV: TextureAddress.ADDRESS_CLAMP_TO_EDGE,\n            minFilter: TextureFilter.FILTER_LINEAR,\n            magFilter: TextureFilter.FILTER_LINEAR,\n        });\n        this.colorBuffer.needsUpload = true;\n        this.stencil = false;\n        this.depth = options.depth !== undefined ? options.depth : false;\n        if (this.depth) {\n            this.depthBuffer = new Texture(engine, {\n                width: options.width,\n                height: options.height,\n                format: TextureFormat.PIXELFORMAT_DEPTH,\n                addressU: TextureAddress.ADDRESS_CLAMP_TO_EDGE,\n                addressV: TextureAddress.ADDRESS_CLAMP_TO_EDGE,\n                minFilter: TextureFilter.FILTER_NEAREST,\n                magFilter: TextureFilter.FILTER_NEAREST,\n            });\n            this.depthBuffer.needsUpload = true;\n        }\n        else {\n            this.stencil = options.stencil !== undefined ? options.stencil : false;\n        }\n        this.samples = options.samples !== undefined ? Math.min(options.samples, this._engine.capabilities.maxSamples) : 1;\n        this._engine.engineRenderTarget.initRenderTarget(this);\n    }\n    /**\n     * Width of the render target in pixels.\n     *\n     * @type {number}\n     */\n    get width() {\n        return this.colorBuffer ? this.colorBuffer.width : this.depthBuffer.width;\n    }\n    /**\n     * Height of the render target in pixels.\n     *\n     * @type {number}\n     */\n    get height() {\n        return this.colorBuffer ? this.colorBuffer.height : this.depthBuffer.height;\n    }\n}\n","// WebGLIndexedBufferRenderer.js\nimport { UniformsType } from \"../engines/engine.enum\";\nimport { Color4 } from \"../maths/math.color\";\nimport { Mat4 } from \"../maths/math.mat4\";\nexport default class Renderer {\n    constructor(engine) {\n        this._engine = engine;\n        this.currentPrograme = null;\n        this.currentRenderTarget = null;\n        this.clearColor = new Color4(0.2, 0.19, 0.3, 1.0);\n    }\n    /**\n     * uniform\n     * @param program\n     * @param mesh\n     * @param camera\n     */\n    _setMeshUniform(program, mesh, camera) {\n        camera.updateMatrix();\n        camera.updateMatrixWorld();\n        camera.updateProjectionMatrix();\n        mesh.updateMatrix();\n        this._engine.engineUniform.setUniform(program, \"projectionMatrix\", camera.projectionMatrix.data, UniformsType.Mat4);\n        const modelViewMatrix = new Mat4();\n        modelViewMatrix.mul2(camera.matrixWorldInverse, mesh.matrix);\n        this._engine.engineUniform.setUniform(program, \"modelViewMatrix\", modelViewMatrix.data, UniformsType.Mat4);\n        this._engine.engineUniform.setUniform(program, \"world\", mesh.matrix.data, UniformsType.Mat4);\n        // : world -> eye\n        mesh.normalMatrix.getNormalMatrix(modelViewMatrix);\n        this._engine.engineUniform.setUniform(program, \"normalMatrix\", mesh.normalMatrix.data, UniformsType.Mat4);\n        this._engine.engineUniform.setUniform(program, \"modelMatrix\", mesh.matrix.data, UniformsType.Mat4);\n    }\n    // webgl\n    // _readMaterial(material) {\n    //     const gl = dao.getData(\"gl\");\n    //     const { blending, depthTest, side } = material;\n    //     const { blendingType, blendRGBASrc, blendRGBADst, blendRGB_ASrc, blendRGB_ADst } = material;\n    //     WebGLInterface.setDepthTest(gl, depthTest);\n    //     WebGLInterface.setBlend(gl, blending, blendingType, blendRGBASrc, blendRGBADst, blendRGB_ASrc, blendRGB_ADst);\n    //     WebGLInterface.setSide(gl, side);\n    //     WebGLInterface.cullFace(gl, false);\n    // }\n    renderMesh(mesh, camera) {\n        if (mesh.visible == false)\n            return;\n        const { geometry, material } = mesh;\n        const { geometryInfo } = geometry;\n        const program = material.program;\n        mesh.active();\n        this._setMeshUniform(program, mesh, camera);\n        this._engine.engineUniform.setSystemUniform(program, camera);\n        this._engine.engineDraw.draw({\n            type: geometryInfo.type,\n            indexed: geometryInfo.indices,\n            count: geometryInfo.count,\n        });\n        // \n        // if (this.currentRenderTarget && this.currentRenderTarget.isMultisample) {\n        //     const { width, height } = this.currentRenderTarget;\n        //     gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.currentRenderTarget.multiSampleFrameBuffer);\n        //     gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.currentRenderTarget.normalFrameBuffer);\n        //     gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n        // }\n    }\n    setRenderTarget(target) {\n        this._target = target;\n        this._engine.engineRenderTarget.setRenderTarget(target);\n    }\n    clear() {\n        this._engine.engineState.clear({\n            color: this.clearColor,\n        });\n    }\n    viewport() {\n        let width = this._engine.renderingCanvas.clientWidth;\n        let height = this._engine.renderingCanvas.clientHeight;\n        if (this._target) {\n            width = this._target.width;\n            height = this._target.height;\n        }\n        this._engine.engineViewPort.setViewport({\n            x: 0,\n            y: 0,\n            width,\n            height: height,\n        });\n    }\n    renderScene(scene, camera) {\n        this.clear();\n        this.viewport();\n        for (let i = 0; i < scene.children.length; i++) {\n            const mesh = scene.children[i];\n            this.renderMesh(mesh, camera);\n        }\n    }\n}\n","export * from \"./scene\";\n","export class Scene {\n    constructor(engine) {\n        this._engine = engine;\n        this.children = [];\n    }\n    add(object) {\n        this.children.push(object);\n    }\n    remove(object) {\n        const index = this.children.indexOf(object);\n        if (index !== -1) {\n            this.children.splice(index, 1);\n        }\n    }\n}\n","export * from \"./texture\";\n","import { CompareFunc, TextureAddress, TextureFilter, TextureFormat } from \"../engines/engine.enum\";\nimport { MathTool } from \"../maths/math.tool\";\nlet id = 0;\nexport class Texture {\n    constructor(engine, options) {\n        this.uuid = id++;\n        this._compareOnRead = false;\n        this._cubemap = false;\n        this._volume = false;\n        this._engine = engine;\n        this.needsUpload = false;\n        if (!options) {\n            options = {};\n        }\n        this._source = null;\n        this._minFilter = options.minFilter !== undefined ? options.minFilter : TextureFilter.FILTER_LINEAR_MIPMAP_LINEAR;\n        this._magFilter = options.magFilter !== undefined ? options.magFilter : TextureFilter.FILTER_LINEAR;\n        this._addressU = options.addressU !== undefined ? options.addressU : TextureAddress.ADDRESS_REPEAT;\n        this._addressV = options.addressV !== undefined ? options.addressV : TextureAddress.ADDRESS_REPEAT;\n        this._flipY = options.flipY !== undefined ? options.flipY : true;\n        this._format = options.format !== undefined ? options.format : TextureFormat.PIXELFORMAT_R8_G8_B8_A8;\n        this._compareOnRead = options.compareOnRead !== undefined ? options.compareOnRead : false;\n        this._compareFunc = options.compareFunc !== undefined ? options.compareFunc : CompareFunc.FUNC_LESS;\n        this._premultiplyAlpha = options.premultiplyAlpha !== undefined ? options.premultiplyAlpha : false;\n        this._parameterFlags = 255; // 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128\n        this._width = options.width !== undefined ? options.width : 0;\n        this._height = options.height !== undefined ? options.height : 0;\n    }\n    get parameterFlags() {\n        return this._parameterFlags;\n    }\n    set parameterFlags(v) {\n        this._parameterFlags = v;\n    }\n    get cubemap() {\n        return this._cubemap;\n    }\n    get volume() {\n        return this._volume;\n    }\n    get flipY() {\n        return this._flipY;\n    }\n    set flipY(v) {\n        this._flipY = v;\n    }\n    set premultiplyAlpha(premultiplyAlpha) {\n        if (this._premultiplyAlpha !== premultiplyAlpha) {\n            this._premultiplyAlpha = premultiplyAlpha;\n            this.needsUpload = true;\n        }\n    }\n    get premultiplyAlpha() {\n        return this._premultiplyAlpha;\n    }\n    get minFilter() {\n        return this._minFilter;\n    }\n    set minFilter(v) {\n        this._minFilter = v;\n        this._parameterFlags |= 1;\n    }\n    get magFilter() {\n        return this._magFilter;\n    }\n    set magFilter(v) {\n        this._magFilter = v;\n        this._parameterFlags |= 2;\n    }\n    get addressU() {\n        return this._addressU;\n    }\n    set addressU(v) {\n        this._addressU = v;\n        this._parameterFlags |= 4;\n    }\n    get addressV() {\n        return this._addressV;\n    }\n    set addressV(v) {\n        this._addressV = v;\n        this._parameterFlags |= 8;\n    }\n    get format() {\n        return this._format;\n    }\n    set format(v) {\n        this._format = v;\n    }\n    /**\n     * Returns true if all dimensions of the texture are power of two, and false otherwise.\n     *\n     * @type {boolean}\n     */\n    get pot() {\n        return MathTool.powerOfTwo(this._width) && MathTool.powerOfTwo(this._height);\n    }\n    /**\n     * When enabled, and if texture format is {@link PIXELFORMAT_DEPTH} or\n     * {@link PIXELFORMAT_DEPTHSTENCIL}, hardware PCF is enabled for this texture, and you can get\n     * filtered results of comparison using texture() in your shader (WebGL2 only).\n     *\n     * @type {boolean}\n     */\n    set compareOnRead(v) {\n        if (this._compareOnRead !== v) {\n            this._compareOnRead = v;\n            this._parameterFlags |= 32;\n        }\n    }\n    get compareOnRead() {\n        return this._compareOnRead;\n    }\n    set compareFunc(v) {\n        if (this._compareFunc !== v) {\n            this._compareFunc = v;\n            this._parameterFlags |= 64;\n        }\n    }\n    get compareFunc() {\n        return this._compareFunc;\n    }\n    get source() {\n        return this._source;\n    }\n    get width() {\n        return this._width;\n    }\n    set width(v) {\n        this._width = v;\n    }\n    get height() {\n        return this._height;\n    }\n    set height(v) {\n        this._height = v;\n    }\n    set source(v) {\n        this._source = v;\n        if (v.width !== undefined)\n            this._width = v.width;\n        if (v.height !== undefined)\n            this._height = v.height;\n        this.needsUpload = true;\n    }\n}\n"],"sourceRoot":""}