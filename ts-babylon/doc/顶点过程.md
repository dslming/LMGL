```js
VertexData.CreateSphere(params) {
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}

class SphereBuilder {
  static CreateSphere(name, options, scene = null) {
    var sphere = new Mesh(name, scene);
    var vertexData = VertexData.CreateSphere(options);
    vertexData.applyToMesh(sphere, options.updatable);
    return sphere;
  }
}

class VertexData {
  public applyToMesh(mesh: Mesh, updatable?: boolean): VertexData {
    this._applyTo(mesh, updatable);
    return this;
  }

  private _applyTo(geometry: IGetSetVerticesData, updatable: boolean = false): VertexData {
    if (this.positions) {
        geometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);
    }

    if (this.uvs) {
        geometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);
    }

    if (this.indices) {
        geometry.setIndices(this.indices, null, updatable);
    } else {
        geometry.setIndices([], null);
    }

    return this;
  }
}


class Geometry {
  public setVerticesData(kind: string, data: FloatArray, updatable: boolean = false, stride?: number): void {
    var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);
    this.setVerticesBuffer(buffer);
  }

  public setVerticesBuffer(buffer: VertexBuffer, totalVertices: Nullable<number> = null): void {
    for (var index = 0; index < numOfMeshes; index++) {
      var mesh = meshes[index];
      mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
      mesh._createGlobalSubMesh(false);
      mesh.computeWorldMatrix(true);
    }
  }
}
```

```js
class Mesh {
     public _createGlobalSubMesh(force: boolean): Nullable<SubMesh> {
        var totalVertices = this.getTotalVertices();
        this.releaseSubMeshes();
        return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);
    }
}
```

```js
class SubMesh {

}
```
